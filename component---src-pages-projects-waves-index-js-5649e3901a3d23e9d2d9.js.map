{"version":3,"sources":["webpack:///./src/img/frequencyrange.png","webpack:///./src/constants/waves/nerdamer/Calculus.js","webpack:///./src/styles/waves/waves.module.css","webpack:///./src/constants/waves/nerdamer/Solve.js","webpack:///./src/img/hierarchy.png","webpack:///./node_modules/decimal.js/decimal.js","webpack:///./src/constants/waves/nerdamer/Algebra.js","webpack:///./node_modules/react-katex/dist/react-katex.js","webpack:///./src/img/wavestructure.png","webpack:///./node_modules/d3-shape/node_modules/d3-path/src/path.js","webpack:///./node_modules/d3-shape/src/point.js","webpack:///./node_modules/d3-shape/src/line.js","webpack:///./src/components/waves/introWave.js","webpack:///./src/constants/waves/nerdamer/nerdamer.js","webpack:///./src/constants/waves/derivePoints.js","webpack:///./src/constants/waves/formula.js","webpack:///./src/components/waves/wave.js","webpack:///./src/constants/waves/buildFormula.js","webpack:///./src/components/waves/waveBuilder.js","webpack:///./src/components/waves/waveForm.js","webpack:///./src/pages/projects/waves/index.js"],"names":["module","exports","nerdamer","require","core","getCore","_","PARSER","Frac","Settings","isSymbol","Utils","FN","groups","Symbol","text","inBrackets","isInt","format","even","evaluate","N","S","PL","CP","CB","EX","P","LOG","SQRT","SIN","COS","TAN","SEC","CSC","COT","SINH","COSH","NoIntegralFound","msg","this","message","prototype","Error","hasIntegral","containsFunction","fnTransform","group","retval","a","args","m","multiplier","sym","clone","toUnitMultiplier","isLinear","fname","parse","power","equals","lessThan","negate","n","double_angle","pow","toLinear","transformed","expand","each","s","t","add","multiply","hasTrig","isConstant","in_trig","in_inverse_trig","symbols","x","Expression","symbol","toCommonDenominator","isComposite","denominator","numerator","getDenom","num","getNum","den","factor","divide","Algebra","indexOf","in_htrig","all_functions","arr","i","l","length","cosAsinBtransform","cosAsinBtranform","symbol1","symbol2","b","cosAsinAtransform","cosAsinAtranform","Number","sinAsinBtransform","trigTransform","map","toString","integration_depth","max_lim_depth","__","Calculus","version","sum","fn","index","start","end","exceptions","NerdamerTypeError","value","isNumericSymbol","modifier","block","f","subs","ans","symfunction","arguments","product","diff","wrt","nth","isVector","vector","Vector","elements","push","isMatrix","matrix","Matrix","j","set","d","undefined","variables","sp","derive","polydiff","contains","subtract","cp","g","collectSymbols","result","df","product_rule","qdiff","arg","String","x_","y_","LOG10","updateHash","val","altVal","integration","u_substitution","dx","try_combo","q","do_fn_sub","subbed","integrate","u","sub","Q","g1","g2","poly_integrate","p","dc","decompose_arg","xp","dc2","new_val","by_parts","integrated","A","Factor","B","f1","f2","toDecimal","stop","warn","partial_fraction","input","depth","opt","partial_fractions","PartFrac","partfrac","get_udv","parts","setSymbol","unwrapSQRT","dv","part","trig_sub","greaterThan","getU","du","integral","clearU","o","udv","v","vdu","uv","integral_vdu","c","vdu_s","previous","stripVar","isE","is_cyclic","pop","rem","decompose_fn","original_symbol","dt","vars","isNaN","error","previousGroup","PARENTHESIS","aa","decomp","ax","b_is_positive","unwrapAbs","C","D","E","F","L1","L2","br","d2","sqrt_a","sqrt_ax","sqa","sqb","aob","bsqi","invert","Math","abs","was_factored","degree","fx","sq","sqComplete","e","u_du","ag","decomposed","hasFunc","a_","b_","rd","rd2","na","r","w","n1","n2","parse_str","coeff","cfsymbol","isPoly","sort","unwrapped","sym1","sym2","fn1","fn2","arg1","arg2","new_sym","p1_even","p2_even","k","sign","trans","bx","sym1_is_linear","pd","min","apply","keys","pc","f_is_linear","p1","p2","dummy","bksub","ASIN","u_transform","sqrt","expanded","y","U","scope","U2","factors","Classes","Factors","coeffFactor","div","cosn","X","sym2_clone","sa","sb","nq","syma","symb","first","intg","DivisionByZero","defint","from","to","get_value","point","Limit","limit","build","Math2","num_integrate","upper","lower","interval","diverges","lim","gin","lim_sign","isInfinity","fm","gm","L","lim1","lim2","indeterminate","ft","gt","t_symbol","den_is_zero","infinity","rewriteToLog","getSubbed","isInterval","isConvergent","Simplify","simplify","_num","_den","isOne","symbol_","base","lim_base","lim_pow","evaluates","trial","FACTORIAL","_lim","_symbols","fns","unshift","Fresnel","register","name","visible","numargs","api","_A","_C","explode","remove","range","isArray","Equation","lhs","rhs","IMAGINARY","NerdamerValueError","LHS","RHS","NEWTON_EPSILON","EPSILON","MAX_NEWTON_NUM","make_pi_conversions","ROOTS_PER_SIDE","MAX_NEWTON_ITERATIONS","SOLVE_RADIUS","STEP_SIZE","MAX_NON_LINEAR_TRIES","NON_LINEAR_JUMP_AT","NON_LINEAR_JUMP_SIZE","NON_LINEAR_START","NEWTON_SLICES","SOLUTION_PROXIMITY","FILTER_SOLUTIONS","MAX_SOLVE_DEPTH","hasNegativeTerms","option","toLHS","eqn","removeDenom","_t","newRHS","isZero","latex","join","solveFor","solve","arrayUnique","concat","jacobian","eqns","getSystemVariables","forEach","eq","max","cMatrix","setEq","checkAll","test","Solve","solutions","variable","solution","es","split","solveNonLinearSystem","tries","max_tries","halfway","floor","iters","xn1","norm","lnorm","xn","jump_at","jump","found","create_subs","get","max_iter","f_eqns","J","systemSolutions","round","expand_result","callback","SOLUTIONS_AS_OBJECT","idx","valueOf","call","solveSystem","var_array","allLinear","setVar","coeffs","cf","arraySum","term","check","z","err","tparts","determinant","SolveError","quad","discriminant","det","cubic","d_o","c_o","b_o","a_o","d0","Ct","replace","quartic","D0","D1","divideAndConquer","solve_for","sols","unwrapPARENS","csolve","pn","pf","sr","roots","root","str","toPolarFormArray","getPoints","step","points","last","last_sign","rside","side","num_roots","xi","hits","isFinite","test_side","Newton","fp","maxiter","iter","x0","fx0","rewrite","for_variable","sqrts","distributeMultiplier","sqrtSolve","filter","isImaginary","existing","add_to_result","has_trig","r_is_symbol","sol","temp","PI","r_str","sf","numvars","cfact","fractionals","correct_denom","original","is_sqrt","min_p","arrayMin","corrected","separate","inverseFunctionSolve","fkeys","getNumberSymbolics","deg","getCoeffs","was_calculated","proots","factored","points1","points2","points3","console","log","separated","rw","neq","parent","globalScope","Decimal","inexact","quadrant","EXP_LIMIT","NUMERALS","LN10","DEFAULTS","precision","rounding","modulo","toExpNeg","toExpPos","minE","maxE","crypto","external","invalidArgument","decimalError","mathfloor","mathpow","isBinary","isHex","isOctal","isDecimal","BASE","LN10_PRECISION","PI_PRECISION","digitsToString","ws","indexOfLastWord","getZeroString","checkInt32","checkRoundingDigits","rm","repeating","di","ceil","convertBase","baseIn","baseOut","arrL","strL","charAt","reverse","absoluteValue","constructor","finalise","comparedTo","cmp","xdL","ydL","xd","yd","xs","ys","NaN","cosine","cos","pr","Ctor","sd","len","tinyPow","taylorSeries","times","cos2x","minus","plus","toLessThanHalfPi","neg","cubeRoot","cbrt","rep","t3","t3plusx","toExponential","slice","decimalPlaces","dp","dividedBy","dividedToIntegerBy","divToInt","greaterThanOrEqualTo","gte","hyperbolicCosine","cosh","one","cosh2_x","d8","hyperbolicSine","sinh","sinh2_x","d5","d16","d20","hyperbolicTangent","tanh","inverseCosine","acos","halfPi","isNeg","getPi","asin","inverseHyperbolicCosine","acosh","lte","ln","inverseHyperbolicSine","asinh","inverseHyperbolicTangent","atanh","wpr","xsd","inverseSine","atan","inverseTangent","px","x2","isInteger","isNegative","isPositive","isPos","lt","lessThanOrEqualTo","logarithm","isBase10","inf","naturalLogarithm","getLn10","xe","xLTy","shift","getBase10Exponent","mod","naturalExponential","exp","negated","carry","getPrecision","sine","sin","sin2_x","squareRoot","tangent","tan","mul","rL","toBinary","toStringBinary","toDecimalPlaces","toDP","finiteToString","toFixed","toFraction","maxD","d1","n0","toHexadecimal","toHex","toNearest","toNumber","toOctal","toPower","yn","intPow","toPrecision","toSignificantDigits","toSD","truncated","trunc","toJSON","multiplyInteger","compare","aL","bL","logBase","more","prod","prodL","qd","remL","rem0","xL","yd0","yL","yz","isTruncated","digits","roundUp","xdi","out","isExp","nonFiniteToString","zs","truncate","isOdd","maxOrMin","ltgt","guard","c0","x1","parseDecimal","search","substring","charCodeAt","parseOther","divisor","isFloat","toLowerCase","isHyperbolic","pi","atan2","config","obj","useDefaults","defaults","ps","getRandomValues","randomBytes","hypot","isDecimalInstance","log2","log10","random","Uint32Array","copy","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","EUCLID","hasOwnProperty","CONST_HASH","math","importFunctions","Polynomial","order","InvalidVariableNameError","fill","MVTerm","terms","image","fromArray","fit","c1","c2","Array","absEquals","trim","equalsZero","modP","up_one","next","poly","dividend","arrayClone","mp","quotient","l1","l2","lc","monic","gcd","QGCD","new_array","gcf","toPolynomial","ca","fnz","parr","incl_img","dsc","squareFree","output","equalsNumber","toSymbol","with_order","imaginary","tBase","nterm","updateCount","altVar","sameVars","groupTerms","egrouped","grouped","el","collectFactors","fo","firstObject","key","preAdd","pFactor","is_constant","Object","values","merge","count","clean","h","getVars","getRevMap","rev_map","mapped","generateImage","getImg","mvterm","new_mvterm","toMapObj","filledArray","clss","arrSum","haveIntersection","some","subFunctions","tvar","getFunctionsSubs","decp","known_roots","get_roots","rarr","powers","calcroots","lowest_pow","lowest_symbol","minpower","arrayMax","last_power","ValueLimitExceededError","zeroi","degreePar","Degree","zeror","QuadSD_ak1","NN","iPar","calcSC_ak1","DBL_EPSILON","K","qk","sdPar","dumFlag","a3","a1","a7","nextK_ak1","tFlag","qp","newest_ak1","a4","a5","b1","b2","c3","c4","Quad_ak1","si","lr","li","QuadIT_ak1","uu","vv","calcPar","ee","omp","relstp","ui","vi","zm","qPar","triedFlag","NZ","szr","szi","lzr","lzi","RealIT_ak1","kv","ms","pv","nm1","Fxshfr_ak1","MDP1","betas","betav","oss","ots","otv","ovv","ss","ts","tss","tv","tvv","fflag","spass","stry","vpass","vtry","svk","iFlag","degPar","bnd","ff","moduli_max","moduli_min","sc","xm","bb","cc","xxx","jj","NM1","zerok","LB2","LN2","pt","Fxshfr_Par","LO","MIN_VALUE","cosr","sinr","xx","yy","MAX_VALUE","rpSolve","img","real","nroots","froot","guess","Function","done","safety","newtonraph","sumProd","polyPowers","mix","include_negatives","ll","common","zeroes","exit","tp","allSame","n_terms","n_zeroes","_symbol","_factor","_factored","quadFactor","root1","root2","isSimple","untouched","den_array","num_array","dfact","nfact","strip","unstrip","multiVar","all_S","all_unit","coeff_factors","power_factors","powerFactor","mfactor","t_factors","trialAndError","tf_symbol","t_factor","reduce","nn","sqfr","allNumeric","cnst","cfactors","ifactor","candidate","ltfactors","isubbed","nfactors","lc_is_neg","cnst_is_neg","factor_found","isPrime","mSqfrFactor","can_divide","is_factor","sqdiff","remove_square","obj_array","constants","powSimp","factors2","sorted","maxes","new_factor","divided","neg_numeric_factor","status","sg","arguments2Array","appeared","splice","every","aggregate","gcd_","lcm","gcd_m","GCD","gcd_v","gcd_p","vars_a","vars_b","T","multipliers","numer","prev","curr","denom_args","size","mask","results","total","isVariableSymbol","denom","remainder","create","symbol1_has_func","symbol2_has_func","parse_funcs","quot","reconvert","get_unique_max","any","t_map","init_sort","is_larger","s1","s2","get_det","lookat","umax","is_equal","max1","max2","idx1","idx2","item1","item2","cterm","lead_var","blv","alv","checked","tt","try_better_lead_var","fdt","fnt","nd","dividend_larger","cur","line","v1","v2","convertToVector","dy","createTemplate","denom_factors","f_array","factors_vec","degrees","efactor","as_array","ofactors","nterms","dterms","M","ks","template","tfactors","fillHoles","transpose","partials","denominators","e2","distributeExponent","raw","complexSimp","ac","bd","bc","ad","cd","r1","r2","i1","i2","realpart","imagpart","trigSimp","sym_array","tr","fracSimp","ratSimp","simplified","useAlgebraDiv","divideFn","calls","useParserDiv","React","PropTypes","KaTeX","createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","Constructor","protoProps","staticProps","createMathComponent","Component","_ref","displayMode","_React$Component","MathComponent","instance","TypeError","classCallCheck","_this","self","ReferenceError","possibleConstructorReturn","__proto__","getPrototypeOf","usedProp","state","createNewState","subClass","superClass","setPrototypeOf","inherits","setState","nextProps","prevState","html","generateHtml","ParseError","errorColor","renderError","renderToString","throwOnError","_state","createElement","InlineMath$1","dangerouslySetInnerHTML","__html","BlockMath$1","InlineMath","BlockMath","factory","tau","tauEpsilon","Path","_x0","_y0","_x1","_y1","path","moveTo","closePath","lineTo","quadraticCurveTo","y1","bezierCurveTo","y2","arcTo","y0","x21","y21","x01","y01","l01_2","x20","y20","l21_2","l20_2","l21","l01","t01","t21","arc","a0","ccw","cw","da","rect","defined","constant","context","curve","data","buffer","defined0","lineStart","lineEnd","IntroWave","radius","amplitude","idxPoints","useMemo","curveFunc","curveNatural","canvasRef","useRef","useEffect","svg","select","current","style","width","height","cynPath","append","attr","magPath","yelPath","timer","time","cynPoints","magPoints","yelPoints","buildWave","ref","className","waveStyles","derivePoints","calcNums","dx2","Set","formula","svgHeight","velocity","Wave","type","frequency","position","_type","_amplitude","_frequency","_position","_time","_speed","_svgHeight","_svgWidth","_derivedPoints","_x","_scale","_y","svgVerticalShift","scaleLinear","domain","setSize","animate","speed","selection","buildFormula","waves","buildPoints","WaveBuilder","Waveform","svgDOM","wave","wb","transformWave","WavesPost","src","hierarchy","alt","structure","href"],"mappings":"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","file":"component---src-pages-projects-waves-index-js-5649e3901a3d23e9d2d9.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/frequencyrange-679c77dd6ec5a94d0cd4fbba43af4819.png\";","/* eslint-disable */\n\n/*\n* Author : Martin Donk\n* Website : http://www.nerdamer.com\n* Email : martin.r.donk@gmail.com\n* Source : https://github.com/jiggzson/nerdamer\n*/\n\nvar nerdamer = require('./core.js');\nrequire('./Algebra.js');\n\n(function() {\n    \"use strict\";\n    var core = nerdamer.getCore(),\n        _ = core.PARSER,\n        Frac = core.Frac,\n        Settings = core.Settings,\n        isSymbol = core.Utils.isSymbol,\n        FN = core.groups.FN,\n        Symbol = core.Symbol,\n        text = core.Utils.text,\n        inBrackets = core.Utils.inBrackets,\n        isInt = core.Utils.isInt,\n        format = core.Utils.format,\n        even = core.Utils.even,\n        evaluate = core.Utils.evaluate,\n        N = core.groups. N,\n        S = core.groups.S,\n        FN = core.groups.FN,\n        PL = core.groups.PL,\n        CP = core.groups.CP,\n        CB = core.groups.CB,\n        EX = core.groups.EX,\n        P = core.groups.P,\n        LOG = Settings.LOG, \n        EXP = 'exp', \n        ABS = 'abs', \n        SQRT = 'sqrt',\n        SIN = 'sin',  \n        COS = 'cos', \n        TAN = 'tan',\n        SEC = 'sec', \n        CSC = 'csc', \n        COT = 'cot',\n        ASIN = 'asin', \n        ACOS = 'acos', \n        ATAN = 'atan',\n        ASEC = 'asec', \n        ACSC = 'acsc', \n        ACOT = 'acot',\n        SINH = 'sinh',   \n        COSH = 'cosh',\n        TANH = 'tanh',\n        CSCH = 'csch',\n        SECH = 'sech',\n        COTH = 'coth',\n        ASECH = 'asech',\n        ACSCH = 'acsch',\n        ACOTH = 'acoth';\n        \n    //custom errors\n    function NoIntegralFound(msg){\n        this.message = msg || \"\";\n    }\n    NoIntegralFound.prototype = new Error();\n    \n    //Preparations\n    Symbol.prototype.hasIntegral = function() {\n        return this.containsFunction('integrate');\n    };\n    //transforms a function\n    Symbol.prototype.fnTransform = function() { \n        if(this.group !== FN)\n            return this;\n        var retval, a = this.args[0];\n        var m = new Symbol(this.multiplier);\n        var sym = this.clone().toUnitMultiplier();\n        if(this.isLinear()) {\n            switch(this.fname) {\n                case SINH:\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\n                    break;\n                case COSH:\n                    retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\n                    break;\n                case TANH:\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\n                    break;\n                case TAN:\n                    retval = _.parse(format('sin({0})/cos({0})', a));\n                    break;\n                case CSC:\n                    retval = _.parse(format('1/sin({0})', a));\n                    break;\n                case SEC:\n                    retval = _.parse(format('1/cos({0})', a));\n                    break;\n                default:\n                    retval = sym;\n            }\n        }\n        else if(this.power.equals(2)) {\n            switch(this.fname) {\n                case SIN:\n                    retval = _.parse(format('1/2-cos(2*({0}))/2', a));\n                    break;\n                case COS:\n                    retval = _.parse(format('1/2+cos(2*({0}))/2', a));\n                    break;\n                case TAN:\n                    //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\n                    retval = _.parse(format('sin({0})^2/cos({0})^2', a));\n                    break;\n                case COSH:\n                    retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\n                    break;\n                case SINH:\n                    retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\n                    break;\n                case TANH:\n                    retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\n                    break;\n                case SEC:\n                    retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\n                    break;\n                default:\n                    retval = sym;\n            }\n        }\n        else if(this.fname === SEC) {\n            retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\n        }\n        else if(this.fname === CSC) {\n            retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\n        }\n        else if(this.fname === TAN) {\n            if(this.power.lessThan(0)) {\n                retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\n            }\n            else {\n                retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\n            }\n        }\n        else if(this.fname === SIN && this.power.lessThan(0)) {\n            retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\n        }\n        else if(this.fname === COS && this.power.lessThan(0)) {\n            retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\n        }\n        else if(this.fname === SIN && this.power.equals(3)) {\n            retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\n        }\n        else if(this.fname === COS && this.power.equals(3)) {\n            retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\n        }\n        //cos(a*x)^(2*n) or sin(a*x)^(2*n)\n        else if((this.fname === COS || this.fname === SIN) && even(this.power)) {\n            var n = this.power/2; \n            //convert to a double angle\n            var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();\n            //raise to the n and expand\n            var transformed = _.expand(_.pow(double_angle, _.parse(n)));\n            \n            retval = new Symbol(0);\n            \n            transformed.each(function(s) {\n                var t = s.fnTransform();\n                retval = _.add(retval, t);\n            }, true);\n        }\n        else\n            retval = sym;\n        \n        return _.multiply(retval, m);\n    };\n    \n    Symbol.prototype.hasTrig = function() {\n        if(this.isConstant(true) || this.group === S)\n            return false;\n        if(this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname)))\n            return true;\n        if(this.symbols) {\n            for(var x in this.symbols)\n                if(this.symbols[x].hasTrig())\n                    return true;\n        }\n        return false;\n    };\n\n    core.Expression.prototype.hasIntegral = function() {\n        return this.symbol.hasIntegral();\n    };\n    /**\n     * Attempts to rewrite a symbol under one common denominator\n     * @param {Symbol} symbol \n     */\n    core.Utils.toCommonDenominator = function(symbol) {\n        //transform x/a+x -> (ax+x)/a\n        if(symbol.isComposite() && symbol.isLinear()) {\n            var m = new Symbol(symbol.multiplier);\n            var denominator = new Symbol(1);\n            var numerator = new Symbol(0);\n            symbol.each(function(x) {\n                denominator = _.multiply(denominator, x.getDenom());\n            }, true);\n\n            //remove the denomitor in each term\n            symbol.each(function(x) {\n                var num = x.getNum();\n                var den = x.getDenom();\n                var factor = _.multiply(num, _.divide(denominator.clone(), den));\n                numerator = _.add(numerator, factor);\n            });\n            var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\n            return retval;\n        }\n        return symbol;\n    };\n    //A function to check if a function name is an inverse trig function\n    core.Utils.in_inverse_trig = function(x) {\n        var inv_trig_fns = [ASIN, ACOS, ATAN,   ACSC, ASEC, ACOT];\n        return inv_trig_fns.indexOf(x) !== -1;\n    };\n    //A function to check if a function name is a trig function\n    core.Utils.in_trig = function(x) {\n        var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\n        return trig_fns.indexOf(x) !== -1;\n    };\n    \n    core.Utils.in_htrig = function(x) {\n        var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\n        return trig_fns.indexOf(x) !== -1;\n    };\n    \n    var all_functions = core.Utils.all_functions = function(arr) {\n        for(var i=0, l=arr.length; i<l; i++)\n            if(arr[i].group !== FN)\n                return false;\n        return true;\n    },\n    cosAsinBtransform = core.Utils.cosAsinBtranform = function(symbol1, symbol2) {\n        var a, b;\n        a = symbol1.args[0];\n        b = symbol2.args[0];\n        return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\n    },\n    cosAsinAtransform = core.Utils.cosAsinAtranform = function(symbol1, symbol2) {\n        //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\n        //we technically know how to do this transform but more is needed for correct output\n        if(Number(symbol2.power) !== 1)\n            return _.multiply(symbol1, symbol2);\n        var a;\n        a = symbol1.args[0];\n        return _.parse(format('(sin(2*({0})))/2', a));\n    },\n    sinAsinBtransform = core.Utils.cosAsinBtranform = function(symbol1, symbol2) { \n        var a, b;\n        a = symbol1.args[0];\n        b = symbol2.args[0];\n        return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\n    },\n    trigTransform = core.Utils.trigTransform = function(arr) { \n        var map = {}, symbol, t,\n            retval = new Symbol(1);\n        for(var i=0, l=arr.length; i<l; i++) {\n            symbol = arr[i]; \n\n            if(symbol.group === FN) {\n                var fname = symbol.fname;\n                \n                if(fname === COS && map[SIN]) { \n                    \n                    if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n                        t = cosAsinBtransform(symbol, map[SIN]);\n                    }\n                    else{\n                        t = cosAsinAtransform(symbol, map[SIN]);\n                    }\n                    delete map[SIN];\n                    \n                    retval = _.multiply(retval, t);\n                }\n                else if(fname === SIN && map[COS]) { \n                    if(map[COS].args[0].toString() !== symbol.args[0].toString()) {\n                        t = cosAsinBtransform(symbol, map[COS]);\n                    }\n                    else {\n                        t = cosAsinAtransform(symbol, map[COS]);\n                    }\n                    delete map[COS];\n                    \n                    retval = _.multiply(retval, t);\n                }\n                else if(fname === SIN && map[SIN]) {\n                    if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n                        t = sinAsinBtransform(symbol, map[SIN]);\n                        delete map[SIN];\n                    }\n                    else {\n                        //This should actually be redundant code but let's put just in case\n                        t = _.multiply(symbol, map[SIN]);\n                        delete map[SIN];\n                    }\n                         \n                    retval = t;\n                }\n                else {\n                    map[fname] = symbol;\n                }\n            }\n            else\n                retval = _.multiply(retval, symbol);\n        }\n        \n        //put back the remaining functions\n        for(var x in map) \n            retval = _.multiply(retval, map[x]);\n        \n        return retval;\n\n    };\n    \n    core.Settings.integration_depth = 10;\n    \n    core.Settings.max_lim_depth = 10;\n    \n    var __ = core.Calculus = {\n\n        version: '1.4.6',\n\n        sum: function(fn, index, start, end) {\n            if(!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. '+text(index)+' provided');\n            index = index.value;\n            var retval;\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n                start = Number(start);\n                end = Number(end);\n                retval = core.Utils.block(modifier, function() {\n                    var f = fn.text(),\n                        subs = {'~': true}, //lock subs. Is this even being used?\n                    retval = new core.Symbol(0);\n\n                    for(var i=start; i<=end; i++) {\n                        subs[index] = new Symbol(i); \n                        var ans = _.parse(f, subs);\n                        retval = _.add(retval, ans);\n                    }\n                    return retval;\n                });\n            }\n            else {\n                retval = _.symfunction('sum',arguments);\n            }\n\n            return retval;\n        },\n        product: function(fn, index, start, end) {\n            if(!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. '+text(index)+' provided');\n            index = index.value;\n            var retval;\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n                retval = core.Utils.block(modifier, function() {\n                    start = Number(start);\n                    end = Number(end.multiplier);\n\n                    var f = fn.text(),\n                        subs = {},\n                        retval = new core.Symbol(1);\n\n                    for(var i=start; i<=end; i++) {\n                        subs[index] = new Symbol(i); \n                        retval = _.multiply(retval, _.parse(f, subs));\n                    }\n                    return retval;\n                });\n            }\n            else {\n                retval = _.symfunction('product', arguments);\n            }\n\n            return retval;\n        },\n        diff: function(symbol, wrt, nth) { \n            if(core.Utils.isVector(symbol)) {\n                var vector = new core.Vector([]);\n                symbol.each(function(x) {\n                    vector.elements.push(__.diff(x, wrt, nth));\n                });\n                return vector;\n            }\n            else if(core.Utils.isMatrix(symbol)) {\n                var matrix = new core.Matrix();\n                symbol.each(function(x, i, j) {\n                    matrix.set(i, j, __.diff(x, wrt, nth));\n                });\n                return matrix;\n            }\n\n            var d = isSymbol(wrt) ? wrt.text() : wrt; \n            //the nth derivative\n            nth = isSymbol(nth) ? nth.multiplier : nth || 1;\n            \n            if(d === undefined) d = core.Utils.variables(symbol)[0];\n            \n            //unwrap sqrt\n            if(symbol.group === FN && symbol.fname === SQRT) {\n                var s = symbol.args[0],\n                    sp = symbol.power.clone();\n                //these groups go to zero anyway so why waste time?\n                if(s.group !== N || s.group !== P) {\n                    s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1/2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\n                    s.multiplier = s.multiplier.multiply(symbol.multiplier);\n                }\n                    \n                symbol = s;\n            }\n\n            if(symbol.group === FN && !isSymbol(symbol.power)) {\n                var a = derive(_.parse(symbol)); \n                var b = __.diff(symbol.args[0].clone(), d); \n                symbol = _.multiply(a, b);//chain rule\n            }\n            else {\n                symbol = derive(symbol);\n            }\n            \n            if(nth > 1) { \n                nth--;\n                symbol = __.diff(symbol, wrt, nth);\n            }\n\n            return symbol;\n  \n             // Equivalent to \"derivative of the outside\".\n            function polydiff(symbol) {\n                if(symbol.value === d || symbol.contains(d, true)) { \n                    symbol.multiplier = symbol.multiplier.multiply(symbol.power);\n                    symbol.power = symbol.power.subtract(new Frac(1)); \n                    if(symbol.power.equals(0)) {\n                        symbol = Symbol(symbol.multiplier);\n                    }\n                } \n                \n                return symbol;\n            };\n            function derive(symbol) { \n                var g = symbol.group, a, b, cp; \n\n                if(g === N || g === S && symbol.value !== d || g === P) { \n                    symbol = Symbol(0);\n                }\n                else if(g === S) {  \n                    symbol = polydiff(symbol);\n                }\n                else if(g === CB) { \n                    var m = symbol.multiplier.clone();\n                    symbol.toUnitMultiplier();\n                    var retval =  _.multiply(product_rule(symbol),polydiff(symbol));\n                    retval.multiplier = retval.multiplier.multiply(m);\n                    return retval;\n                }\n                else if(g === FN && symbol.power.equals(1)) { \n                    // Table of known derivatives\n                    switch(symbol.fname) {\n                        case LOG:\n                            cp = symbol.clone(); \n                            symbol = symbol.args[0].clone();//get the arguments\n                            symbol.power = symbol.power.negate();\n                            symbol.multiplier = cp.multiplier.divide(symbol.multiplier); \n                            break;\n                        case COS:\n                            //cos -> -sin\n                            symbol.fname = SIN;\n                            symbol.multiplier.negate();\n                            break;\n                        case SIN: \n                            //sin -> cos\n                            symbol.fname = COS;\n                            break;\n                        case TAN:\n                            //tan -> sec^2\n                            symbol.fname = SEC;\n                            symbol.power = new Frac(2);\n                            break;\n                        case SEC: \n                            // Use a clone if this gives errors\n                            symbol = qdiff(symbol, TAN);\n                            break;\n                        case CSC:\n                            symbol = qdiff(symbol, '-cot');\n                            break;\n                        case COT:\n                            symbol.fname = CSC;\n                            symbol.multiplier.negate();\n                            symbol.power = new Frac(2);\n                            break;\n                        case ASIN:\n                            symbol = _.parse('(sqrt(1-('+text(symbol.args[0])+')^2))^(-1)');\n                            break;\n                        case ACOS:\n                            symbol = _.parse('-(sqrt(1-('+text(symbol.args[0])+')^2))^(-1)');\n                            break;\n                        case ATAN:\n                            symbol = _.parse('(1+('+text(symbol.args[0])+')^2)^(-1)');\n                            break;\n                        case ABS: \n                            m = symbol.multiplier.clone(); \n                            symbol.toUnitMultiplier();\n                            //depending on the complexity of the symbol it's easier to just parse it into a new symbol\n                            //this should really be readdressed soon\n                            b = symbol.args[0].clone();\n                            b.toUnitMultiplier();\n                            symbol = _.parse(inBrackets(text(symbol.args[0]))+'/abs'+inBrackets(text(b)));\n                            symbol.multiplier = m;\n                            break;\n                        case 'parens':\n                            //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\n                            //1*g'\n                            symbol = Symbol(1);\n                            break;\n                        case 'cosh':\n                            //cosh -> -sinh\n                            symbol.fname = 'sinh';\n                            break;\n                        case 'sinh': \n                            //sinh -> cosh\n                            symbol.fname = 'cosh';\n                            break;\n                        case TANH:\n                            //tanh -> sech^2\n                            symbol.fname = SECH;\n                            symbol.power = new Frac(2);\n                            break;\n                        case SECH: \n                            // Use a clone if this gives errors\n                            symbol = qdiff(symbol, '-tanh');\n                            break;\n                        case CSCH: \n                            var arg = String(symbol.args[0]);\n                            return _.parse('-coth('+arg+')*csch('+arg+')');\n                            break;\n                        case COTH: \n                            var arg = String(symbol.args[0]);\n                            return _.parse('-csch('+arg+')^2');\n                            break;\n                        case 'asinh':\n                            symbol = _.parse('(sqrt(1+('+text(symbol.args[0])+')^2))^(-1)');\n                            break;\n                        case 'acosh':\n                            symbol = _.parse('(sqrt(-1+('+text(symbol.args[0])+')^2))^(-1)');\n                            break;\n                        case 'atanh':\n                            symbol = _.parse('(1-('+text(symbol.args[0])+')^2)^(-1)');\n                            break;\n                        case ASECH:\n                            var arg = String(symbol.args[0]);\n                            symbol = _.parse('-1/(sqrt(1/('+arg+')^2-1)*('+arg+')^2)');\n                            break;\n                        case ACOTH:\n                            symbol = _.parse('-1/(('+symbol.args[0]+')^2-1)');\n                            break;\n                        case ACSCH:\n                            var arg = String(symbol.args[0]);\n                            symbol = _.parse('-1/(sqrt(1/('+arg+')^2+1)*('+arg+')^2)');\n                            break;\n                        case ASEC:\n                            var arg = String(symbol.args[0]);\n                            symbol = _.parse('1/(sqrt(1-1/('+arg+')^2)*('+arg+')^2)');\n                            break;\n                        case ACSC:\n                            var arg = String(symbol.args[0]);\n                            symbol = _.parse('-1/(sqrt(1-1/('+arg+')^2)*('+arg+')^2)');\n                            break;\n                        case ACOT:\n                            symbol = _.parse('-1/(('+symbol.args[0]+')^2+1)');\n                            break;\n                        case 'S':\n                            var arg = String(symbol.args[0]);\n                            symbol = _.parse('sin((pi*('+arg+')^2)/2)');\n                            break;\n                        case 'C':\n                            var arg = String(symbol.args[0]);\n                            symbol = _.parse('cos((pi*('+arg+')^2)/2)');\n                            break;\n                        case 'Si':\n                            var arg = symbol.args[0];\n                            symbol = _.parse('sin('+arg+')/('+arg+')');\n                            break;\n                        case 'Shi':\n                            var arg = symbol.args[0];\n                            symbol = _.parse('sinh('+arg+')/('+arg+')');\n                            break;\n                        case 'Ci':\n                            var arg = symbol.args[0];\n                            symbol = _.parse('cos('+arg+')/('+arg+')');\n                            break;\n                        case 'Chi':\n                            var arg = symbol.args[0];\n                            symbol = _.parse('cosh('+arg+')/('+arg+')');\n                            break;\n                        case 'Ei':\n                            var arg = symbol.args[0];\n                            symbol = _.parse('e^('+arg+')/('+arg+')');\n                            break;\n                        case 'Li':\n                            var arg = symbol.args[0];\n                            symbol = _.parse('1/'+Settings.LOG+'('+arg+')');\n                            break;\n                        case 'erf':\n                            symbol = _.parse('(2*e^(-('+symbol.args[0]+')^2))/sqrt(pi)');\n                            break;\n                        case 'atan2':\n                            var x_ = String(symbol.args[0]),\n                                y_ = String(symbol.args[1]);\n                            symbol = _.parse('('+y_+')/(('+y_+')^2+('+x_+')^2)');\n                            break;\n                        case 'sign':\n                            symbol = new Symbol(0);\n                            break;\n                        case 'sinc':\n                            symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\n                            break;\n                        case Settings.LOG10:\n                            symbol = _.parse('1/(('+symbol.args[0]+')*'+Settings.LOG+'(10))');\n                            break;\n                        default:\n                            symbol = _.symfunction('diff', [symbol, wrt]);\n                    }\n                }\n                else if(g === EX || g === FN && isSymbol(symbol.power)) { \n                    var value;\n                    if(g === EX) {\n                        value = symbol.value;\n                    }\n                    else if(g === FN && symbol.contains(d)) { \n                        value = symbol.fname + inBrackets(text(symbol.args[0]));\n                    }\n                    else {\n                        value = symbol.value + inBrackets(text(symbol.args[0]));\n                    }\n                        a = _.multiply(_.parse(LOG+inBrackets(value)), symbol.power.clone()); \n                        b = __.diff(_.multiply(_.parse(LOG+inBrackets(value)), symbol.power.clone()), d); \n                    symbol = _.multiply(symbol, b);\n                }\n                else if(g === FN && !symbol.power.equals(1)) { \n                    b = symbol.clone();\n                    b.toLinear();\n                    b.toUnitMultiplier();\n                    symbol = _.multiply(polydiff(symbol.clone()), derive(b));  \n                }\n                else if( g === CP || g === PL ) { \n                    var result = new Symbol(0);\n                    for(var x in symbol.symbols) {\n                        result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\n                    }\n                    symbol = _.multiply(polydiff(symbol.clone()), result);\n                }\n\n                symbol.updateHash();\n                return symbol;\n            };\n\n            function qdiff(symbol, val, altVal) {\n                return _.multiply(symbol, _.parse(val+inBrackets(altVal || text(symbol.args[0]))));\n            };\n\n            function product_rule(symbol) { \n                //grab all the symbols within the CB symbol\n                var symbols = symbol.collectSymbols(), \n                    result = new Symbol(0),\n                    l = symbols.length;\n                //loop over all the symbols\n                for(var i=0; i<l; i++) {\n                    var df = __.diff(symbols[i].clone(), d);\n                    for(var j=0; j<l; j++) {\n                        //skip the symbol of which we just pulled the derivative\n                        if(i !== j) {\n                            //multiply out the remaining symbols\n                            df = _.multiply(df, symbols[j].clone());\n                        }\n                    }\n                    //add the derivative to the result\n                    result = _.add(result, df);\n                }\n                return result; //done\n            };\n        },\n        integration: {\n            u_substitution: function(symbols, dx) { \n                function try_combo(a, b, f) {\n                    var d = __.diff(b, dx);\n                    var q = f ? f(a, b) : _.divide(a.clone(), d);\n                    if(!q.contains(dx, true)) \n                        return q;\n                    return null;\n                }\n                function do_fn_sub(fname, arg) { \n                    var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\n                    subbed = subbed.sub(new Symbol(u), arg);\n                    subbed.updateHash();\n                    return subbed;\n                }\n\n                var a = symbols[0].clone(),\n                    b = symbols[1].clone(),\n                    g1 = a.group,\n                    g2 = b.group,\n                    //may cause problems if person is using this already. Will need\n                    //to find algorithm for detecting conflict\n                    u = '__u__', \n                    Q;\n                if(g1 === FN && g2 !== FN) {\n                    //e.g. 2*x*cos(x^2)\n                    var arg = a.args[0];\n                    Q = try_combo(b, arg.clone());\n                    if(Q) \n                        return _.multiply(Q, do_fn_sub(a.fname, arg));\n                    Q = try_combo(b, a);\n                    if(Q) {\n                        return __.integration.poly_integrate(a);\n                    }\n                }\n                else if(g2 === FN && g1 !== FN) {\n                    //e.g. 2*(x+1)*cos((x+1)^2\n                    var arg = b.args[0];\n                    Q = try_combo(a, arg.clone());\n                    if(Q) \n                        return _.multiply(Q, do_fn_sub(b.fname, arg));\n                }\n                else if(g1 === FN && g2 === FN) {\n                    Q = try_combo(a.clone(), b.clone());\n                    if(Q)\n                        return _.multiply(__.integration.poly_integrate(b), Q);\n                    Q = try_combo(b.clone(), a.clone());\n                    if(Q)\n                        return _.multiply(__.integration.poly_integrate(b), Q);\n                }\n                else if(g1 === EX && g2 !== EX) { \n                    var p = a.power; \n                    Q = try_combo(b, p.clone());\n                    if(!Q) {\n                        //one more try\n                        var dc = __.integration.decompose_arg(p.clone(), dx);\n                        //consider the possibility of a^x^(n-1)*x^n dx\n                        var xp = __.diff(dc[2].clone(), dx);\n                        var dc2 = __.integration.decompose_arg(xp.clone(), dx);\n                        //if their powers equal, so if dx*p == b\n                        if(_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\n                            var m = _.divide(dc[0].clone(), dc2[0].clone());\n\n                            var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\n                            new_val = _.multiply(new_val, new Symbol(u));\n                            return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\n                        }\n\n                    }\n                    var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\n                            retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\n                        \n                    \n                    return retval;\n                }\n                else if(g2 === EX && g1 !== EX) {\n                    var p = b.power;\n                    Q = try_combo(a, p.clone());\n                    var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\n                    return _.multiply(integrated.sub(new Symbol(u), p), Q);\n                }\n                else if(a.isComposite() || b.isComposite()) { \n                    var f = function(a, b) {\n                        var d = __.diff(b, dx);\n                        var A = core.Algebra.Factor.factor(a),\n                            B = core.Algebra.Factor.factor(d);\n                        var q = _.divide(A, B);\n                        return q;\n                    };\n                    var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\n                        f2 = b.isComposite() ? b.clone().toLinear() : b.clone(); \n                    Q = try_combo(f1.clone(), f2.clone(), f); \n                    if(Q) \n                        return _.multiply(__.integration.poly_integrate(b), Q);\n                    Q = try_combo(f2.clone(), f1.clone(), f);\n                    if(Q)\n                        return _.multiply(__.integration.poly_integrate(a), Q);\n                }\n            },\n            //simple integration of a single polynomial x^(n+1)/(n+1)\n            poly_integrate: function(x) { \n                var p = x.power.toString(),\n                    m = x.multiplier.toDecimal(), \n                    s = x.toUnitMultiplier().toLinear();\n                if(Number(p) === -1) {\n                    return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\n                }\n                return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\n            },\n            //If we're just spinning wheels we want to stop. This is why we \n            //wrap integration in a try catch block and call this to stop.\n            stop: function(msg) {\n                msg = msg || 'Unable to compute integral!';\n                core.Utils.warn(msg);\n                throw new NoIntegralFound(msg);\n            },\n            partial_fraction: function(input, dx, depth, opt) { \n                //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\n                if(!isSymbol(dx))\n                    dx = _.parse(dx);\n                \n                var result, partial_fractions;\n                result = new Symbol(0);\n                partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\n\n                if(partial_fractions.group === CB && partial_fractions.isLinear()) {\n                    //perform a quick check to make sure that all partial fractions are linear\n                    partial_fractions.each(function(x) {\n                        if(!x.isLinear())\n                            __.integration.stop();\n                    });\n                    partial_fractions.each(function(x) {\n                        result = _.add(result, __.integrate(x, dx, depth, opt));\n                    });\n                }\n                else {\n                    result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\n                }\n                return result;\n            },\n            get_udv: function(symbol) { \n                var parts = [[/*L*/], [/*I*/], [/*A*/], [/*T*/], [/*E*/]];\n                //first we sort them \n                var setSymbol = function(x) { \n                    var g = x.group; \n                    if(g === FN) {\n                        var fname = x.fname;\n                        if(core.Utils.in_trig(fname) || core.Utils.in_htrig(fname))\n                            parts[3].push(x);\n                        else if(core.Utils.in_inverse_trig(fname))\n                            parts[1].push(x);\n                        else if(fname === LOG)\n                            parts[0].push(x);\n                        else { \n                            __.integration.stop();\n                        }\n                    }\n                    else if(g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\n                        parts[2].push(x);\n                    }\n                    else if(g === EX || x.isComposite() && !x.isLinear())\n                        parts[4].push(x);\n                    else\n                        __.integration.stop();\n                };\n                \n                if(symbol.group === CB) \n                    symbol.each(function(x) { \n                        setSymbol(Symbol.unwrapSQRT(x, true));\n                    });\n                else \n                    setSymbol(symbol);\n                var u, dv = new Symbol(1);\n                //compile u and dv\n                for(var i=0; i<5; i++) { \n                    var part = parts[i], t,\n                        l = part.length;\n                    if(l > 0) {\n                        if(l > 1) {\n                            t = new Symbol(1);\n                            for(var j=0; j<l; j++) \n                                t = _.multiply(t, part[j].clone());\n                        }\n                        else\n                            t = part[0].clone();\n\n                        if(!u) { \n                            u = t;//the first u encountered gets chosen\n                            u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\n                        } \n                        else dv = _.multiply(dv, t); //everything else belongs to dv\n                    }  \n                }\n\n                return [u, dv];\n            },\n            \n            trig_sub: function(symbol, dx, depth, opt, parts, symbols) {  \n                parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\n                var b = parts[3],\n                    ax = parts[2],\n                    a = parts[0],\n                    x = parts[1]; \n                if(x.power.equals(2) && a.greaterThan(0)) {\n                    //use tan(x)\n                    var t = core.Utils.getU(symbol), //get an appropriate u\n                        u = _.parse(TAN+inBrackets(t)), //u\n                        du = _.parse(SEC+inBrackets(t)+'^2'), //du\n                        f = _.multiply(symbol.sub(x, u), du);\n                    var integral = __.integrate(f, t, depth, opt).sub(u, x);\n                    core.Utils.clearU(u);\n                    return integral;\n                }\n            },\n            \n            by_parts: function(symbol, dx, depth, o) { \n                o.previous = o.previous || [];\n                var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;\n                //first LIATE\n                udv = __.integration.get_udv(symbol);\n                u = udv[0]; \n                dv = udv[1]; \n                du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true); \n                c = du.clone().stripVar(dx);\n                //strip any coefficients\n                du = _.divide(du, c.clone());\n                v = __.integrate(dv.clone(), dx, depth || 0); \n                vdu = _.multiply(v.clone(), du); \n                vdu_s = vdu.toString();\n                //currently only supports e^x*(some trig)\n                if(o.previous.indexOf(vdu_s) !== -1 && (core.Utils.in_trig(u.fname)) && dv.isE()) { \n                    //We're going to exploit the fact that vdu can never be constant\n                    //to work out way out of this cycle. We'll return the length of\n                    //the this.previous array until we're back at level one\n                    o.is_cyclic = true;\n                    //return the integral. \n                    return new Symbol(1);\n                }\n                else\n                    o.previous.push(vdu_s);\n\n                uv = _.multiply(u, v); \n                //clear the multiplier so we're dealing with a bare integral\n                m = vdu.multiplier.clone();\n                vdu.toUnitMultiplier();\n                integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c); \n                integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\n                retval = _.subtract(uv, integral_vdu);\n                //we know that there cannot be constants so they're a holdover from a cyclic integral\n                if(o.is_cyclic) { \n                    //start popping the previous stack so we know how deep in we are\n                    o.previous.pop();\n                    if(o.previous.length === 0) {\n                        retval = _.expand(retval);\n                        var rem = new Symbol(0);\n                        retval.each(function(x) {\n                            if(!x.contains(dx))\n                                rem = _.add(rem, x.clone());\n                        });\n                        //get the actual uv\n                        retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\n                    }\n                }\n                \n                return retval;\n            },\n            /*\n             * dependents: [Solve, integrate]\n             */\n            decompose_arg: core.Utils.decompose_fn\n        },\n        //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\n        integrate: function(original_symbol, dt, depth, opt) { \n            //assume integration wrt independent variable if expression only has one variable\n            if(!dt) {\n                var vars = core.Utils.variables(original_symbol);\n                if(vars.length === 1)\n                    dt = vars[0]; \n                //defaults to x\n                dt = dt || 'x';\n            }\n            //add support for integrating vectors\n            if(core.Utils.isVector(original_symbol)) {\n                var vector = new core.Vector([]);\n                original_symbol.each(function(x) {\n                    vector.elements.push(__.integrate(x, dt));\n                });\n                return vector;\n            }\n            if(!isNaN(dt))\n                _.error('variable expected but received '+dt);\n            //get rid of constants right away\n            if(original_symbol.isConstant(true))\n                return _.multiply(original_symbol.clone(), _.parse(dt));\n            \n            //configurations options for integral. This is needed for tracking extra options\n            //e.g. cyclic integrals or additional settings\n            opt = opt || {};\n            return core.Utils.block('PARSE2NUMBER', function() {\n                //make a note of the original symbol. Set only if undefined\n                depth = depth || 0;\n                var dx = isSymbol(dt) ? dt.toString() : dt,\n                    //we don't want the symbol in sqrt form. x^(1/2) is prefererred\n                    symbol = Symbol.unwrapSQRT(original_symbol.clone(), true), \n                    g = symbol.group,\n                    retval;\n\n                try { \n                    //We stop integration after x amount of recursive calls\n                    if(++depth > core.Settings.integration_depth) \n                        __.integration.stop('Maximum depth reached. Exiting!');\n\n                    //constants. We first eliminate anything that doesn't have dx. Everything after this has \n                    //to have dx or else it would have been taken care of below\n                    if(!symbol.contains(dx, true)) { \n                        retval = _.multiply(symbol.clone(), _.parse(dx));\n                    }\n                    //e.g. 2*x\n                    else if(g === S) {\n                        retval = __.integration.poly_integrate(symbol, dx, depth);\n                    }\n                    else if(g === EX) { \n                        if(symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS))\n                            __.integration.stop();\n                        //check the base\n                        if(symbol.contains(dx) && symbol.previousGroup !== FN) {\n                            //if the symbol also contains dx then we stop since we currently \n                            //don't know what to do with it e.g. x^x\n                            if(symbol.power.contains(dx))\n                                __.integration.stop();\n                            else { \n                                var t = __.diff(symbol.clone().toLinear(), dx);\n                                if(t.contains(dx))\n                                    __.integration.stop();\n                                //since at this point it's the base only then we do standard single poly integration\n                                //e.g. x^y\n                                retval = __.integration.poly_integrate(symbol, dx, depth);\n                            }\n                        }\n                        //e.g. a^x or 9^x\n                        else {\n                            var a = __.diff(symbol.power.clone(), dx);\n                            if(a.contains(dx)) {\n                                var aa = a.stripVar(dx),\n                                    x = _.divide(a.clone(), aa.clone());\n                                if(x.group === S && x.isLinear()) {\n                                    aa.multiplier = aa.multiplier.divide(new Frac(2));\n                                    return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\n                                }\n                                else\n                                    __.integration.stop();\n                            }\n                            if(symbol.isE()) { \n                                if(a.isLinear())\n                                    retval = symbol;\n                                else {\n                                    if(a.isE() && a.power.group === S && a.power.power.equals(1))\n                                        retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);\n                                    else\n                                        __.integration.stop();\n                                }\n                            }\n                            else {\n                                var d = _.symfunction(LOG, [_.parse(symbol.value)]);\n                                retval = _.divide(symbol, d);\n                            }\n                            retval = _.divide(retval, a);\n                        }\n                    }\n                    else if(symbol.isComposite() && symbol.isLinear()) { \n                        var m = _.parse(symbol.multiplier);\n                        symbol.toUnitMultiplier();\n                        retval = new Symbol(0);\n                        symbol.each(function(x) {\n                            retval = _.add(retval, __.integrate(x, dx, depth));\n                        });\n                        retval = _.multiply(m, retval);\n                    }\n                    else if(g === CP) { \n                        if(symbol.power.greaterThan(1))\n                            symbol = _.expand(symbol);\n                        if(symbol.power.equals(1)) {\n                            retval = new Symbol(0);\n                            symbol.each(function(x) {\n                                retval = _.add(retval, __.integrate(x, dx, depth));\n                            }, true);\n                        }\n                        else {\n                            var p = Number(symbol.power),\n                                m = symbol.multiplier.clone();//temporarily remove the multiplier\n                            symbol.toUnitMultiplier();\n                            var //below we consider the form ax+b\n                                fn = symbol.clone().toLinear(), //get just the pure function without the power\n                                decomp = __.integration.decompose_arg(fn, dx),\n                                //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\n                                b = decomp[3],\n                                ax = decomp[2],\n                                a = decomp[0],\n                                x = decomp[1]; \n                            if(p === -1 && x.group !== PL && x.power.equals(2)) { \n                                var b_is_positive = isInt(b) ? b > 0 : true;\n                                //we can now check for atan\n                                if(x.group === S && x.power.equals(2) && b_is_positive) { \n                                    ////then we have atan\n                                    //abs is redundants since the sign appears in both denom and num.\n                                    var unwrapAbs = function(s) {\n                                        var result = new Symbol(1);\n                                        s.each(function(x) {\n                                            result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\n                                        });\n                                        return result;\n                                    };\n                                    var A = a.clone(),\n                                        B = b.clone();\n                                    A = _.pow(A, new Symbol(1/2));\n                                    B = _.pow(B, new Symbol(1/2));\n                                    //unwrap abs\n\n                                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\n                                        f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\n                                    retval = _.divide(f, d);\n                                }\n                                else if(x.group === S && x.isLinear()) {\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\n                                }\n                                else { \n                                    //1/(x^4+1)\n                                    if(x.power.equals(4)) {\n                                        //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\n                                        var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\n                                        var br = inBrackets;\n                                        //apply rule: ax^4+b = (ax^2+2abx+b)(ax^2-2abx+b)\n                                        //get quadratic factors\n                                        A = _.parse(SQRT+br(a)+'*'+dx+'^2');\n                                        B = _.parse(SQRT+br(2)+'*'+br(a)+'^'+br('1/4')+'*'+br(b)+'^'+br('1/4')+'*'+dx);\n                                        C = _.parse(SQRT+br(b));\n                                        f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\n                                        f2 = _.add(_.subtract(A, B), C);\n                                        //calculate numerators: [D+E, D-E] -> [2*b^(3/4)+bax, 2*b^(3/4)-bax]\n                                        D = _.parse(SQRT+br(2)+'*'+br(b)+'^'+br('3/4'));\n                                        E = _.parse(SQRT+br(b)+'*'+br(b)+'^'+br('1/4')+'*'+dx);\n                                        //let F = 2b2b\n                                        F = _.parse(2+'*'+br(b)+'*'+SQRT+br(2)+'*'+br(b)+'^'+br('1/4'));\n                                        //calculate the factors\n                                        L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\n                                        L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\n                                        retval = _.add(\n                                                    __.integrate(L1, dx, depth, opt),\n                                                    __.integrate(L2, dx, depth, opt)\n                                                );\n                                    }\n                                    else\n                                        //let's try partial fractions\n                                        retval = __.integration.partial_fraction(symbol, dx, depth);\n                                }\n                            }\n                            else if(p === -1/2) {\n                                //detect asin and atan\n                                if(x.group === S && x.power.equals(2)) {\n                                    if(ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\n                                        a.negate();\n                                        //it's asin\n                                        if(b.isConstant() && a.isConstant()) {\n                                            var d = _.symfunction(SQRT, [a.clone()]),\n                                                d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\n                                            retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\n                                        }\n                                        //I'm not sure about this one. I'm trusting Wolfram Alpha here\n                                        else {\n                                            var sqrt_a = _.symfunction(SQRT, [a]),\n                                                sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\n                                            retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\n                                        }\n                                    }\n                                    else {\n                                        /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\n                                        __.integration.stop();\n                                    }\n                                }\n                                else {\n                                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\n                                    __.integration.stop();\n                                }\n                            }\n                            else { \n                                if(x.isLinear() && x.group !== PL) \n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\n                                else if(x.power.equals(2) && a.greaterThan(0)) { \n                                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv;\n                                    //1/(a*x^2+b^2)^n\n                                    //strip the value of b so b = 1\n                                    sqa = _.parse(SQRT+inBrackets(a)); //strip a so b = 1\n                                    sqb = _.parse(SQRT+inBrackets(b));\n                                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\n                                    bsqi = _.pow(b, new Symbol(symbol.power));\n                                    uv = core.Utils.getU(symbol);\n                                    u = _.multiply(aob, x.clone().toLinear());\n                                    v = _.parse(ATAN+inBrackets(u));\n                                    //the conversion will be 1+tan(x)^2 -> sec(x)^2\n                                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \n                                    //then the remaining sec will be (n-1)*2;\n                                    var n = (Math.abs(symbol.power)-1)*2; \n                                    //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\n                                    var integral = __.integrate(_.parse(COS+inBrackets(uv)+'^'+n));\n                                    core.Utils.clearU(uv);\n                                    return _.multiply(integral.sub(uv, v), bsqi);\n                                }\n                                else { \n                                    if(symbol.group !== CB && !symbol.power.lessThan(0)) {\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                    }\n                                    else { \n                                        var f = symbol.clone().toLinear();\n                                        var factored = core.Algebra.Factor.factor(f);\n                                        var was_factored = factored.toString() !== f.toString();\n                                        if(core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) { \n                                            try {\n                                                var f1, fx, u, sq;\n                                                sq = core.Algebra.sqComplete(f, dx);\n                                                u = core.Utils.getU(f);\n                                                f1 = sq.f.sub(sq.a, u);\n                                                fx = _.pow(f1, _.parse(symbol.power));\n                                                retval = __.integrate(fx, u).sub(u, sq.a);\n                                            }\n                                            catch(e) {\n                                                __.integration.stop();\n                                            }\n                                        }\n                                        else\n                                            retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                                    }\n                                }\n                            }\n                            retval.multiplier = retval.multiplier.multiply(m);\n                        }\n                    }\n                    else if(g === FN) { \n                        var arg = symbol.args[0],\n                            m = symbol.multiplier.clone();\n                        symbol.toUnitMultiplier();\n                        var decomp = __.integration.decompose_arg(arg, dx);\n                        //easies way I can think of to get the coefficient and to make sure\n                        //that the symbol is linear wrt dx. I'm not actually trying to get the \n                        //derivative\n                        var a = decomp[0],\n                            x = decomp[1],\n                            fname = symbol.fname;\n                        //log is a special case that can be handled with integration by parts\n                        if(fname === LOG || (fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear())) { \n                            /*integration by parts */\n                            var p = symbol.power.toString(); \n                            if(isInt(p))\n                                depth = depth - p; //it needs more room to find the integral\n                            \n                            if(!arg.isComposite())\n                                retval = _.multiply(_.parse(m),__.integration.by_parts(symbol, dx, depth, opt)); \n                            else {\n                                //integral u du\n                                var u = core.Utils.getU(symbol);\n                                var f = _.pow(_.parse(LOG+inBrackets(u)),new Symbol(p));\n                                var du = __.diff(arg, dx);\n                                var u_du = _.multiply(f, du);\n                                var integral = __.integrate(u_du, u, depth, opt);\n                                retval = _.multiply(_.parse(m),integral.sub(u, arg));\n                            }\n\n                        }\n                        else if(fname === TAN && symbol.power.lessThan(0)) {\n                            //convert to cotangent\n                            var sym  = symbol.clone();\n                            sym.power.negate();\n                            sym.fname = COT;\n                            return _.multiply(_.parse(m),__.integrate(sym, dx, depth));\n                        }\n                        else {\n                            if(!a.contains(dx, true) && symbol.isLinear()) { //perform a deep search for safety\n                                //first handle the special cases \n                                if(fname === ABS) {\n                                    //REVISIT **TODO**\n                                    var x = _.divide(arg.clone(), a.clone());\n                                    if(x.group === S && !x.power.lessThan(0)) {\n                                        if(core.Utils.even(x.power)) {\n                                            retval = __.integrate(arg, dx, depth);\n                                        }\n                                        else {\n                                            var integrated = __.integrate(x, dx, depth);\n                                            integrated.power = integrated.power.subtract(new Frac(1));\n                                            retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\n                                        }\n                                    }\n                                    else \n                                        __.integration.stop();\n                                }\n                                else { \n                                    var ag = symbol.args[0].group,\n                                        decomposed = __.integration.decompose_arg(arg, dx);\n                                    \n                                    if(!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc())\n                                        __.integration.stop();\n                                    /**TODO**/ //ASIN, ACOS, ATAN\n                                    switch(fname) {\n                                        case COS:\n                                            retval = _.symfunction(SIN, [arg]);\n                                            break;\n                                        case SIN:\n                                            retval = _.symfunction(COS, [arg]);\n                                            retval.negate();\n                                            break;\n                                        case TAN:\n                                            retval = _.parse(format(Settings.LOG+'(sec({0}))', arg));\n                                            break;\n                                        case SEC:\n                                            retval = _.parse(format(Settings.LOG+'(tan({0})+sec({0}))', arg));\n                                            break;\n                                        case CSC:\n                                            retval = _.parse(format('-'+Settings.LOG+'(csc({0})+cot({0}))', arg));\n                                            break;\n                                        case COT:\n                                            retval = _.parse(format(Settings.LOG+'(sin({0}))', arg));\n                                            break;\n                                        case SINH:\n                                            retval = _.symfunction(COSH, [arg]);\n                                            break;\n                                        case COSH:\n                                            retval = _.symfunction(SINH, [arg]);\n                                            break;\n                                        case TANH:\n                                            retval = _.parse(format(Settings.LOG+'(cosh({0}))', arg));\n                                            break;\n                                        case ASEC:\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                            break;\n                                        case ACSC:\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                            break;\n                                        case ACOT:\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                            break;\n                                        //inverse htrig\n                                        case ASECH:\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                            break;\n                                        case ACSCH:\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                            break;\n                                        case ACOTH:\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                            break;\n                                        //end inverse htrig\n                                        //htrigh\n                                        case SECH:\n                                            retval = _.parse(format('atan(sinh({0}))', arg));\n                                            break;\n                                        case CSCH:\n                                            retval = _.parse(format(Settings.LOG+'(tanh(({0})/2))', arg));\n                                            break;\n                                        case COTH:\n                                            retval = _.parse(format(Settings.LOG+'(sinh({0}))', arg));\n                                            break;\n                                        //end htrig\n                                        case EXP:\n                                            retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\n                                            break;\n                                        case 'S':\n                                            var arg = symbol.args[0].clone(),\n                                                dc = __.integration.decompose_arg(arg, dx),\n                                                x_ = dc[1],\n                                                a_ = dc[0];\n                                            var b_ = dc[3];\n                                            retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\n                                            break;\n                                        case 'C':\n                                            var arg = symbol.args[0].clone(),\n                                                dc = __.integration.decompose_arg(arg, dx),\n                                                x_ = dc[1],\n                                                a_ = dc[0];\n                                            var b_ = dc[3];\n                                            retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\n                                            break;\n                                        case 'erf':\n                                            var arg = symbol.args[0].clone(),\n                                                dc = __.integration.decompose_arg(arg, dx),\n                                                x_ = dc[1],\n                                                a_ = dc[0];\n                                            retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\n                                            break;\n                                        case 'sign':\n                                            retval = _.multiply(symbol.clone(), arg.clone());\n                                            break;\n                                        default:\n                                            __.integration.stop();\n                                    }\n\n                                    retval = _.divide(retval, a); \n                                }\n                            }\n                            else if(x.isLinear()) { \n                                if(fname === COS || fname === SIN) {\n                                    var p = Number(symbol.power);\n                                    //check to see if it's negative and then just transform it to sec or csc\n                                    if(p < 0) {\n                                        symbol.fname = fname === SIN ? CSC : SEC;\n                                        symbol.invert().updateHash();\n                                        retval = __.integrate(symbol, dx, depth);\n                                    }\n                                    else {\n                                        var arg = symbol.args[0],\n                                            rd = symbol.clone(), //cos^(n-1)\n                                            rd2 = symbol.clone(), //cos^(n-2)\n                                            q = new Symbol((p-1)/p), //\n                                            na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\n                                        rd.power = rd.power.subtract(new Frac(1));\n                                        rd2.power = rd2.power.subtract(new Frac(2));\n\n                                        var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\n                                        if(fname === SIN) t.negate();\n                                        retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\n                                    }\n                                }\n                                //tan(x)^n or cot(x)^n\n                                else if(fname === TAN || fname === COT) { \n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                                    if(symbol.args[0].isLinear(dx)) {\n                                        var n = symbol.power.subtract(new Frac(1)).toString(),\n                                            r = symbol.clone().toUnitMultiplier(),\n                                            w = _.parse(format((fname === COT ? '-' : '')+'1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\n                                        r.power = r.power.subtract(new Frac(2));\n                                        if(r.power.equals(0))\n                                            r = _.parse(r);\n                                        retval = _.subtract(w, __.integrate(r, dx, depth));\n                                    }   \n                                }\n                                //sec(x)^n or csc(x)^n\n                                else if(fname === SEC || fname === CSC) { \n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                                    var n1 = symbol.power.subtract(new Frac(1)).toString(),\n                                        n2 = symbol.power.subtract(new Frac(2)).toString(),\n                                        f2 = fname === SEC ? TAN : COT,\n                                        r = symbol.clone().toUnitMultiplier(),\n                                        parse_str = format((fname === CSC ? '-' : '')+'1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\n                                        w = _.parse(parse_str);\n                                    r.power = r.power.subtract(new Frac(2));\n                                    if(r.power.equals(0))\n                                        r = _.parse(r);\n                                    retval = _.add(w, _.multiply(new Symbol(n2/n1), __.integrate(r, dx, depth)));\n                                }\n                                else if((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\n                                    retval = __.integrate(symbol.fnTransform(), dx, depth);\n                                }\n                                else\n                                    __.integration.stop();\n                            }\n                            else \n                                __.integration.stop();\n\n                            retval.multiplier = retval.multiplier.multiply(m);\n                        }\n                    }\n                    else if(g === PL) {\n                        retval = __.integration.partial_fraction(symbol, dx, depth);\n                    }\n                    else if(g === CB) {\n                        var den = symbol.getDenom();\n                        if(den.group === S)\n                            symbol = _.expand(symbol);\n                        \n                        //separate the coefficient since all we care about are symbols containing dx\n                        var coeff = symbol.stripVar(dx); \n                        //now get only those that apply\n                        var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\n                        //peform a correction for stripVar. This is a serious TODO!\n                        if(coeff.contains(dx)) {\n                            cfsymbol = _.multiply(cfsymbol, coeff);\n                            coeff = new Symbol(1);\n                        }\n                        \n                        //if we only have one symbol left then let's not waste time. Just pull the integral\n                        //and let the chips fall where they may\n                        if(cfsymbol.group !== CB) {\n                            if(cfsymbol.equals(1)) { \n                                return __.integrate(_.expand(symbol), dx, depth);\n                            }\n                            \n                            //only factor for multivariate which are polynomials\n                            if(cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\n                                cfsymbol = core.Algebra.Factor.factor(cfsymbol);\n                            }\n  \n                            retval = __.integrate(cfsymbol, dx, depth);\n                        }\n                        else { \n                            //we collect the symbols and sort them descending group, descending power, descending alpabethically\n                            var symbols = cfsymbol.collectSymbols().sort(function(a, b) {\n                                if(a.group === b.group)  {\n                                    if(Number(a.power) === Number(b.power))\n                                        if(a < b) return 1; //I want sin first\n                                        else return -1;\n                                    return b.power - a.power; //descending power\n                                }\n                                return b.group - a.group; //descending groups\n                            }).map(function(x) {\n                                var unwrapped = Symbol.unwrapSQRT(x, true);\n                                if(unwrapped.fname === EXP) {\n                                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\n                                }\n                                return unwrapped;\n                            });\n                            var l = symbols.length;\n                            if(symbol.power < 0) { \n                                if(l === 2) {\n                                    return __.integrate(_.expand(symbol), dx, depth, opt);\n                                }\n                            }\n                            //otherwise the denominator is one lumped together symbol \n                            else {\n                                //generate an image for \n                                if(l === 2) {\n                                    //try u substitution\n                                    try {\n                                        retval = __.integration.u_substitution(symbols, dx);\n                                    }\n                                    catch(e){/* failed :`(*/; }   \n\n                                    if(!retval) { \n                                        //no success with u substitution so let's try known combinations\n                                        //are they two functions\n                                        var g1 = symbols[0].group,\n                                            g2 = symbols[1].group,\n                                            sym1 = symbols[0],\n                                            sym2 = symbols[1],\n                                            fn1 = sym1.fname,\n                                            fn2 = sym2.fname; \n                                        //reset the symbol minus the coeff\n                                        symbol = _.multiply(sym1.clone(), sym2.clone());\n                                        if(g1 === FN && g2 === FN) { \n                                            if(fn1 === LOG || fn2 === LOG) { \n                                                retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\n                                            }\n                                            else { \n                                                symbols.sort(function(a, b) {\n                                                    return b.fname > a.fname;\n                                                });\n                                                var arg1 = sym1.args[0];\n                                                //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\n                                                if(!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S))\n                                                    __.integration.stop();\n\n                                                var decomp = __.integration.decompose_arg(arg1, dx);\n                                                x = decomp[1];\n                                                a = decomp[0];\n                                                if(!x.isLinear()) //again... linear arguments only wrt x\n                                                    __.integration.stop();\n\n                                                //they have to have the same arguments and then we have cleared all the check to \n                                                //make sure we can integrate FN & FN\n                                                var arg2 = sym2.args[0];\n                                                //make sure that their argument matches\n                                                if(arg1.equals(arg2)) { \n                                                    if(fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) { \n                                                        if(sym1.power.lessThan(0))\n                                                            __.integration.stop();//we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\n                                                        //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\n                                                        if(fn1 === SIN && sym1.power.add(sym2.power).equals(0)) { \n                                                            sym1.fname = TAN;\n                                                            sym1.updateHash();\n                                                            retval = __.integrate(sym1, dx, depth);\n                                                        }\n                                                        else {\n                                                            if(even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\n                                                                //transform sin^(2*n) to (1-cos^2)^n\n                                                                var n = Number(sym1.power)/2,\n                                                                    new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                                                            }\n                                                            else if(even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\n                                                                //transform cos^(2*n) to (1-sin^2)^n\n                                                                var n = Number(sym1.power)/2,\n                                                                    new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                                                            }\n                                                            else {\n                                                                var p1_even = core.Utils.even(sym1.power),\n                                                                    p2_even = core.Utils.even(sym2.power);\n                                                                retval = new Symbol(0);\n                                                                if(!p1_even || !p2_even) { \n                                                                    var u, r, trans;\n                                                                    //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\n                                                                    //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\n                                                                    if(!p1_even) {\n                                                                        //u = sin(x)\n                                                                        u = sym2; r = sym1; \n                                                                    }\n                                                                    else {\n                                                                        u = sym1; r = sym2;\n                                                                    }\n                                                                    //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\n                                                                    var sign = u.fname === COS ? -1 : 1,\n                                                                        n = r.power, \n                                                                        //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \n                                                                        //even powers afterwards which can be transformed\n                                                                        k = (n - 1)/2, \n                                                                        //make the transformation cos(x)^2 = 1 - sin(x)^2\n                                                                        trans = _.parse('(1-'+u.fname+core.Utils.inBrackets(arg1)+'^2)^'+k), \n                                                                        sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans)));\n                                                                    //we can now just loop through and integrate each since it's now just a polynomial with functions\n                                                                    sym.each(function(x) { \n                                                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\n                                                                    });\n                                                                }\n                                                                else { \n                                                                    //performs double angle transformation\n                                                                    var double_angle = function(symbol) {\n                                                                        var p = symbol.power,\n                                                                            k = p/2, e;\n                                                                        if(symbol.fname === COS)\n                                                                            e = '((1/2)+(cos(2*('+symbol.args[0]+'))/2))^'+k;\n                                                                        else\n                                                                            e = '((1/2)-(cos(2*('+symbol.args[0]+'))/2))^'+k;\n\n                                                                        return _.parse(e);\n                                                                    };\n                                                                    //they're both even so transform both using double angle identities and we'll just\n                                                                    //be able to integrate by the sum of integrals\n                                                                    var a = double_angle(sym1),\n                                                                        b = double_angle(sym2),\n                                                                        t = _.multiply(a, b);\n                                                                    var sym = _.expand(t);\n                                                                    sym.each(function(x) {\n                                                                        retval = _.add(retval, __.integrate(x, dx, depth));\n                                                                    });\n                                                                    return _.multiply(retval, coeff);\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                    //tan(x)*sec(x)^n \n                                                    else if(fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) { \n                                                        retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\n                                                    }\n                                                    else if(fn1 === TAN && fn2 === SEC && x.isLinear()) { \n                                                        //remaining: tan(x)^3*sec(x)^6\n                                                        if(sym1.isLinear() && sym2.isLinear()) {\n                                                            retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\n                                                        }\n                                                        else if(even(sym1.power)) {\n                                                            var p = Number(sym1.power)/2;\n                                                            //transform tangent\n                                                            var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\n                                                            retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\n                                                        }\n                                                        else\n                                                            __.integration.stop();\n                                                    }\n                                                    else if(fn1 === SEC && fn2 === COS) {\n                                                        sym1.fname = COS;\n                                                        sym1.invert().updateHash();\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                                                    }\n                                                    else if(fn1 === SIN && fn2 === CSC) {\n                                                        sym2.fname = SIN;\n                                                        sym2.invert().updateHash();\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                                                    }\n                                                    //tan/cos\n                                                    else if(fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\n                                                        var t = _.multiply(sym1.fnTransform(), sym2);\n                                                        retval = __.integrate(_.expand(t), dx, depth);\n                                                    }\n                                                    else { \n                                                        var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\n                                                        retval = __.integrate(_.expand(t), dx, depth);\n                                                    }\n                                                }\n                                                //TODO: In progress\n                                                else if((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\n                                                    \n                                                    if(sym1.isLinear() && sym2.isLinear()) {\n                                                        //if in the form cos(a*x)*sin(b*x)\n                                                        if(sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\n                                                            //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\n                                                            var ax, bx;\n                                                            if(fn2 === SIN) {\n                                                                ax = sym1.args[0];\n                                                                bx = sym2.args[0];\n                                                            }\n                                                            else {\n                                                                bx = sym1.args[0];\n                                                                ax = sym2.args[0];\n                                                            }\n                                                            \n                                                            //make the transformation\n                                                            f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString()));\n\n                                                            //integrate it\n                                                            retval = __.integrate(f, dx, depth);\n                                                        }\n                                                        else {\n                                                            var transformed = trigTransform(symbols);\n                                                            retval = __.integrate(_.expand(transformed), dx, depth);\n                                                        }\n                                                    }\n                                                    else {\n                                                        var transformed = new Symbol(1);\n                                                        symbols.map(function(sym) {\n                                                            var s = sym.fnTransform();\n                                                            transformed = _.multiply(transformed, s);\n                                                        });\n                                                        var t = _.expand(transformed);\n\n                                                        retval = __.integrate(t, dx, depth);\n\n                                                        if(retval.hasIntegral()) {\n                                                            retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\n                                                        }\n                                                    }\n                                                }\n                                                else {\n                                                    __.integration.stop();\n                                                }\n\n                                            }\n                                        }\n                                        else if(g1 === FN && g2 === S) { \n                                            var sym1_is_linear = sym1.isLinear();\n                                            if(sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1)) \n                                                retval = _.symfunction('Ci', [sym1.args[0]]);\n                                            else if(sym1.fname === COS && sym2.power.equals(-1)) {\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                                            }\n                                            else if(sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1))\n                                                retval = _.symfunction('Chi', [sym1.args[0]]);\n                                            else if(sym1.fname === COSH && sym2.power.equals(-1)) {\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                                            }\n                                            else if(sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1))\n                                                retval = _.symfunction('Si', [sym1.args[0]]);\n                                            else if(sym1.fname === SIN && sym2.power.equals(-1)) {\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                                            }\n                                            else if(sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1))\n                                                retval = _.symfunction('Shi', [sym1.args[0]]);\n                                            else if(sym1.fname === SINH && sym2.power.equals(-1)) {\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                                            }\n                                            else if(sym1.fname === LOG && sym2.power.equals(-1)) {\n                                                //log(x)^n/x = log(x)^(n+1)/(n+1)\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\n                                            }\n                                            else if(sym1.fname === 'erf') {\n                                                if(sym2.power.equals(1)) {\n                                                    var dc = __.integration.decompose_arg(sym1.args[0], dx),\n                                                        a_ = dc[0],\n                                                        x_ = dc[1],\n                                                        arg = sym1.args[0].toString();\n                                                    retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg))\n                                                }\n                                            }\n                                            else { \n                                                //since group S is guaranteed convergence we need not worry about tracking depth of integration\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                            }\n                                        }\n                                        else if(g1 === EX && g2 === S) { \n                                            var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\n                                            if(sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\n                                                retval = _.symfunction('Ei', [sym1.power.clone()]);\n                                            }\n                                            else if(fn1 === LOG && x.value === sym2.value) {\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\n                                            }\n                                            else\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                        }\n                                        else if(g1 === PL && g2 === S) {\n                                            //first try to reduce the top\n                                            if(sym2.value === sym1.value && sym1.power.equals(-1)) {\n                                                //find the lowest power in the denominator\n                                                var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));\n                                                //get the lowest common value between denominator and numerator\n                                                var pc = Math.min(pd, sym2.power);\n                                                //reduce both denominator and numerator by that factor\n                                                var factor = sym2.clone();\n                                                factor.power = new Frac(pc);\n                                                sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\n                                                var t = new Symbol(0);\n                                                sym1.each(function(x) {\n                                                    t = _.add(t, _.divide(x.clone(), factor.clone()));\n                                                });\n                                                t.multiplier = sym1.multiplier;\n                                                symbol = _.divide(sym2, t);\n                                            }\n                                            else {\n                                                symbol = _.expand(symbol);\n                                            }\n                                            retval = __.integration.partial_fraction(symbol, dx, depth);\n                                        }\n                                        else if(g1 === CP && g2 === S) {  \n                                            var f = sym1.clone().toLinear(),\n                                                f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);\n                                            //handle cases x^(2*n)/sqrt(1-x^2)\n                                            if(sym1.power.equals(-1/2)) { \n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\n                                                var a = decomp[0].negate(),\n                                                    x = decomp[1],\n                                                    b = decomp[3],\n                                                    p1 = Number(sym1.power),\n                                                    p2 = Number(sym2.power);\n                                                if(isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\n                                                    //if the substitution \n                                                    var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)), \n                                                        _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])), \n                                                        _.pow(a.clone(), new Symbol(2)));\n                                                    c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\n                                                    var dummy = _.parse('sin(u)');\n                                                    dummy.power = dummy.power.multiply(sym2.power);\n                                                    var integral = __.integrate(dummy, 'u', depth);\n                                                    var bksub = _.parse(ASIN+'('+SQRT+'('+a+'/'+b+')*'+dx+')');\n                                                    retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\n                                                }   \n                                                else if(p1 === -1/2) {\n                                                    var u_transform = function(f, u) {\n                                                        var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\n                                                        if(!integral.hasIntegral())\n                                                            return integral;\n                                                    }\n                                                    if(p2 === -1) {\n                                                        retval = u_transform(\n                                                                _.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(),\n                                                                'sqrt(1-1/({0})^2)'\n                                                        );\n                                                    }\n                                                    else if(p2 === -2) {\n                                                        //apply transformation to see if it matches asin(x)\n                                                        retval = u_transform(\n                                                                _.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(),\n                                                                'sqrt(1-1/({0})^2)'\n                                                        );\n                                                    }\n                                                }\n                                            }\n                                            else if(sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) { \n                                                retval = __.integration.partial_fraction(symbol, dx, depth);\n                                            }\n                                            else if(!sym1.power.lessThan(0) && isInt(sym1.power)) { \n                                                //sum of integrals\n                                                var expanded = _.expand(sym1);\n                                                retval = new Symbol(0);\n                                                expanded.each(function(x) {\n                                                    if(x.group === PL) {\n                                                        x.each(function(y) {\n                                                            retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\n                                                        });\n                                                    }\n                                                    else \n                                                        retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\n                                                });\n                                            }\n                                            else if(sym1.power.lessThan(-2)) { \n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                            }\n                                            else if(sym1.power.lessThan(0) && sym2.power.greaterThan(1)) { \n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                                                    a = decomp[0].negate(),\n                                                    x = decomp[1],\n                                                    b = decomp[3],\n                                                    fn = sym1.clone().toLinear();\n\n                                                if(x.group !== PL && x.isLinear()) { \n                                                    var p = Number(sym2.power),\n                                                        du = '_u_',\n                                                        u = new Symbol(du),\n                                                        //pull the integral with the subsitution\n                                                        U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\n                                                        scope = {};\n\n                                                    //generate a scope for resubbing the symbol\n                                                    scope[du] = fn;\n                                                    var U2 = _.parse(U, scope);\n                                                    retval = __.integrate(U2, dx, 0);\n                                                }\n                                                else if(sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) { \n\n                                                    //factor out coefficients\n                                                    var factors = new core.Algebra.Classes.Factors();\n                                                    sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\n                                                    var div = core.Algebra.divide(sym2, sym1);\n                                                    //it assumed that the result will be of group CB\n                                                    if(div.group !== CB) {\n                                                        retval = new Symbol(0);\n                                                        div.each(function(t) {\n                                                            retval = _.add(retval, __.integrate(t, dx, depth));\n                                                        });\n                                                        //put back the factors\n                                                        factors.each(function(factor) {\n                                                            retval = _.divide(retval, factor);\n                                                        });\n\n                                                        retval = _.expand(retval);\n                                                    }\n                                                    else {\n                                                        //try something else\n                                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                                    }\n                                                }\n                                                else \n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\n                                            }\n                                            else { \n                                                //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \n                                                if(sym1.power.den.equals(2)) { \n                                                    //assume the function is in the form (a^2-b*x^n)^(m/2)\n                                                    var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                                                        //using the above definition\n                                                        a = dc[3], x = dc[1], b = dc[0], bx = dc[2];\n                                                    if(x.power.equals(2) && b.lessThan(0)) { //if n is even && b is negative\n                                                        //make a equal 1 so we can do a trig sub\n                                                        if(!a.equals(1)) { //divide a out of everything\n                                                            //move a to the coeff\n                                                            coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\n                                                        }\n                                                        var u = dx;\n                                                        var c = _.divide(_.pow(b.clone().negate(), new Symbol(1/2)), _.pow(a, new Symbol(1/2))),\n                                                            du = _.symfunction(COS, [new Symbol(u)]),\n                                                            cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\n                                                            X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\n                                                            val = _.multiply(_.multiply(cosn, du), X),\n                                                            integral = __.integrate(val, u, depth);\n                                                            //but remember that u = asin(sqrt(b)*a*x)\n                                                            retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\n                                                    }\n                                                    else {\n                                                        retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                                                    }\n                                                }\n                                                else if(f_is_linear) {\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\n                                                }\n                                            }\n\n                                        }\n                                        else if(sym1.isComposite() && sym2.isComposite()) { \n                                            //sum of integrals\n                                            retval = new Symbol(0);\n                                            if(sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\n                                                //combine and pull the integral of each\n                                                var sym = _.expand(symbol);\n                                                sym.each(function(x) {\n                                                    retval = _.add(retval, __.integrate(x, dx, depth));\n                                                }, true);\n                                            }\n                                            else {\n                                                var p1 = Number(sym1.power),\n                                                    p2 = Number(sym2.power);\n                                                if(p1 < 0 && p2 > 0) {\n                                                    //swap\n                                                    var t = sym1; sym1 = sym2; sym2 = t;\n                                                }\n                                                if(p1 === -1 && p2 === -1) {\n                                                    retval = __.integration.partial_fraction(symbol, dx);\n                                                }\n                                                else {\n                                                    sym1.each(function(x) {\n                                                        var k = _.multiply(x, sym2.clone());\n                                                        var integral = __.integrate(k, dx, depth);\n                                                        retval = _.add(retval, integral);\n                                                    });\n                                                }\n                                            }\n                                        }\n                                        else if(g1 === CP && symbols[0].power.greaterThan(0)) {\n                                            sym1 = _.expand(sym1);\n                                            retval = new Symbol(0);\n                                            sym1.each(function(x) {\n                                                retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\n                                            }, true);\n                                        }\n                                        else if(g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\n                                            sym1 = sym1.fnTransform();\n                                            retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\n                                        }\n                                        else if(g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\n                                            if(g2 === FN && g1 === CP) {\n                                                var t = sym1; sym1 = sym2; sym2 = t; //swap\n                                            }\n                                            var du, sym2_clone, p, q, sa, sb;\n                                            du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\n                                            sym2_clone = Symbol.unwrapSQRT(sym2, true);\n                                            if(du.power.equals(sym2_clone.power)) { \n                                                p = new Symbol(sym2.power);\n                                                sa = du.clone().toLinear();\n                                                sb = sym2.clone().toLinear();\n                                                q = core.Algebra.divide(sa.toLinear(), sb);\n                                                if(q.isConstant()) {\n                                                    var nq = _.pow(q, p.negate());\n                                                    retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\n                                                }\n                                            }\n                                            else {\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                            }\n                                        }\n                                        else { \n                                            var syma = sym1.clone().toLinear();\n                                            var symb = sym2.clone().toLinear();\n                                            if(g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx) \n                                                    && !syma.contains(dx) && !symb.contains(dx)) {\n                                                retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))',\n                                                    syma.toString(),\n                                                    symb.toString(),\n                                                    sym1.power.multiplier.toString(),\n                                                    sym2.power.multiplier.toString(),\n                                                    dx\n                                                ));\n                                            }\n                                            else \n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                        }\n                                    }\n                                }\n                                else if(l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) { \n                                    var first = symbols[0];\n                                    if(first.group === CP) { //TODO {support higher powers of x in the future}\n                                        if(first.power.greaterThan(1))\n                                            first = _.expand(first);\n                                        var r = _.multiply(symbols[1], symbols[2]);\n                                        retval = new Symbol(0);\n                                        first.each(function(x) {\n                                            var t = _.multiply(x, r.clone());\n                                            var intg = __.integrate(t, dx, depth);\n                                            retval = _.add(retval, intg);\n                                        }, true);\n                                    }\n                                    else { \n                                        //try integration by parts although technically it will never work\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                                    }\n\n                                }\n                                else if(all_functions(symbols)) { \n                                    var t = new Symbol(1);\n                                    for(var i=0,l=symbols.length; i<l; i++) {\n                                        t = _.multiply(t, symbols[i].fnTransform());\n                                    }\n                                    t = _.expand(t);\n                                    retval = __.integrate(t, dx, depth);\n                                }\n                                else { \n                                    //one more go\n                                    var transformed = trigTransform(symbols);\n                                    retval = __.integrate(_.expand(transformed), dx, depth);\n                                }\n                            }\n                                \n                        }\n\n                        retval = _.multiply(retval, coeff);\n                    }\n                    //if an integral was found then we return it\n                    if(retval)\n                        return retval;\n                }\n\n                catch(error){\n                    //do nothing if it's a NoIntegralFound error otherwise let it bubble\n                    if(!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero)) \n                        throw error;\n                }  \n\n                //no symbol found so we return the integral again\n                return _.symfunction('integrate', [original_symbol, dt]);\n            }, false);\n        },\n        defint: function(symbol, from, to, dx) {\n            dx = dx || 'x'; //make x the default variable of integration\n            var get_value = function(integral, vars, point) {\n                try {\n                    return _.parse(integral, vars);\n                }\n                catch(e) {\n                    //it failed for some reason so return the limit\n                    var lim = __.Limit.limit(integral, dx, point);\n                    return lim;\n                }\n            };\n            \n            var vars = core.Utils.variables(symbol),\n                hasTrig = symbol.hasTrig();\n            var retval, integral;\n            if(vars.length === 1)\n                dx = vars[0];\n            if(!hasTrig) {\n                integral = __.integrate(symbol, dx);\n            }\n            \n            if(!hasTrig && !integral.hasIntegral()) { \n                var upper = {},\n                    lower = {},\n                    a, b;\n                upper[dx] = to;\n                lower[dx] = from;\n                \n                a = get_value(integral, upper, to, dx);  \n                b = get_value(integral, lower, from, dx);\n                retval = _.subtract(a, b);\n            }\n            else if(vars.length === 1 && from.isConstant() && to.isConstant()) {\n                \n                var f = core.Utils.build(symbol); \n                    retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\n            }\n            else \n                retval = _.symfunction('defint', [symbol, from , to, dx]);\n            return retval;\n        },\n            \n        Limit: {\n            interval: function(start, end) {\n                return _.parse(format('[{0}, {1}]', start, end));\n            },\n            diverges: function() {\n                return __.Limit.interval('-Infinity', 'Infinity');\n            },\n            divide: function(f, g, x, lim, depth) { \n                if(depth++ > Settings.max_lim_depth) {\n                    return;\n                }\n\n                var fin = f.clone(), gin = g.clone();\n                \n                //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\n                //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\n                //the two-sided limit.\n                //Known limit\n                if(g.fname === ABS) {\n                    var sign = f.sign();\n                    var lim_sign = lim.sign();\n\n                    if(lim.isInfinity)\n                        return _.multiply(new Symbol(sign), new Symbol(lim_sign));\n                    \n                    else if(lim.equals(0)) {\n                        var fm = _.parse(f.multiplier);\n                        var gm = _.parse(g.multiplier);\n                        return _.divide(_.multiply(fm,__.Limit.interval('-1', '1')), gm);\n                    }\n                    else {\n                        //TODO: Support more limits\n                        __.Limit.diverges();\n                    }\n                }\n                \n                var isInfinity = function(L) {\n                    if(core.Utils.isVector(L)) {\n                        for(var i=0; i<L.elements.length; i++)\n                            if(!L.elements[i].isInfinity)\n                                return false;\n                        return true;\n                    }\n                    return L.isInfinity;     \n                };\n\n                var equals = function(L, v) {\n                    if(core.Utils.isVector(L)) {\n                        return false;\n                    }\n                    return L.equals(v);\n                };\n\n                var retval;\n                do {\n                    var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\n                    var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));\n\n                    //if it's in indeterminate form apply L'Hospital's rule\n                    var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);\n                    //pull the derivatives\n                    if(indeterminate) {\n                        var ft = __.diff(f.clone(), x);\n                        var gt = __.diff(g.clone(), x);\n\n                        var t_symbol = _.expand(_.divide(ft, gt));\n                        f = t_symbol.getNum();\n                        g = t_symbol.getDenom();\n                        \n                    }\n                }\n                while(indeterminate)  \n\n                //REMEMBER: \n                //- 1/cos(x)\n                //n/0 is still possible since we only checked for 0/0\n                var den_is_zero = lim2.equals(0);\n                var p = Number(gin.power);\n                \n                if(lim.isConstant(true) && den_is_zero) {\n                    retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\n                }\n                else if(den_is_zero) {\n                    retval = __.Limit.diverges();\n                }\n                else {\n                    retval = _.divide(lim1, lim2);\n                }\n                \n                return retval;\n            },\n            rewriteToLog: function(symbol) {\n                var p = symbol.power.clone();\n                symbol.toLinear();\n                return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG+'', [symbol])));\n            },\n            getSubbed: function(f, x, lim) {\n                var retval;\n                //1. rewrite EX with base e\n                if(f.group === EX) {\n                    f = __.rewriteToLog(f);\n                }\n                //2. try simple substitution\n                try {\n                    retval = f.sub(x, lim);\n                }\n                catch(e) {\n                    //Nope. No go, so just return the unsubbed function so we can test the limit instead.\n                    retval = f;\n                }\n                \n                return retval;\n            },\n            isInterval: function(limit) {\n                return core.Utils.isVector(limit);\n            },\n            isConvergent: function(limit) {\n                //it's not convergent if it lies on the interval -Infinity to Infinity\n                if(     \n                    //It lies on the interval -Infinity to Infinity\n                    __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity ||\n                    //We weren't able to calculate the limit\n                    limit.containsFunction('limit')\n                ) {\n                    return false; //Then no\n                }\n                return true; //It is\n            },\n            limit: function(symbol, x, lim, depth) {\n                //Simplify the symbol\n                symbol = core.Algebra.Simplify.simplify(symbol);\n                \n                depth = depth || 1;\n                \n                if(depth++ > Settings.max_lim_depth) {\n                    return;\n                }\n                \n                //store the multiplier\n                var m = _.parse(symbol.multiplier);\n                //strip the multiplier\n                symbol.toUnitMultiplier();\n                try {\n                    //https://en.wikipedia.org/wiki/List_of_limits\n                    var retval;\n                    //we try the simplest option first where c is some limit\n                    //lim a as x->c = a where c \n                    if(symbol.isConstant(true)) {\n                        retval = symbol;\n                    }\n                    else {\n                        var point = {};\n                        point[x] = lim;\n                        //lim x as x->c = c where c\n                        \n                        try {\n                            //evaluate the function at the given limit\n                            var t = _.parse(symbol.sub(x, lim), point);\n\n                            //a constant or infinity is known so we're done\n                            if(t.isConstant(true) || t.isInfinity)\n                                retval = t;\n                        }\n                        catch(e){ /*Nothing. Maybe we tried to divide by zero.*/};\n\n                        if(!retval) {\n                            //split the symbol in the numerator and the denominator\n                            var num = symbol.getNum();\n                            var den = symbol.getDenom();\n\n                            if(den.isConstant(true)) {\n                                //We still don't have a limit so we generate tests.\n                                if(symbol.group === EX) {\n                                    //https://en.wikipedia.org/wiki/List_of_limits\n                                    //Speed boost for exponentials by detecting patterns\n                                    var f = symbol.clone().toLinear();\n                                    var p = symbol.power.clone();\n                                    var _num = f.getNum();\n                                    var _den = f.getDenom();\n                                    var fn = core.Utils.decompose_fn(_den, x, true);\n                                    //start detection of pattern (x/(x+1))^x\n                                    if(_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\n                                        retval = _.parse(format('(1/e^({0}))', fn.b));\n                                    }\n                                    else {\n                                        var symbol_ = __.Limit.rewriteToLog(symbol.clone());\n                                        //get the base\n                                        var pow = symbol_.power.clone();\n                                        var base = symbol_.clone().toLinear();\n                                        var lim_base = __.Limit.limit(base, x, lim, depth);\n                                        var lim_pow = __.Limit.limit(pow, x, lim, depth);\n                                        retval = _.pow(lim_base, lim_pow);\n                                    }\n                                }\n                                else if(symbol.group === FN && symbol.args.length === 1 ) {\n                                    var evaluates;\n                                    //Squeeze theorem lim f(g(x)) = lim f(lim g))\n                                    var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\n                                    if(core.Utils.isVector(arg)) {\n                                        //get the limit over that interval\n                                        retval = arg.map(function(e) {\n                                            var clone = symbol.clone();\n                                            clone.args[0] = e;\n                                            return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\n                                        });\n                                        \n                                        return _.multiply(m, retval);\n                                    }\n                                    //if the argument is constant then we're done\n                                    else if(arg.isConstant(true)) {\n                                    \n                                        //double check that it evaluates\n                                        var trial = _.symfunction(symbol.fname, [arg]);\n                                        //trial evaluation\n                                        try {\n                                            evaluate(trial);\n                                            evaluates = true;\n                                        }\n                                        catch(e) {\n                                            \n                                            evaluates = false;\n                                        }\n                                    }\n                                    if(evaluates) {\n                                        retval = trial;\n                                    }\n                                    else {\n                                        //if the limit converges. We'll deal with non-convergent ones later\n                                        if(__.Limit.isConvergent(arg)) {\n                                            if(symbol.fname === LOG) { \n                                                switch(arg.toString()) {\n                                                    //lim -> 0\n                                                    case '0':\n                                                        retval = Symbol.infinity().negate();\n                                                        break;\n                                                    case 'Infinity':\n                                                        retval = Symbol.infinity();\n                                                        break;\n                                                    case '-Infinity':\n                                                        retval = Symbol.infinity();\n                                                        break;\n                                                }\n                                            }\n                                            else if((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\n                                                retval = __.Limit.interval(-1, 1);\n                                            }\n                                            else if(symbol.fname === Settings.FACTORIAL) {\n                                                if(arg.isInfinity)\n                                                    return Symbol.infinity();\n                                            }\n                                        }\n                                    }\n                                }\n                                else if(symbol.group === S) {\n                                    if(symbol.power > 0)\n                                        //these functions always converge to the limit\n                                        return _.parse(symbol, point);\n                                    else {\n                                        //we're dealing with 1/x^n but remember that infinity has already been dealt\n                                        //with by substitution\n                                        if(core.Utils.even(symbol.power)) {\n                                            //even powers converge to infinity\n                                            retval = Symbol.infinity();\n                                        }\n                                        else {\n                                            //odd ones don't\n                                            retval = __.Limit.diverges();\n                                        }   \n                                    }\n                                }\n                                else if(symbol.group === CB) { \n                                    \n                                    var lim1, lim2;\n                                    //loop through all the symbols\n                                    //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\n                                    //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\n                                    var symbols = symbol.collectSymbols().sort(function(a, b) {\n                                        return a.group - b.group;\n                                    });\n\n                                    var f = symbols.pop();\n                                    //calculate the first limit so we can keep going down the list\n                                    lim1 = evaluate(__.Limit.limit(f, x, lim, depth));\n\n                                    //reduces all the limits one at a time\n                                    while(symbols.length) {\n                                        //get the second limit\n                                        var g = symbols.pop();\n                                        //get the limit of g\n                                        lim2 = evaluate(__.Limit.limit(g, x, lim, depth));\n\n                                        //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\n                                        if((lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2))) { \n                                            if(g.containsFunction(LOG)) {\n                                                //swap them\n                                                g = [f, f = g][0];\n                                            }\n                                            //invert the symbol\n                                            g.invert();\n\n                                            lim1 = __.Limit.divide(f, g, x, lim, depth);\n                                        }\n                                        else {\n                                            //lim f*g = (lim f)*(lim g)\n                                            lim1 = _.multiply(lim1, lim2);\n                                            //let f*g equal f and h equal g \n                                            f = _.multiply(f, g);\n                                        }\n                                    }\n                                    //Done, lim1 is the limit we're looking for     \n                                    retval = lim1;\n                                }\n                                else if(symbol.isComposite()) { \n                                    var _lim;\n                                    if(!symbol.isLinear())\n                                        symbol = _.expand(symbol);\n                                    //Apply lim f+g = (lim f)+(lim g)\n                                    retval = new Symbol(0);\n                                    \n                                    var symbols = symbol.collectSymbols().sort(function(a, b) {\n                                        return b.group - a.group;\n                                    });\n\n                                    var _symbols = [];\n                                    //Analyze the functions first\n                                    var fns = new Symbol(0);\n                                    for(var i=0, l=symbols.length; i<l; i++) {\n                                        var sym = symbols[i].clone();\n                                        if(sym.group === FN || sym.group === CB && sym.hasFunc()) {\n                                            fns = _.add(fns, sym);\n                                        }\n                                        else\n                                            _symbols.push(sym);\n                                    }\n                                    _symbols.unshift(fns);\n                                    \n                                    //make sure that we didn't just repackage the exact same symbol\n                                    if(_symbols.length !== 1) {\n                                        symbols = _symbols;\n                                    }\n                                    \n                                    for(var i=0, l=symbols.length; i<l; i++) {\n                                        var sym = symbols[i];\n                                        //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\n                                        try {\n                                            _lim = __.Limit.limit(sym, x, lim, depth);\n                                        }\n                                        catch(e) {\n                                            _lim = __.Limit.diverges();\n                                        }\n                                        \n                                        try {\n                                            retval = _.add(retval, _lim);\n                                        }\n                                        catch(e) {\n                                            if(depth++ > Settings.max_lim_depth) {\n                                                return;\n                                            };\n                                            retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\n                                        }\n                                    }\n                                } \n                            }\n                            else {\n                                retval = __.Limit.divide(num, den, x, lim, depth);\n                            }    \n                        }\n                    }\n\n                    //if we still don't have a solution\n                    if(!retval)\n                        //return it symbolically\n                        retval = _.symfunction('limit', [symbol, x, lim]); \n                }\n                catch(e) {\n                    //if all else fails return the symbolic function\n                    retval = _.symfunction('limit', [symbol, x, lim]); \n                }\n                \n                return _.multiply(m, retval);\n            }\n        },\n        Fresnel: {\n            S: function(x) {\n                if(x.isConstant(true)) {\n                    return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\n                }\n                return _.symfunction('S', arguments);\n            },\n            C: function(x) {\n                if(x.isConstant(true)) {\n                    return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\n                }\n                return _.symfunction('C', arguments);\n            }\n        }\n    };\n    \n    nerdamer.register([\n        {\n            name: 'diff',\n            visible: true,\n            numargs: [1,3],\n            build: function(){ return __.diff; }\n        },\n        {\n            name: 'sum',\n            visible: true,\n            numargs: 4,\n            build: function(){ return __.sum; }\n        },\n        {\n            name: 'product',\n            visible: true,\n            numargs: 4,\n            build: function(){ return __.product; }\n        },\n        {\n            name: 'integrate',\n            visible: true,\n            numargs: [1, 2],\n            build: function() { return __.integrate; }\n        },\n        {\n            name: 'defint',\n            visible: true,\n            numargs: [3, 4],\n            build: function() { return __.defint; }\n        },\n        {\n            name: 'S',\n            visible: true,\n            numargs: 1,\n            build: function() { return __.Fresnel.S; }\n        },\n        {\n            name: 'C',\n            visible: true,\n            numargs: 1,\n            build: function() { return __.Fresnel.C; }\n        },\n        {\n            name: 'limit',\n            visible: true,\n            numargs: [3, 4],\n            build: function() { return __.Limit.limit; }\n        }\n    ]);\n    //link registered functions externally\n    nerdamer.api();\n   \n})();","// extracted by mini-css-extract-plugin\nmodule.exports = {\"post\":\"waves-module--post--2joRM\",\"math\":\"waves-module--math--vgcwZ\",\"image\":\"waves-module--image--2_Jac\",\"fadeIn\":\"waves-module--fadeIn--AGluC\"};","/*\n * Author : Martin Donk\n * Website : http://www.nerdamer.com\n * Email : martin.r.donk@gmail.com\n * Source : https://github.com/jiggzson/nerdamer\n */\n/* eslint-disable */\n\nvar nerdamer = require('./core.js');\nrequire('./Calculus.js');\nrequire('./Algebra.js');\n\n(function () {\n    //handle imports\n    var core = nerdamer.getCore(),\n            _ = core.PARSER,\n            _A = core.Algebra,\n            _C = core.Calculus,\n            explode = _C.integration.decompose_arg,\n            evaluate = core.Utils.evaluate,\n            remove = core.Utils.remove,\n            format = core.Utils.format,\n            build = core.Utils.build,\n            Symbol = core.Symbol,\n            isSymbol = core.Utils.isSymbol,\n            variables = core.Utils.variables,\n            S = core.groups.S,\n            PL = core.groups.PL,\n            CB = core.groups.CB,\n            CP = core.groups.CP,\n            FN = core.groups.FN,\n            Settings = core.Settings,\n            range = core.Utils.range,\n            isArray = core.Utils.isArray;\n\n    //The epsilon used in Newton's iteration\n    core.Settings.NEWTON_EPSILON = Number.EPSILON*5;\n    //The number used in Newton's iteration to verify if esitmated derivation close to 0\n    core.Settings.MAX_NEWTON_NUM = 1e-10\n    // Covert the number to multiples of pi if possible\n    core.Settings.make_pi_conversions = false;\n    // The maximum number to fish for on each side of the zero\n    core.Settings.ROOTS_PER_SIDE = 100;\n    //the maximum iterations for Newton's method\n    core.Settings.MAX_NEWTON_ITERATIONS = 100;\n\n    // The search radius for the roots\n    core.Settings.SOLVE_RADIUS = 1000;\n    // The step size\n    core.Settings.STEP_SIZE = 0.1;\n    //the maximum number of time non-linear solve tries another jump point\n    core.Settings.MAX_NON_LINEAR_TRIES = 12;\n    //the amount of iterations the function will start to jump at\n    core.Settings.NON_LINEAR_JUMP_AT = 50;\n    //the size of the jump\n    core.Settings.NON_LINEAR_JUMP_SIZE = 100;\n    //the original starting point for nonlinear solving\n    core.Settings.NON_LINEAR_START = 0.01;\n    //When points are generated as starting points for Newton's method, they are sliced into small\n    //slices to make sure that we have convergence on the right point. This defines the \n    //size of the slice\n    core.Settings.NEWTON_SLICES = 200;\n    //The distance in which two solutions are deemed the same\n    core.Settings.SOLUTION_PROXIMITY = 1e-14;\n    //Indicate wheter to filter the solutions are not\n    core.Settings.FILTER_SOLUTIONS = true;\n    //the maximum number of recursive calls\n    core.Settings.MAX_SOLVE_DEPTH = 10;\n    \n    core.Symbol.prototype.hasTrig = function () {\n        return this.containsFunction(['cos', 'sin', 'tan', 'cot', 'csc', 'sec']);\n    };\n\n    core.Symbol.prototype.hasNegativeTerms = function () {\n        if (this.isComposite()) {\n            for (var x in this.symbols) {\n                var sym = this.symbols[x];\n                if (sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0))\n                    return true;\n            }\n        }\n        return false;\n    };\n    \n    /* nerdamer version 0.7.x and up allows us to make better use of operator overloading\n     * As such we can have this data type be supported completely outside of the core.\n     * This is an equation that has a left hand side and a right hand side\n     */\n    function Equation(lhs, rhs) {\n        if (rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) || rhs.equals(core.Settings.IMAGINARY))\n            throw new core.exceptions.NerdamerValueError(lhs.toString() + ' does not equal ' + rhs.toString());\n        this.LHS = lhs; //left hand side\n        this.RHS = rhs; //right and side\n    };\n    \n    //UTILS ##!!\n\n    Equation.prototype = {\n        toString: function () {\n            return this.LHS.toString() + '=' + this.RHS.toString();\n        },\n        text: function (option) {\n            return this.LHS.text(option) + '=' + this.RHS.text(option);\n        },\n        toLHS: function (expand) {\n            expand = typeof expand === 'undefined' ? true : false;\n            var eqn;\n            if(!expand) {\n                eqn = this.clone();\n            }\n            else {\n                eqn = this.removeDenom();\n            }\n            var _t = _.subtract(eqn.LHS, eqn.RHS);\n            var retval = expand ? _.expand(_t) : _t;\n            return retval;\n        },\n        removeDenom: function () { \n            var a = this.LHS.clone();\n            var b = this.RHS.clone();\n            //remove the denominator on both sides\n            var den = _.multiply(a.getDenom(), b.getDenom());\n            a = _.expand(_.multiply(a, den.clone()));\n            b = _.expand(_.multiply(b, den));\n            //swap the groups\n            if (b.group === CP && b.group !== CP) {\n                var t = a;\n                a = b;\n                b = t; //swap\n            }\n\n            //scan to eliminate denominators\n            if (a.group === CB) {\n                var t = new Symbol(a.multiplier),\n                        newRHS = b.clone();\n                a.each(function (y) {\n                    if (y.power.lessThan(0))\n                        newRHS = _.divide(newRHS, y);\n                    else\n                        t = _.multiply(t, y);\n                });\n                a = t;\n                b = newRHS;\n\n            }\n            else if (a.group === CP) {\n                //the logic: loop through each and if it has a denominator then multiply it out on both ends\n                //and then start over\n                for (var x in a.symbols) {\n                    var sym = a.symbols[x];\n                    if (sym.group === CB) {\n                        for (var y in sym.symbols) {\n                            var sym2 = sym.symbols[y];\n                            if (sym2.power.lessThan(0)) {\n                                return new Equation(\n                                        _.expand(_.multiply(sym2.clone().toLinear(), a)),\n                                        _.expand(_.multiply(sym2.clone().toLinear(), b))\n                                        );\n                            }\n                        }\n                    }\n                }\n            }\n            \n            return new Equation(a, b);\n        },\n        clone: function () {\n            return new Equation(this.LHS.clone(), this.RHS.clone());\n        },\n        sub: function (x, y) {\n            var clone = this.clone();\n            clone.LHS = clone.LHS.sub(x.clone(), y.clone());\n            clone.RHS = clone.RHS.sub(x.clone(), y.clone());\n            return clone;\n        },\n        isZero: function () {\n            return core.Utils.evaluate(this.toLHS()).equals(0);\n        },\n        latex: function (option) {\n            return [this.LHS.latex(option), this.RHS.latex(option)].join('=');\n        }\n    };\n    //overwrite the equals function\n    _.equals = function (a, b) {\n        return new Equation(a, b);\n    };\n    \n    /**\n     * Sets two expressions equal\n     * @param {Symbol} symbol\n     * @returns {Expression}\n     */\n    core.Expression.prototype.equals = function(symbol) {\n        if(symbol instanceof core.Expression)\n            symbol = symbol.symbol; //grab the symbol if it's an expression\n        var eq = new Equation(this.symbol, symbol);\n        return eq;\n    };\n    \n    core.Expression.prototype.solveFor = function (x) {\n        var symbol;\n        if(this.symbol instanceof Equation) {\n            //exit right away if we already have the answer\n            //check the LHS\n            if(this.symbol.LHS.isConstant() && this.symbol.RHS.equals(x))\n                return new core.Expression(this.symbol.LHS);\n            \n            //check the RHS\n            if(this.symbol.RHS.isConstant() && this.symbol.LHS.equals(x))\n                return new core.Expression(this.symbol.RHS);\n            \n            //otherwise just bring it to LHS\n            symbol = this.symbol.toLHS();\n        }\n        else  {\n            symbol = this.symbol;\n        }\n            \n        \n        return solve(symbol, x).map(function (x) {\n            return new core.Expression(x);\n        });\n    };\n\n    core.Expression.prototype.expand = function () {\n        if (this.symbol instanceof Equation) {\n            var clone = this.symbol.clone();\n            clone.RHS = _.expand(clone.RHS);\n            clone.LHS = _.expand(clone.LHS);\n            return new core.Expression(clone);\n        }\n        return new core.Expression(_.expand(this.symbol));\n    };\n\n    core.Expression.prototype.variables = function () {\n        if (this.symbol instanceof Equation)\n            return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));\n        return variables(this.symbol);\n    };\n    \n    core.Matrix.jacobian = function(eqns, vars) {\n        var jacobian = new core.Matrix();\n        //get the variables if not supplied\n        if(!vars) {\n            vars = __.getSystemVariables(eqns);\n        }\n        \n        vars.forEach(function(v, i) {\n            eqns.forEach(function(eq, j) {\n                var e = core.Calculus.diff(eq.clone(), v);\n                jacobian.set(j, i, e);\n            });\n        });\n        \n        return jacobian;\n    };\n    \n    core.Matrix.prototype.max = function() {\n        var max = new Symbol(0);\n        this.each(function(x) {\n            var e = x.abs();\n            if(e.gt(max))\n                max = e;\n        });\n        return max;\n    };\n    \n    core.Matrix.cMatrix = function(value, vars) {\n        var m = new core.Matrix();\n        //make an initial guess\n        vars.forEach(function(v, i) {\n            m.set(i, 0, _.parse(value));\n        });\n        return m;\n    };\n\n    var setEq = function (a, b) {\n        return _.equals(a, b);\n    };\n\n    //link the Equation class back to the core\n    core.Equation = Equation;\n    \n    //Loops through an array and attempts to fails a test. Stops if manages to fail.\n    var checkAll = core.Utils.checkAll = function (args, test) {\n        for (var i = 0; i < args.length; i++)\n            if (test(args[i]))\n                return false;\n        return true;\n    };\n    \n    //version solve\n    var __ = core.Solve = {\n        version: '2.0.3',\n        solutions: [],\n        solve: function (eq, variable) {\n            var solution = solve(eq, String(variable));\n            return new core.Vector(solution);\n            //return new core.Vector(solve(eq.toString(), variable ? variable.toString() : variable));\n        },\n        /**\n         * Brings the equation to LHS. A string can be supplied which will be converted to an Equation\n         * @param {Equation|String} eqn\n         * @returns {Symbol}\n         */\n        toLHS: function (eqn, expand) {            \n            if(isSymbol(eqn))\n                return eqn;\n            //If it's an equation then call its toLHS function instead\n            if (!(eqn instanceof Equation)) {\n                var es = eqn.split('=');\n                //convert falsey values to zero\n                es[1] = es[1] || '0';\n                eqn = new Equation(_.parse(es[0]), _.parse(es[1]));\n            }\n            return eqn.toLHS(expand);\n        },\n        getSystemVariables: function(eqns) {\n            let vars = '';\n            vars = variables(eqns[0], null, null, true);\n\n            //get all variables\n            for (var i = 1, l=eqns.length; i < l; i++)\n                vars = vars.concat(variables(eqns[i]));\n            //remove duplicates\n            vars = core.Utils.arrayUnique(vars).sort();\n            \n            //done\n            return vars;\n        },\n        solveNonLinearSystem: function(eqns, tries, start) {\n            if(tries < 0)\n                return [];//can't find a solution\n            start = typeof start === 'undefined' ? core.Settings.NON_LINEAR_START : start;\n\n            //the maximum number of times to jump\n            var max_tries = core.Settings.MAX_NON_LINEAR_TRIES;\n            \n            //halfway through the tries\n            var halfway = Math.floor(max_tries/2);\n            \n            //initialize the number of tries to 10 if not specified\n            tries = typeof tries === 'undefined' ? max_tries : tries;\n            \n            //a point at which we check to see if we're converging. By inspection it seems that we can\n            //use around 20 iterations to see if we're converging. If not then we retry a jump of x\n            var jump_at = core.Settings.NON_LINEAR_JUMP_AT; \n            \n            //we jump by this many points at each pivot point\n            var jump = core.Settings.NON_LINEAR_JUMP_SIZE;\n            \n            //used to check if we actually found a solution or if we gave up. Assume we will find a solution.\n            var found = true;\n            \n            var create_subs = function(vars, matrix) {\n                return vars.map(function(x, i) {\n                    return Number(matrix.get(i, 0));\n                });\n            };\n            \n            var vars = __.getSystemVariables(eqns);\n            var jacobian = core.Matrix.jacobian(eqns, vars, function(x) {\n                return build(x, vars);\n            }, true);\n            \n            var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;\n            var o, y, iters, xn1, norm, lnorm, xn, d;\n            \n            var f_eqns = eqns.map(function(eq) {\n                return build(eq, vars);\n            });\n            \n            var J = jacobian.map(function(e) {\n                return build(e, vars);\n            }, true);\n            //initial values\n            xn1 = core.Matrix.cMatrix(0, vars);;\n            //initialize the c matrix with something close to 0. \n            var c = core.Matrix.cMatrix(start, vars);\n            \n            iters = 0;\n            \n            //start of algorithm\n            do {\n                //if we've reached the max iterations then exit\n                if(iters > max_iter) {\n                    break;\n                    found = false;\n                }\n                \n                //set the substitution object\n                o = create_subs(vars, c);\n                \n                //set xn\n                xn = c.clone();\n                \n                //make all the substitutions for each of the equations\n                f_eqns.forEach(function(f, i) {\n                    c.set(i, 0, f.apply(null, o));\n                });\n                \n                var m = new core.Matrix();\n                J.each(function(fn, i, j) {\n                    var ans = fn.apply(null, o);\n                    m.set(i, j, ans);\n                });\n\n                m = m.invert();\n                \n                //preform the elimination\n                y = _.multiply(m, c).negate();\n                \n                //the callback is to avoid overflow in the coeffient denonimator\n                //it converts it to a decimal and then back to a fraction. Some precision\n                //is lost be it's better than overflow. \n                d = y.subtract(xn1, function(x) { return _.parse(Number(x)); });\n\n                xn1 = xn.add(y, function(x) { return _.parse(Number(x)); });\n\n                //move c is now xn1\n                c = xn1;\n                \n                //get the norm\n                \n                //the expectation is that we're converging to some answer as this point regardless of where we start\n                //this may have to be adjusted at some point because of erroneous assumptions\n                if(iters >= jump_at) {\n                    //check the norm. If the norm is greater than one then it's time to try another point\n                    if(norm > 1) {\n                        //reset the start point at halway\n                        if(tries === halfway)\n                            start = 0;\n                        var sign = tries > halfway ? 1 : -1; //which side are we incrementing\n                        //we increment +n at one side and -n at the other. \n                        let n = (tries % Math.floor(halfway))+1;\n                        //adjust the start point\n                        start += (sign*n*jump);\n                        //call restart\n                        return __.solveNonLinearSystem(eqns, --tries, start);\n                    }\n                }\n                lnorm = norm;\n                iters++;\n                norm = d.max();\n                \n                //exit early. Revisit if we get bugs\n                if(Number(norm) === Number(lnorm))\n                    break;\n                \n            }\n            while(Number(norm) >= Number.EPSILON)\n            \n            //return a blank set if nothing was found;\n            if(!found) \n                return [];\n            \n            //return c since that's the answer\n            return __.systemSolutions(c, vars, true, function(x) {\n                return core.Utils.round(Number(x), 14);\n            });\n        },\n        systemSolutions: function(result, vars, expand_result, callback) {\n            var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];\n            \n            result.each(function (e, idx) {\n                var solution = (expand_result ? _.expand(e) : e).valueOf();\n                if(callback)\n                    solution = callback.call(e, solution);\n                var variable = vars[idx];\n                if (core.Settings.SOLUTIONS_AS_OBJECT) {\n                    solutions[variable] = solution;\n                }\n                else\n                    solutions.push([variable, solution]); /*NO*/\n            });\n            //done\n            return solutions;\n        },\n        //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf\n        solveSystem: function (eqns, var_array) {\n            //check if a var_array was specified\n            //nerdamer.clearVars();// this deleted ALL variables: not what we want\n            //parse all the equations to LHS. Remember that they come in as strings\n            for (var i = 0; i < eqns.length; i++)\n                eqns[i] = __.toLHS(eqns[i]);\n\n            var l = eqns.length,\n                m = new core.Matrix(),\n                c = new core.Matrix(),\n                expand_result = false,\n                vars;\n\n            if (typeof var_array === 'undefined') {\n                //check to make sure that all the equations are linear\n                if (!_A.allLinear(eqns))\n                    return __.solveNonLinearSystem(eqns);\n                    //core.err('System must contain all linear equations!');\n                \n                vars = __.getSystemVariables(eqns);\n                // deletes only the variables of the linear equations in the nerdamer namespace\n                for (var i = 0; i < vars.length; i++) {\n                    nerdamer.setVar(vars[i], \"delete\");\n                }\n                // populate the matrix\n                for (var i = 0; i < l; i++) {\n                    var e = eqns[i]; //store the expression\n                    for (var j = 0; j < l; j++) {\n                        var v = vars[j];\n                        var coeffs = [];\n                        e.each(function(x) {\n                            if(x.contains(v)) {\n                                coeffs = coeffs.concat(x.coeffs());\n                            }\n                        });\n\n                        var cf = core.Utils.arraySum(coeffs);\n                        m.set(i, j, cf);\n                    }\n\n                    //strip the variables from the symbol so we're left with only the zeroth coefficient\n                    //start with the symbol and remove each variable and its coefficient\n                    var num = e.clone();\n                    vars.map(function(e) {\n                        num = num.stripVar(e, true);\n                    });\n                    c.set(i, 0, num.negate());\n                }\n            }\n            else {\n                /**\n                 * The idea is that we loop through each equation and then expand it. Afterwards we loop\n                 * through each term and see if and check to see if it matches one of the variables.\n                 * When a match is found we mark it. No other match should be found for that term. If it\n                 * is we stop since it's not linear.\n                 */\n                vars = var_array;\n                expand_result = true;\n                for (i = 0; i < l; i++) {\n                    //prefill\n                    c.set(i, 0, new Symbol(0));\n                    var e = _.expand(eqns[i]).collectSymbols(); //expand and store\n                    //go trough each of the variables\n                    for (var j = 0; j < var_array.length; j++) {\n                        m.set(i, j, new Symbol(0));\n                        var v = var_array[j];\n                        //go through the terms and sort the variables\n                        for (var k = 0; k < e.length; k++) {\n                            var term = e[k],\n                                    check = false;\n                            for (var z = 0; z < var_array.length; z++) {\n                                //check to see if terms contain multiple variables\n                                if (term.contains(var_array[z])) {\n                                    if (check)\n                                        core.err('Multiple variables found for term ' + term);\n                                    check = true;\n                                }\n                            }\n                            //we made sure that every term contains one variable so it's safe to assume that if the\n                            //variable is found then the remainder is the coefficient.\n                            if (term.contains(v)) {\n                                var tparts = explode(remove(e, k), v);\n                                m.set(i, j, _.add(m.get(i, j), tparts[0]));\n                            }\n                        }\n                    }\n                    //all the remaining terms go to the c matrix\n                    for (k = 0; k < e.length; k++) {\n                        c.set(i, 0, _.add(c.get(i, 0), e[k]));\n                    }\n                }\n                //consider case (a+b)*I+u\n            }\n\n            //check if the system has a distinct solution\n            if(m.determinant().equals(0))\n                throw new core.exceptions.SolveError('System does not have a distinct solution');\n            // Use M^-1*c to solve system\n            m = m.invert();\n            var result = m.multiply(c);\n            //correct the sign as per issue #410\n            if (core.Utils.isArray(var_array))\n                result.each(function (x) {\n                    return x.negate();\n                });\n            \n            \n            return __.systemSolutions(result, vars, expand_result);\n        },\n        /**\n         * The quadratic function but only one side.\n         * @param {Symbol} c\n         * @param {Symbol} b\n         * @param {Symbol} a\n         * @returns {Symbol}\n         */\n        quad: function (c, b, a) {\n            var discriminant = _.subtract(_.pow(b.clone(), Symbol(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol(4)))/*b^2 - 4ac*/;\n            var det = _.pow(discriminant, Symbol(0.5));\n            var retval = [\n                _.parse(_.divide(_.add(b.clone().negate(), det.clone()), _.multiply(new Symbol(2), a.clone()))),\n                _.parse(_.divide(_.subtract(b.clone().negate(), det.clone()), _.multiply(new Symbol(2), a.clone())))\n            ];\n            return retval;\n        },\n        /**\n         * The cubic equation\n         * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations\n         * @param {Symbol} d_o\n         * @param {Symbol} c_o\n         * @param {Symbol} b_o\n         * @param {Symbol} a_o\n         * @returns {Array}\n         */\n        cubic:function (d_o, c_o, b_o, a_o) {\n            //convert everything to text\n            var a = a_o.text(), b = b_o.text(), c = c_o.text(), d = d_o.text();\n            var d0s = '({1})^2-3*({0})*({2})',\n                    d0 = _.parse(format(d0s, a, b, c)),\n                    Q = _.parse(format('((2*({1})^3-9*({0})*({1})*({2})+27*({0})^2*({3}))^2-4*(({1})^2-3*({0})*({2}))^3)^(1/2)', a, b, c, d)),\n                    C = _.parse(format('((1/2)*(({4})+2*({1})^3-9*({0})*({1})*({2})+27*({0})^2*({3})))^(1/3)', a, b, c, d, Q));\n            //check if C equals 0\n            var scope = {};\n            //populate the scope object\n            variables(C).map(function (x) {\n                scope[x] = 1;\n            });\n\n            var Ct = core.Utils.block('PARSE2NUMBER', function () {\n                return _.parse(C, scope);\n            });\n\n            if (Number(d0) === 0 && Number(Ct) === 0) //negate Q such that C != 0\n                C = _.parse(format('((1/2)*(-({4})+2*({1})^3-9*({0})*({1})*({2})+27*({0})^2*({3})))^(1/3)', a, b, c, d, Q));\n\n            var xs = [\n                '-(b/(3*a))-C/(3*a)-(((b^2-3*a*c))/(3*a*C))',\n                '-(b/(3*a))+(C*(1+i*sqrt(3)))/(6*a)+((1-i*sqrt(3))*(b^2-3*a*c))/(6*a*C)'.replace(/i/g, core.Settings.IMAGINARY),\n                '-(b/(3*a))+(C*(1-i*sqrt(3)))/(6*a)+((1+i*sqrt(3))*(b^2-3*a*c))/(6*a*C)'.replace(/i/g, core.Settings.IMAGINARY)\n            ];\n\n            return xs.map(function (e, i) {\n                var o = {a: a_o.clone(), b: b_o.clone(), c: c_o.clone(), d: d_o.clone(), C: C.clone()};\n                return _.parse(e, o);\n            });\n        },\n        /**\n         * The quartic equation\n         * @param {Symbol} e\n         * @param {Symbol} d\n         * @param {Symbol} c\n         * @param {Symbol} b\n         * @param {Symbol} a\n         * @returns {Array}\n         */\n        quartic: function (e, d, c, b, a) {\n            var scope = {};\n            core.Utils.arrayUnique(variables(a).concat(variables(b))\n                    .concat(variables(c)).concat(variables(d)).concat(variables(e)))\n                    .map(function (x) {\n                        scope[x] = 1;\n                    });\n            a = a.toString();\n            b = b.toString();\n            c = c.toString();\n            d = d.toString();\n            e = e.toString();\n            var p, q, D, D0, D1, Q, x1, x2, x3, x4;\n            /*var D = core.Utils.block('PARSE2NUMBER', function() {\n             return _.parse(format(\"256*({0})^3*({4})^3-192*({0})^2*({1})*({3})*({4})^2-128*({0})^2*({2})^2*({4})^2+144*({0})^2*({2})*({3})^2*({4})\"+\n             \"-27*({0})^2*({3})^4+144*({0})*({1})^2*({2})*({4})^2-6*({0})*({1})^2*({3})^2*({4})-80*({0})*({1})*({2})^2*({3})*({4})+18*({0})*({1})*({2})*({3})^3\"+\n             \"+16*({0})*({2})^4*({4})-4*({0})*({2})^3*({3})^2-27*({1})^4*({4})^2+18*({1})^3*({2})*({3})*({4})-4*({1})^3*({3})^3-4*({1})^2*({2})^3*({4})+({1})^2*({2})^2*({3})^2\", \n             a, b, c, d, e), scope);\n             });*/\n\n            p = _.parse(format(\"(8*({0})*({2})-3*({1})^2)/(8*({0})^2)\", a, b, c)).toString(); //a, b, c\n            q = _.parse(format(\"(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)\", a, b, c, d)).toString();//a, b, c, d, e\n            D0 = _.parse(format(\"12*({0})*({4})-3*({1})*({3})+({2})^2\", a, b, c, d, e)).toString(); //a, b, c, d, e\n            D1 = _.parse(format(\"2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})\", a, b, c, d, e)).toString(); //a, b, c, d, e\n            Q = _.parse(format(\"((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)\", D0, D1)).toString(); //D0, D1\n            S = _.parse(format(\"(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)\", a, p, Q, D0)).toString(); //a, p, Q, D0\n            x1 = _.parse(format(\"-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n            x2 = _.parse(format(\"-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n            x3 = _.parse(format(\"-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n            x4 = _.parse(format(\"-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n            return [x1, x2, x3, x4];\n        },\n        /**\n         * Breaks the equation up in its factors and tries to solve the smaller parts\n         * @param {Symbol} symbol\n         * @param {String} solve_for\n         * @returns {Array}\n         */\n        divideAndConquer: function (symbol, solve_for) {\n            var sols = [];\n            //see if we can solve the factors\n            var factors = core.Algebra.Factor.factor(symbol);\n            if (factors.group === CB) {\n                factors.each(function (x) {\n                    x = Symbol.unwrapPARENS(x);\n                    sols = sols.concat(solve(x, solve_for));\n                });\n            }\n            return sols;\n        },\n        /**\n         * Attempts to solve the equation assuming it's a polynomial with numeric coefficients\n         * @param {Symbol} eq\n         * @param {String} solve_for\n         * @returns {Array}\n         */\n        csolve: function (eq, solve_for) {\n            return core.Utils.block('IGNORE_E', function () {\n                var f, p, pn, n, pf, r, theta, sr, sp, roots;\n                roots = [];\n                f = core.Utils.decompose_fn(eq, solve_for, true);\n                if (f.x.group === S) {\n                    p = _.parse(f.x.power);\n                    pn = Number(p);\n                    n = _.pow(_.divide(f.b.negate(), f.a), p.invert());\n                    pf = Symbol.toPolarFormArray(n);\n                    r = pf[0];\n                    theta = pf[1];\n                    sr = r.toString();\n                    sp = p.toString();\n                    var k, root, str;\n                    for (var i = 0; i < pn; i++) {\n                        k = i;\n                        str = format('({0})*e^(2*{1}*pi*{2}*{3})', sr, k, p, core.Settings.IMAGINARY);\n                        root = _.parse(str);\n                        roots.push(root);\n                    }\n                }\n                return roots;\n            }, true);\n        },\n        /**\n         * Generates starting points for the Newton solver given an expression at zero.\n         * It beings by check if zero is a good point and starts expanding by a provided step size. \n         * Builds on the fact that if the sign changes over an interval then a zero\n         * must exist on that interval\n         * @param {Symbol} symbol\n         * @param {Number} step\n         * @param {Array} points\n         * @returns {Array}\n         */\n        getPoints: function (symbol, step, points) {\n            step = step || 0.01;\n            points = points || [];\n            var f = build(symbol);\n            var x0 = 0;\n                \n            var start = Math.round(x0),\n                    last = f(start),\n                    last_sign = last / Math.abs(last),\n                    rside = core.Settings.ROOTS_PER_SIDE, // the max number of roots on right side\n                    lside = rside; // the max number of roots on left side\n            // check around the starting point\n            points.push(Math.floor(start / 2)); //half way from zero might be a good start\n            points.push(Math.abs(start)); //|f(0)| could be a good start\n            points.push(start);//|f(0)| could be a good start\n            //adjust for log. A good starting point to include for log is 0.1\n            symbol.each(function (x) {\n                if (x.containsFunction(core.Settings.LOG))\n                    points.push(0.1);\n            });\n            \n            var left = range(-core.Settings.SOLVE_RADIUS, start, step),\n                right = range(start, core.Settings.SOLVE_RADIUS, step);\n            \n            var test_side = function(side, num_roots) {\n                var xi, val, sign;\n                var hits = [];\n                for(var i=0, l=side.length; i<l; i++) {\n                    xi = side[i]; //the point being evaluated\n                    val = f(xi);\n                    sign = val / Math.abs(val);\n                    //Don't add non-numeric values\n                    if (isNaN(val) || !isFinite(val) || hits.length > num_roots) { \n                        continue;\n                    }\n\n                    //compare the signs. The have to be different if they cross a zero\n                    if (sign !== last_sign) {\n                        hits.push(xi); //take note of the possible zero location\n                    }\n                    last_sign = sign;\n                }\n\n                points = points.concat(hits);\n            };\n            \n            // test_side(left, lside);\n            test_side(right, rside);\n            \n            return points;\n        },\n        Newton: function (point, f, fp) {\n            var maxiter = core.Settings.MAX_NEWTON_ITERATIONS,\n                    iter = 0;\n            //first try the point itself. If it's zero viola. We're done\n            var x0 = point, x;\n            do {\n                var fx0 = f(x0); //store the result of the function\n                //if the value is zero then we're done because 0 - (0/d f(x0)) = 0\n                if (x0 === 0 && fx0 === 0) {\n                    x = 0;\n                    break;\n                }\n                \n                iter++;\n                if (iter > maxiter)\n                    return; //naximum iterations reached\n\n                x = x0 - fx0 / fp(x0);\n                var e = Math.abs(x - x0);\n                x0 = x;\n            }\n            while (e > Settings.NEWTON_EPSILON)\n            \n            //check if the number is indeed zero. 1e-13 seems to give the most accurate results\n            if(Math.abs(f(x)) <= core.Settings.MAX_NEWTON_NUM)\n                return x;\n        },\n        rewrite: function (rhs, lhs, for_variable) {\n            lhs = lhs || new Symbol(0);\n            if(rhs.isComposite() && rhs.isLinear()) {\n                //try to isolate the square root\n                //container for the square roots\n                var sqrts = [];\n                //all else\n                var rem = [];\n                rhs.each(function(x) {\n                    x = x.clone();\n                    if(x.fname === 'sqrt' && x.contains(for_variable)) {\n                        sqrts.push(x);\n                    }\n                    else {\n                        rem.push(x);\n                    }\n                }, true);\n\n                if(sqrts.length === 1) {\n                    //move the remainder to the RHS\n                    lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol(2)));\n                    //square both sides\n                    rhs = _.expand(_.pow(Symbol.unwrapSQRT(sqrts[0]), new Symbol(2)));\n                }\n            }\n            else {\n                rhs = Symbol.unwrapSQRT(_.expand(rhs)); //expand the term expression go get rid of quotients when possible\n            }\n            \n            var c = 0, //a counter to see if we have all terms with the variable\n                    l = rhs.length;\n            //try to rewrite the whole thing\n            if (rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {\n                rhs.distributeMultiplier();\n                var t = new Symbol(0);\n                //first bring all the terms containing the variable to the lhs\n                rhs.each(function (x) {\n                    if (x.contains(for_variable)) {\n                        c++;\n                        t = _.add(t, x.clone());\n                    }\n                    else\n                        lhs = _.subtract(lhs, x.clone());\n                });\n                rhs = t;\n\n                //if not all the terms contain the variable so it's in the form\n                //a*x^2+x\n                if (c !== l) {\n                    return __.rewrite(rhs, lhs, for_variable);\n                }\n                else {\n                    return [rhs, lhs];\n                }\n            }\n            else if (rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {\n                if (rhs.multiplier.lessThan(0)) {\n                    rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));\n                    lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));\n                }\n                if (lhs.equals(0))\n                    return new Symbol(0);\n                else {\n                    var t = new Symbol(1);\n                    rhs.each(function (x) {\n                        if (x.contains(for_variable))\n                            t = _.multiply(t, x.clone());\n                        else\n                            lhs = _.divide(lhs, x.clone());\n                    });\n                    rhs = t;\n                    return __.rewrite(rhs, lhs, for_variable);\n\n                }\n            }\n            else if (!rhs.isLinear() && rhs.contains(for_variable)) {\n                var p = _.parse(rhs.power.clone().invert());\n                rhs = _.pow(rhs, p.clone());\n                lhs = _.pow(_.expand(lhs), p.clone());\n                return __.rewrite(rhs, lhs, for_variable);\n            }\n            else if (rhs.group === FN || rhs.group === S || rhs.group === PL) {\n                return [rhs, lhs];\n            }\n        },\n        sqrtSolve: function(symbol, v) {\n            var sqrts = new Symbol(0);\n            var rem = new Symbol(0);\n            if(symbol.isComposite()) {\n                symbol.each(function(x) {\n                    if(x.fname === 'sqrt' && x.contains(v)) {\n                        sqrts = _.add(sqrts, x.clone());\n                    }\n                    else {\n                        rem = _.add(rem, x.clone());\n                    }\n                });\n                //quick and dirty ATM\n                if(!sqrts.equals(0)) {\n                    var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol(2)), _.pow(sqrts, new Symbol(2)))));\n                    //square both sides\n                    var solutions = solve(t, v);\n                    //test the points. The dumb way of getting the answers\n                    solutions = solutions.filter(function(e) {\n                        if(e.isImaginary())\n                            return e;\n                        var subs = {};\n                        subs[v] = e;\n                        var point = evaluate(symbol, subs);\n                        if(point.equals(0))\n                            return e;\n                    });\n                    return solutions;\n                }\n            }\n        }\n    };\n\n    /*\n     * \n     * @param {String[]|String|Equation} eqns\n     * @param {type} solve_for\n     * @returns {Array}\n     */\n    var solve = function (eqns, solve_for, solutions, depth) {\n        depth = depth || 0;\n        \n        if(depth++ > Settings.MAX_SOLVE_DEPTH) {\n            return solutions;\n        }\n        \n        //make preparations if it's an Equation\n        if (eqns instanceof Equation) {\n            //if it's zero then we're done\n            if (eqns.isZero())\n                return [new Symbol(0)];\n            //if the lhs = x then we're done\n            if (eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {\n                return [eqns.RHS];\n            }\n            //if the rhs = x then we're done\n            if (eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {\n                return [eqns.LHS];\n            }\n        }\n\n        //unwrap the vector since what we want are the elements\n        if (eqns instanceof core.Vector)\n            eqns = eqns.elements;\n        solve_for = solve_for || 'x'; //assumes x by default\n        //If it's an array then solve it as a system of equations\n        if (isArray(eqns)) {\n            return __.solveSystem.apply(undefined, arguments);\n        }\n        \n        //parse out functions. Fix for issue #300\n        //eqns = core.Utils.evaluate(eqns);\n        solutions = solutions || [];\n        //mark existing solutions as not to have duplicates\n        var existing = {}; \n        //Is usued to add solutions to set. \n        //TODO: Set is now implemented and should be utilized\n        var add_to_result = function (r, has_trig) {\n            var r_is_symbol = isSymbol(r);\n            if (r === undefined || typeof r === 'number' && isNaN(r))\n                return;\n            if (isArray(r)) {\n                r.map(function(sol) {\n                    add_to_result(sol);\n                });\n            }\n            else {\n                if (r.valueOf() !== 'null') {\n                    if (!r_is_symbol)\n                        r = _.parse(r);\n                    //try to convert the number to multiples of pi\n                    if (core.Settings.make_pi_conversions && has_trig) {\n                        var temp = _.divide(r.clone(), new Symbol(Math.PI)),\n                                m = temp.multiplier,\n                                a = Math.abs(m.num),\n                                b = Math.abs(m.den);\n                        if (a < 10 && b < 10)\n                            r = _.multiply(temp, new Symbol('pi'));\n                    }\n                    //convert to a string so we can mark it as a known solution\n                    var r_str = r.toString();\n                    if (!existing[r_str])\n                        solutions.push(r); /*NO*/\n                    //mark the answer as seen\n                    existing[r_str] = true;\n                }\n            }\n        };\n        //maybe we get lucky\n        if (eqns.group === S && eqns.contains(solve_for)) {\n            add_to_result(new Symbol(0));\n            return solutions;\n        }\n        if (eqns.group === CB) {\n            var sf = String(solve_for); //everything else belongs to the coeff\n            //get the denominator and make sure it doesn't have x since we don't know how to solve for those\n            eqns.each(function (x) {\n                if (x.contains(sf))\n                    solve(x, solve_for, solutions);\n            });\n\n            return solutions;\n        }\n        \n        if(eqns.group === FN && eqns.fname === 'sqrt') {\n            eqns = _.pow(Symbol.unwrapSQRT(eqns), new Symbol(2));\n        }\n        //pass in false to not expand equations such as (x+y)^5.\n        //It suffices to solve for the numerator since there's no value in the denominator which yields a zero for the function\n        var eq = (core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns, false)).getNum(),\n                vars = core.Utils.variables(eq), //get a list of all the variables\n                numvars = vars.length;//how many variables are we dealing with\n        \n        //it sufficient to solve (x+y) if eq is (x+y)^n since 0^n\n        if(core.Utils.isInt(eq.power) && eq.power > 0) {\n            eq = _.parse(eq).toLinear();\n        }\n       \n        //if we're dealing with a single variable then we first check if it's a \n        //polynomial (including rationals).If it is then we use the Jenkins-Traubb algorithm.     \n        //Don't waste time\n        if (eq.group === S || eq.group === CB && eq.contains(solve_for))\n            return [new Symbol(0)];\n        //force to polynomial. We go through each and then we look at what it would \n        //take for its power to be an integer\n        //if the power is a fractional we divide by the fractional power\n        var fractionals = {},\n                cfact;\n        \n        var correct_denom = function (symbol) {\n            symbol = _.expand(symbol);\n            var original = symbol.clone(); //preserve the original\n            \n            if (symbol.symbols) {\n                for (var x in symbol.symbols) {\n                    var sym = symbol.symbols[x];\n                    \n                    //get the denominator of the sub-symbol\n                    var den = sym.getDenom();\n                    \n                    if(!den.isConstant(true) && symbol.isComposite()) {\n                        var t = new Symbol(0);\n                        symbol.each(function(e) {\n                            t = _.add(t, _.multiply(e, den.clone()));\n                        });\n\n                        return correct_denom(_.multiply(_.parse(symbol.multiplier), t));\n                    }\n                    \n                    var parts = explode(sym, solve_for);\n                    var is_sqrt = parts[1].fname === core.Settings.SQRT;\n                    var v = Symbol.unwrapSQRT(parts[1]);\n                    var p = v.power.clone();\n                    //circular logic with sqrt. Since sqrt(x) becomes x^(1/2) which then becomes sqrt(x), this continues forever\n                    //this needs to be terminated if p = 1/2\n                    if (!isSymbol(p) && !p.equals(1 / 2)) {\n                        if (p.den.gt(1)) {\n                            if (is_sqrt) {\n                                symbol = _.subtract(symbol, sym.clone());\n                                symbol = _.add(symbol, _.multiply(parts[0].clone(), v));\n                                return correct_denom(symbol);\n                            }\n                            var c = fractionals[p.den];\n                            fractionals[p.den] = c ? c++ : 1;\n                        }\n                        else if (p.sign() === -1) {\n                            var factor = _.parse(solve_for + '^' + Math.abs(p)); //this\n                            //unwrap the symbol's denoniator\n                            symbol.each(function (y, index) {\n                                if (y.contains(solve_for)) {\n                                    symbol.symbols[index] = _.multiply(y, factor.clone());\n                                }\n                            });\n                            fractionals = {};\n                            return correct_denom(_.parse(symbol));\n                        }\n                        else if (sym.group === PL) {\n                            var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));\n                            if (min_p < 0) {\n                                var factor = _.parse(solve_for + '^' + Math.abs(min_p));\n                                var corrected = new Symbol(0);\n                                original.each(function (x) {\n                                    corrected = _.add(corrected, _.multiply(x.clone(), factor.clone()));\n                                }, true);\n                                return corrected;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            return symbol;\n        };\n\n        //separate the equation\n        var separate = function (eq) {\n            var lhs = new Symbol(0),\n                    rhs = new Symbol(0);\n            eq.each(function (x) {\n                if (x.contains(solve_for, true))\n                    lhs = _.add(lhs, x.clone());\n                else\n                    rhs = _.subtract(rhs, x.clone());\n            });\n            return [lhs, rhs];\n        };\n\n        __.inverseFunctionSolve = function(name, lhs, rhs) {\n            //ax+b comes back as [a, x, ax, b];\n            var parts = explode(lhs.args[0], solve_for);\n            //check if x is by itself\n            var x = parts[1];\n            if(x.group === S) {\n                return _.divide(_.symfunction(name, [_.divide(rhs, _.parse(lhs.multiplier))]), parts[0]);\n            }\n            \n        };\n        \n        //first remove any denominators\n        eq = correct_denom(eq);\n\n        if (eq.equals(0))\n            return [eq];\n        //correct fractionals. I can only handle one type right now\n        var fkeys = core.Utils.keys(fractionals);\n        if (fkeys.length === 1) {\n            //make a note of the factor\n            cfact = fkeys[0];\n            eq.each(function (x, index) {\n                if (x.contains(solve_for)) {\n                    var parts = explode(x, solve_for);\n                    var v = parts[1];\n                    var p = v.power;\n                    if (p.den.gt(1)) {\n                        v.power = p.multiply(new core.Frac(cfact));\n                        eq.symbols[index] = _.multiply(v, parts[0]);\n                    }\n                }\n            });\n            eq = _.parse(eq);\n        }\n        \n        //try for nested sqrts as per issue #486\n        add_to_result(__.sqrtSolve(eq, solve_for));\n        \n        //polynomial single variable\n        if (numvars === 1) {\n            if (eq.isPoly(true)) {\n                //try to factor and solve\n                var factors = new core.Algebra.Classes.Factors();\n\n                core.Algebra.Factor.factor(eq, factors);\n                //if the equation has more than one symbolic factor then solve those individually\n                if(factors.getNumberSymbolics() > 1) {\n                    for(var x in factors.factors) {\n                        add_to_result(solve(factors.factors[x], solve_for));\n                    }\n                }\n                else {\n                    var coeffs = core.Utils.getCoeffs(eq, solve_for),\n                            deg = coeffs.length - 1,\n                            was_calculated = false;\n                    if (vars[0] === solve_for) {\n                        //check to see if all the coefficients are constant\n                        if (checkAll(coeffs, function (x) {\n                            return x.group !== core.groups.N;\n                        })) {\n                            var roots = core.Algebra.proots(eq);\n                            //if all the roots are integers then return those\n                            if (checkAll(roots, function (x) {\n                                return !core.Utils.isInt(x);\n                            })) {\n                                //roots have been calculates\n                                was_calculated = true;\n                                roots.map(function (x) {\n                                    add_to_result(new Symbol(x));\n                                });\n                            }\n                        }\n\n                        if (!was_calculated) {\n                            eqns = _.parse(eqns);\n                            if(eqns instanceof core.Equation)\n                                eqns = eqns.toLHS();\n                            \n                            //we can solve algebraically for degrees 1, 2, 3. The remainder we switch to Jenkins-\n                            if (deg === 1)\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\n                            else if (deg === 2) {\n                                add_to_result(_.expand(__.quad.apply(undefined, coeffs)));\n                            }\n                            else if (deg === 3) {\n                                var solutions = []; //set to blank\n                                //first try to factor and solve\n                                var factored = core.Algebra.Factor.factor(eqns);\n                                //if it was successfully factored\n                                var solutions = !factored.equals(eqns) ? solve(factored, solve_for) : [];\n                                if(solutions.length > 0)\n                                    add_to_result(solutions);\n                                else\n                                    add_to_result(__.cubic.apply(undefined, coeffs));\n                            }\n                            else {\n                                /*\n                                 var sym_roots = csolve(eq, solve_for); \n                                 if(sym_roots.length === 0)\n                                 sym_roots = divnconsolve(eq, solve_for);\n                                 if(sym_roots.length > 0) \n                                 add_to_result(sym_roots);\n                                 else\n                                 */\n                                _A.proots(eq).map(add_to_result);\n                            }\n                        }\n                    }\n                }\n                \n            }\n            else {\n                try {\n                    //Attempt Newton\n                    //since it's not a polynomial then we'll try to look for a solution using Newton's method\n                    //this is not a very broad search but takes the positions that something is better than nothing\n                    var has_trig = eq.hasTrig();\n                    // we get all the points where a possible zero might exist.\n                    var points1 = __.getPoints(eq, 0.1);\n                    var points2 = __.getPoints(eq, 0.05);\n                    var points3 = __.getPoints(eq, 0.01);\n                    var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)).sort(function(a, b) { return a-b});\n                    \n                    //generate slices\n                    //points = core.Utils.arrayAddSlices(points, Settings.NEWTON_SLICES); \n\n                    //compile the function and the derivative of the function\n                    var f = build(eq.clone());\n                    \n                    var d = _C.diff(eq.clone());\n                    \n                    var fp = build(d);\n                    for (var i = 0; i < points.length; i++) {\n                        var point = points[i];\n                        \n                        add_to_result(__.Newton(point, f, fp), has_trig);\n                    }\n                    solutions.sort();\n                }\n                catch(e) {\n                    console.log(e);\n                }   \n            }\n            \n        }\n        else {\n            //The idea here is to go through the equation and collect the coefficients\n            //place them in an array and call the quad or cubic function to get the results\n            if (!eq.hasFunc(solve_for) && eq.isComposite()) {\n                try {\n                    var factored = core.Algebra.Factor.factor(eq.clone());\n                    \n                    if(factored.group === CB) {\n                        factored.each(function(x) {\n                            add_to_result(solve(x, solve_for));\n                        });\n                    }\n                    else {\n                        var coeffs = core.Utils.getCoeffs(eq, solve_for);\n\n                        var l = coeffs.length,\n                                deg = l - 1; //the degree of the polynomial\n                        //get the denominator and make sure it doesn't have x\n\n                        //handle the problem based on the degree\n                        switch (deg) {\n                            case 0:\n                                var separated = separate(eq);\n                                var lhs = separated[0],\n                                        rhs = separated[1];\n                                if (lhs.group === core.groups.EX) {\n                                    add_to_result(_.parse(core.Utils.format(core.Settings.LOG+'(({0})/({2}))/'+core.Settings.LOG+'({1})', rhs, lhs.value, lhs.multiplier)));\n                                }\n                                break;\n                            case 1:\n                                //nothing to do but to return the quotient of the constant and the LT\n                                //e.g. 2*x-1\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\n                                break;\n                            case 2:\n                                add_to_result(__.quad.apply(undefined, coeffs));\n                                break;\n                            case 3:\n                                add_to_result(__.cubic.apply(undefined, coeffs));\n                                break;\n                            case 4:\n                                add_to_result(__.quartic.apply(undefined, coeffs));\n                                break;\n                            default:\n                                add_to_result(__.csolve(eq, solve_for));\n                                if (solutions.length === 0)\n                                    add_to_result(__.divideAndConquer(eq, solve_for));\n                        }\n                        \n                        if(solutions.length === 0) {\n                            //try factoring\n                            add_to_result(solve(factored, solve_for, solutions, depth));\n                        }\n                    }  \n                    \n                }\n                catch (e) { /*something went wrong. EXITING*/\n                    ;\n                }\n            }\n            else {\n                try {\n                    var rw = __.rewrite(eq, null, solve_for); \n                    var lhs = rw[0];\n                    var rhs = rw[1];\n                    if (lhs.group === FN) {\n                        if (lhs.fname === 'abs') {\n                            add_to_result([rhs.clone(), rhs.negate()]);\n                        }\n                        else if(lhs.fname === 'sin') {\n                            //asin\n                            add_to_result(__.inverseFunctionSolve('asin', lhs, rhs));\n                        }\n                        else if(lhs.fname === 'cos') {\n                            //asin\n                            add_to_result(__.inverseFunctionSolve('acos', lhs, rhs));\n                        }\n                        else if(lhs.fname === 'tan') {\n                            //asin\n                            add_to_result(__.inverseFunctionSolve('atan', lhs, rhs));\n                        }\n                        else if(lhs.fname === core.Settings.LOG) {\n                            //ax+b comes back as [a, x, ax, b];\n                            var parts = explode(lhs.args[0], solve_for);\n                            //check if x is by itself\n                            var x = parts[1];\n                            if(x.group === S) {\n                                rhs = _.divide(_.subtract(_.pow(lhs.args.length > 1 ? lhs.args[1] : new Symbol('e'), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);\n                                var eq = new Equation(x, rhs).toLHS();\n                                add_to_result(solve(eq, solve_for));\n                            }\n                            \n                        }\n                        else\n                            add_to_result(_.subtract(lhs, rhs));\n                    }\n                    else {\n                        var neq = new Equation(lhs, rhs).toLHS(); //create a new equation\n\n                        if(neq.equals(eq))\n                            throw new Error('Stopping. No stop condition exists');\n                        add_to_result(solve(neq, solve_for));\n                    }\n                }\n                catch (error) {\n                    //Let's try this another way\n                    try {\n                        //1. if the symbol is in the form a*b*c*... then the solution is zero if \n                        //either a or b or c is zero.\n                        if (eq.group === CB)\n                            add_to_result(0);\n                        else if (eq.group === CP) {\n                            var separated = separate(eq);\n                            var lhs = separated[0],\n                                    rhs = separated[1];\n\n                            //reduce the equation\n                            if (lhs.group === core.groups.EX && lhs.value === solve_for) {\n                                //change the base of both sides\n                                var p = lhs.power.clone().invert();\n                                add_to_result(_.pow(rhs, p));\n                            }\n                        }\n                    }\n                    catch (error) {\n                        ;\n                    }\n                }\n            }\n        }\n\n        if (cfact) {\n            solutions = solutions.map(function (x) {\n                return _.pow(x, new Symbol(cfact));\n            });\n        }\n        \n        return solutions;\n    };\n    \n    //Register the functions for external use\n    nerdamer.register([\n        {\n            name: 'solveEquations',\n            parent: 'nerdamer',\n            numargs: -1,\n            visible: true,\n            build: function () {\n                return solve; //comment out to return a vector\n                /*\n                 return function() {\n                 return core.Utils.convertToVector(solve.apply(null, arguments));\n                 };\n                 */\n            }\n        },\n        {\n            name: 'solve',\n            parent: 'Solve',\n            numargs: 2,\n            visible: true,\n            build: function () {\n                return core.Solve.solve;\n            }\n        },\n        /*\n         {\n         name: 'polysolve',\n         parent: 'Solve',\n         visible: true,\n         build: function(){ return polysolve; }\n         },\n         */\n        {\n            name: 'setEquation',\n            parent: 'Solve',\n            visible: true,\n            build: function () {\n                return setEq;\n            }\n        }\n    ]);\n    nerdamer.api();\n})();","module.exports = __webpack_public_path__ + \"static/hierarchy-219454aee12583615a21713af1dd376d.png\";","require(\"core-js/modules/es.typed-array.sort.js\");\n\n;\n\n(function (globalScope) {\n  'use strict';\n  /*\r\n   *  decimal.js v10.2.1\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Licence\r\n   */\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\n  // The maximum exponent magnitude.\n  // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\n\n  var EXP_LIMIT = 9e15,\n      // 0 to 9e15\n  // The limit on the value of `precision`, and on the value of the first argument to\n  // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\n  MAX_DIGITS = 1e9,\n      // 0 to 1e9\n  // Base conversion alphabet.\n  NUMERALS = '0123456789abcdef',\n      // The natural logarithm of 10 (1025 digits).\n  LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\n      // Pi (1025 digits).\n  PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\n      // The initial configuration properties of the Decimal constructor.\n  DEFAULTS = {\n    // These values must be integers within the stated ranges (inclusive).\n    // Most of these values can be changed at run-time using the `Decimal.config` method.\n    // The maximum number of significant digits of the result of a calculation or base conversion.\n    // E.g. `Decimal.config({ precision: 20 });`\n    precision: 20,\n    // 1 to MAX_DIGITS\n    // The rounding mode used when rounding to `precision`.\n    //\n    // ROUND_UP         0 Away from zero.\n    // ROUND_DOWN       1 Towards zero.\n    // ROUND_CEIL       2 Towards +Infinity.\n    // ROUND_FLOOR      3 Towards -Infinity.\n    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n    //\n    // E.g.\n    // `Decimal.rounding = 4;`\n    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\n    rounding: 4,\n    // 0 to 8\n    // The modulo mode used when calculating the modulus: a mod n.\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n    // The remainder (r) is calculated as: r = a - n * q.\n    //\n    // UP         0 The remainder is positive if the dividend is negative, else is negative.\n    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\n    // FLOOR      3 The remainder has the same sign as the divisor (Python %).\n    // HALF_EVEN  6 The IEEE 754 remainder function.\n    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\n    //\n    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\n    // division (9) are commonly used for the modulus operation. The other rounding modes can also\n    // be used, but they may not give useful results.\n    modulo: 1,\n    // 0 to 9\n    // The exponent value at and beneath which `toString` returns exponential notation.\n    // JavaScript numbers: -7\n    toExpNeg: -7,\n    // 0 to -EXP_LIMIT\n    // The exponent value at and above which `toString` returns exponential notation.\n    // JavaScript numbers: 21\n    toExpPos: 21,\n    // 0 to EXP_LIMIT\n    // The minimum exponent value, beneath which underflow to zero occurs.\n    // JavaScript numbers: -324  (5e-324)\n    minE: -EXP_LIMIT,\n    // -1 to -EXP_LIMIT\n    // The maximum exponent value, above which overflow to Infinity occurs.\n    // JavaScript numbers: 308  (1.7976931348623157e+308)\n    maxE: EXP_LIMIT,\n    // 1 to EXP_LIMIT\n    // Whether to use cryptographically-secure random number generation, if available.\n    crypto: false // true/false\n\n  },\n      // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\n  Decimal,\n      inexact,\n      noConflict,\n      quadrant,\n      external = true,\n      decimalError = '[DecimalError] ',\n      invalidArgument = decimalError + 'Invalid argument: ',\n      precisionLimitExceeded = decimalError + 'Precision limit exceeded',\n      cryptoUnavailable = decimalError + 'crypto unavailable',\n      mathfloor = Math.floor,\n      mathpow = Math.pow,\n      isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\n      isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\n      isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\n      isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\n      BASE = 1e7,\n      LOG_BASE = 7,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      LN10_PRECISION = LN10.length - 1,\n      PI_PRECISION = PI.length - 1,\n      // Decimal.prototype object\n  P = {\n    name: '[object Decimal]'\n  }; // Decimal prototype methods\n\n  /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */\n\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\n\n  P.absoluteValue = P.abs = function () {\n    var x = new this.constructor(this);\n    if (x.s < 0) x.s = 1;\n    return finalise(x);\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */\n\n\n  P.ceil = function () {\n    return finalise(new this.constructor(this), this.e + 1, 2);\n  };\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */\n\n\n  P.comparedTo = P.cmp = function (y) {\n    var i,\n        j,\n        xdL,\n        ydL,\n        x = this,\n        xd = x.d,\n        yd = (y = new x.constructor(y)).d,\n        xs = x.s,\n        ys = y.s; // Either NaN or Infinity?\n\n    if (!xd || !yd) {\n      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n    } // Either zero?\n\n\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0; // Signs differ?\n\n    if (xs !== ys) return xs; // Compare exponents.\n\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\n    xdL = xd.length;\n    ydL = yd.length; // Compare digit by digit.\n\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\n      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n    } // Compare lengths.\n\n\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n  };\n  /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */\n\n\n  P.cosine = P.cos = function () {\n    var pr,\n        rm,\n        x = this,\n        Ctor = x.constructor;\n    if (!x.d) return new Ctor(NaN); // cos(0) = cos(-0) = 1\n\n    if (!x.d[0]) return new Ctor(1);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n    Ctor.rounding = 1;\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n  };\n  /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */\n\n\n  P.cubeRoot = P.cbrt = function () {\n    var e,\n        m,\n        n,\n        r,\n        rep,\n        s,\n        sd,\n        t,\n        t3,\n        t3plusx,\n        x = this,\n        Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    external = false; // Initial estimate.\n\n    s = x.s * mathpow(x.s * x, 1 / 3); // Math.cbrt underflow/overflow?\n    // Pass x to Math.pow as integer, then adjust the exponent of the result.\n\n    if (!s || Math.abs(s) == 1 / 0) {\n      n = digitsToString(x.d);\n      e = x.e; // Adjust n exponent so it is a multiple of 3 away from x exponent.\n\n      if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? '0' : '00';\n      s = mathpow(n, 1 / 3); // Rarely, e may be one less than the result exponent value.\n\n      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n\n      if (s == 1 / 0) {\n        n = '5e' + e;\n      } else {\n        n = s.toExponential();\n        n = n.slice(0, n.indexOf('e') + 1) + e;\n      }\n\n      r = new Ctor(n);\n      r.s = x.s;\n    } else {\n      r = new Ctor(s.toString());\n    }\n\n    sd = (e = Ctor.precision) + 3; // Halley's method.\n    // TODO? Compare Newton's method.\n\n    for (;;) {\n      t = r;\n      t3 = t.times(t).times(t);\n      t3plusx = t3.plus(x);\n      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1); // TODO? Replace with for-loop and checkRoundingDigits.\n\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n        n = n.slice(sd - 3, sd + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\n        // , i.e. approaching a rounding boundary, continue the iteration.\n\n        if (n == '9999' || !rep && n == '4999') {\n          // On the first iteration only, check to see if rounding up gives the exact result as the\n          // nines may infinitely repeat.\n          if (!rep) {\n            finalise(t, e + 1, 0);\n\n            if (t.times(t).times(t).eq(x)) {\n              r = t;\n              break;\n            }\n          }\n\n          sd += 4;\n          rep = 1;\n        } else {\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n          // If not, then there are further digits and m will be truthy.\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\n            // Truncate to the first rounding digit.\n            finalise(r, e + 1, 1);\n            m = !r.times(r).times(r).eq(x);\n          }\n\n          break;\n        }\n      }\n    }\n\n    external = true;\n    return finalise(r, e, Ctor.rounding, m);\n  };\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\n\n\n  P.decimalPlaces = P.dp = function () {\n    var w,\n        d = this.d,\n        n = NaN;\n\n    if (d) {\n      w = d.length - 1;\n      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE; // Subtract the number of trailing zeros of the last word.\n\n      w = d[w];\n      if (w) for (; w % 10 == 0; w /= 10) {\n        n--;\n      }\n      if (n < 0) n = 0;\n    }\n\n    return n;\n  };\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\n\n\n  P.dividedBy = P.div = function (y) {\n    return divide(this, new this.constructor(y));\n  };\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\n\n\n  P.dividedToIntegerBy = P.divToInt = function (y) {\n    var x = this,\n        Ctor = x.constructor;\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n  };\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\n\n\n  P.equals = P.eq = function (y) {\n    return this.cmp(y) === 0;\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */\n\n\n  P.floor = function () {\n    return finalise(new this.constructor(this), this.e + 1, 3);\n  };\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\n\n\n  P.greaterThan = P.gt = function (y) {\n    return this.cmp(y) > 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\n\n\n  P.greaterThanOrEqualTo = P.gte = function (y) {\n    var k = this.cmp(y);\n    return k == 1 || k === 0;\n  };\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */\n\n\n  P.hyperbolicCosine = P.cosh = function () {\n    var k,\n        n,\n        pr,\n        rm,\n        len,\n        x = this,\n        Ctor = x.constructor,\n        one = new Ctor(1);\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\n    if (x.isZero()) return one;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n    Ctor.rounding = 1;\n    len = x.d.length; // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\n    // Estimate the optimum number of times to use the argument reduction.\n    // TODO? Estimation reused from cosine() and may not be optimal here.\n\n    if (len < 32) {\n      k = Math.ceil(len / 3);\n      n = (1 / tinyPow(4, k)).toString();\n    } else {\n      k = 16;\n      n = '2.3283064365386962890625e-10';\n    }\n\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true); // Reverse argument reduction\n\n    var cosh2_x,\n        i = k,\n        d8 = new Ctor(8);\n\n    for (; i--;) {\n      cosh2_x = x.times(x);\n      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n    }\n\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n  };\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */\n\n\n  P.hyperbolicSine = P.sinh = function () {\n    var k,\n        pr,\n        rm,\n        len,\n        x = this,\n        Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n    Ctor.rounding = 1;\n    len = x.d.length;\n\n    if (len < 3) {\n      x = taylorSeries(Ctor, 2, x, x, true);\n    } else {\n      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\n      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\n      // 3 multiplications and 1 addition\n      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\n      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\n      // 4 multiplications and 2 additions\n      // Estimate the optimum number of times to use the argument reduction.\n      k = 1.4 * Math.sqrt(len);\n      k = k > 16 ? 16 : k | 0;\n      x = x.times(1 / tinyPow(5, k));\n      x = taylorSeries(Ctor, 2, x, x, true); // Reverse argument reduction\n\n      var sinh2_x,\n          d5 = new Ctor(5),\n          d16 = new Ctor(16),\n          d20 = new Ctor(20);\n\n      for (; k--;) {\n        sinh2_x = x.times(x);\n        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n      }\n    }\n\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(x, pr, rm, true);\n  };\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */\n\n\n  P.hyperbolicTangent = P.tanh = function () {\n    var pr,\n        rm,\n        x = this,\n        Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(x.s);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 7;\n    Ctor.rounding = 1;\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n  };\n  /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */\n\n\n  P.inverseCosine = P.acos = function () {\n    var halfPi,\n        x = this,\n        Ctor = x.constructor,\n        k = x.abs().cmp(1),\n        pr = Ctor.precision,\n        rm = Ctor.rounding;\n\n    if (k !== -1) {\n      return k === 0 // |x| is 1\n      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) // |x| > 1 or x is NaN\n      : new Ctor(NaN);\n    }\n\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5); // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\n\n    Ctor.precision = pr + 6;\n    Ctor.rounding = 1;\n    x = x.asin();\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return halfPi.minus(x);\n  };\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */\n\n\n  P.inverseHyperbolicCosine = P.acosh = function () {\n    var pr,\n        rm,\n        x = this,\n        Ctor = x.constructor;\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\n    if (!x.isFinite()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n    Ctor.rounding = 1;\n    external = false;\n    x = x.times(x).minus(1).sqrt().plus(x);\n    external = true;\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.ln();\n  };\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */\n\n\n  P.inverseHyperbolicSine = P.asinh = function () {\n    var pr,\n        rm,\n        x = this,\n        Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n    Ctor.rounding = 1;\n    external = false;\n    x = x.times(x).plus(1).sqrt().plus(x);\n    external = true;\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.ln();\n  };\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */\n\n\n  P.inverseHyperbolicTangent = P.atanh = function () {\n    var pr,\n        rm,\n        wpr,\n        xsd,\n        x = this,\n        Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    xsd = x.sd();\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\n    Ctor.precision = wpr = xsd - x.e;\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n    Ctor.precision = pr + 4;\n    Ctor.rounding = 1;\n    x = x.ln();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(0.5);\n  };\n  /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */\n\n\n  P.inverseSine = P.asin = function () {\n    var halfPi,\n        k,\n        pr,\n        rm,\n        x = this,\n        Ctor = x.constructor;\n    if (x.isZero()) return new Ctor(x);\n    k = x.abs().cmp(1);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n\n    if (k !== -1) {\n      // |x| is 1\n      if (k === 0) {\n        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n        halfPi.s = x.s;\n        return halfPi;\n      } // |x| > 1 or x is NaN\n\n\n      return new Ctor(NaN);\n    } // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\n\n\n    Ctor.precision = pr + 6;\n    Ctor.rounding = 1;\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(2);\n  };\n  /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */\n\n\n  P.inverseTangent = P.atan = function () {\n    var i,\n        j,\n        k,\n        n,\n        px,\n        t,\n        r,\n        wpr,\n        x2,\n        x = this,\n        Ctor = x.constructor,\n        pr = Ctor.precision,\n        rm = Ctor.rounding;\n\n    if (!x.isFinite()) {\n      if (!x.s) return new Ctor(NaN);\n\n      if (pr + 4 <= PI_PRECISION) {\n        r = getPi(Ctor, pr + 4, rm).times(0.5);\n        r.s = x.s;\n        return r;\n      }\n    } else if (x.isZero()) {\n      return new Ctor(x);\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n      r = getPi(Ctor, pr + 4, rm).times(0.25);\n      r.s = x.s;\n      return r;\n    }\n\n    Ctor.precision = wpr = pr + 10;\n    Ctor.rounding = 1; // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\n    // Argument reduction\n    // Ensure |x| < 0.42\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\n\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n\n    for (i = k; i; --i) {\n      x = x.div(x.times(x).plus(1).sqrt().plus(1));\n    }\n\n    external = false;\n    j = Math.ceil(wpr / LOG_BASE);\n    n = 1;\n    x2 = x.times(x);\n    r = new Ctor(x);\n    px = x; // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\n\n    for (; i !== -1;) {\n      px = px.times(x2);\n      t = r.minus(px.div(n += 2));\n      px = px.times(x2);\n      r = t.plus(px.div(n += 2));\n      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;) {\n        ;\n      }\n    }\n\n    if (k) r = r.times(2 << k - 1);\n    external = true;\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n  };\n  /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */\n\n\n  P.isFinite = function () {\n    return !!this.d;\n  };\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\n\n\n  P.isInteger = P.isInt = function () {\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n  };\n  /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */\n\n\n  P.isNaN = function () {\n    return !this.s;\n  };\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\n\n\n  P.isNegative = P.isNeg = function () {\n    return this.s < 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\n\n\n  P.isPositive = P.isPos = function () {\n    return this.s > 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */\n\n\n  P.isZero = function () {\n    return !!this.d && this.d[0] === 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\n\n\n  P.lessThan = P.lt = function (y) {\n    return this.cmp(y) < 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\n\n\n  P.lessThanOrEqualTo = P.lte = function (y) {\n    return this.cmp(y) < 1;\n  };\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\n\n\n  P.logarithm = P.log = function (base) {\n    var isBase10,\n        d,\n        denominator,\n        k,\n        inf,\n        num,\n        sd,\n        r,\n        arg = this,\n        Ctor = arg.constructor,\n        pr = Ctor.precision,\n        rm = Ctor.rounding,\n        guard = 5; // Default base is 10.\n\n    if (base == null) {\n      base = new Ctor(10);\n      isBase10 = true;\n    } else {\n      base = new Ctor(base);\n      d = base.d; // Return NaN if base is negative, or non-finite, or is 0 or 1.\n\n      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\n      isBase10 = base.eq(10);\n    }\n\n    d = arg.d; // Is arg negative, non-finite, 0 or 1?\n\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n    } // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\n    // integer power of 10.\n\n\n    if (isBase10) {\n      if (d.length > 1) {\n        inf = true;\n      } else {\n        for (k = d[0]; k % 10 === 0;) {\n          k /= 10;\n        }\n\n        inf = k !== 1;\n      }\n    }\n\n    external = false;\n    sd = pr + guard;\n    num = naturalLogarithm(arg, sd);\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd); // The result will have 5 rounding digits.\n\n    r = divide(num, denominator, sd, 1); // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\n    // calculate 10 further digits.\n    //\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\n    // further digits, the last 14 are nines, round up and assume the result is exact.\n    // Also assume the result is exact if the last 14 are zero.\n    //\n    // Example of a result that will be incorrectly rounded:\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\n    // place is still 2.6.\n\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\n      do {\n        sd += 10;\n        num = naturalLogarithm(arg, sd);\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n        r = divide(num, denominator, sd, 1);\n\n        if (!inf) {\n          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\n          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n            r = finalise(r, pr + 1, 0);\n          }\n\n          break;\n        }\n      } while (checkRoundingDigits(r.d, k += 10, rm));\n    }\n\n    external = true;\n    return finalise(r, pr, rm);\n  };\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'lt');\r\n  };\r\n   */\n\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'gt');\r\n  };\r\n   */\n\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\n\n\n  P.minus = P.sub = function (y) {\n    var d,\n        e,\n        i,\n        j,\n        k,\n        len,\n        pr,\n        rm,\n        xd,\n        xe,\n        xLTy,\n        yd,\n        x = this,\n        Ctor = x.constructor;\n    y = new Ctor(y); // If either is not finite...\n\n    if (!x.d || !y.d) {\n      // Return NaN if either is NaN.\n      if (!x.s || !y.s) y = new Ctor(NaN); // Return y negated if x is finite and y is Infinity.\n      else if (x.d) y.s = -y.s; // Return x if y is finite and x is Infinity.\n        // Return x if both are Infinity with different signs.\n        // Return NaN if both are Infinity with the same sign.\n        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n      return y;\n    } // If signs differ...\n\n\n    if (x.s != y.s) {\n      y.s = -y.s;\n      return x.plus(y);\n    }\n\n    xd = x.d;\n    yd = y.d;\n    pr = Ctor.precision;\n    rm = Ctor.rounding; // If either is zero...\n\n    if (!xd[0] || !yd[0]) {\n      // Return y negated if x is zero and y is non-zero.\n      if (yd[0]) y.s = -y.s; // Return x if y is zero and x is non-zero.\n      else if (xd[0]) y = new Ctor(x); // Return zero if both are zero.\n        // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\n        else return new Ctor(rm === 3 ? -0 : 0);\n      return external ? finalise(y, pr, rm) : y;\n    } // x and y are finite, non-zero numbers with the same sign.\n    // Calculate base 1e7 exponents.\n\n\n    e = mathfloor(y.e / LOG_BASE);\n    xe = mathfloor(x.e / LOG_BASE);\n    xd = xd.slice();\n    k = xe - e; // If base 1e7 exponents differ...\n\n    if (k) {\n      xLTy = k < 0;\n\n      if (xLTy) {\n        d = xd;\n        k = -k;\n        len = yd.length;\n      } else {\n        d = yd;\n        e = xe;\n        len = xd.length;\n      } // Numbers with massively different exponents would result in a very high number of\n      // zeros needing to be prepended, but this can be avoided while still ensuring correct\n      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\n\n\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n\n      if (k > i) {\n        k = i;\n        d.length = 1;\n      } // Prepend zeros to equalise exponents.\n\n\n      d.reverse();\n\n      for (i = k; i--;) {\n        d.push(0);\n      }\n\n      d.reverse(); // Base 1e7 exponents equal.\n    } else {\n      // Check digits to determine which is the bigger number.\n      i = xd.length;\n      len = yd.length;\n      xLTy = i < len;\n      if (xLTy) len = i;\n\n      for (i = 0; i < len; i++) {\n        if (xd[i] != yd[i]) {\n          xLTy = xd[i] < yd[i];\n          break;\n        }\n      }\n\n      k = 0;\n    }\n\n    if (xLTy) {\n      d = xd;\n      xd = yd;\n      yd = d;\n      y.s = -y.s;\n    }\n\n    len = xd.length; // Append zeros to `xd` if shorter.\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\n\n    for (i = yd.length - len; i > 0; --i) {\n      xd[len++] = 0;\n    } // Subtract yd from xd.\n\n\n    for (i = yd.length; i > k;) {\n      if (xd[--i] < yd[i]) {\n        for (j = i; j && xd[--j] === 0;) {\n          xd[j] = BASE - 1;\n        }\n\n        --xd[j];\n        xd[i] += BASE;\n      }\n\n      xd[i] -= yd[i];\n    } // Remove trailing zeros.\n\n\n    for (; xd[--len] === 0;) {\n      xd.pop();\n    } // Remove leading zeros and adjust exponent accordingly.\n\n\n    for (; xd[0] === 0; xd.shift()) {\n      --e;\n    } // Zero?\n\n\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\n    y.d = xd;\n    y.e = getBase10Exponent(xd, e);\n    return external ? finalise(y, pr, rm) : y;\n  };\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */\n\n\n  P.modulo = P.mod = function (y) {\n    var q,\n        x = this,\n        Ctor = x.constructor;\n    y = new Ctor(y); // Return NaN if x is Infinity or NaN, or y is NaN or 0.\n\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN); // Return x if y is Infinity or x is 0.\n\n    if (!y.d || x.d && !x.d[0]) {\n      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n    } // Prevent rounding of intermediate calculations.\n\n\n    external = false;\n\n    if (Ctor.modulo == 9) {\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\n      // result = x - q * y    where  0 <= result < abs(y)\n      q = divide(x, y.abs(), 0, 3, 1);\n      q.s *= y.s;\n    } else {\n      q = divide(x, y, 0, Ctor.modulo, 1);\n    }\n\n    q = q.times(y);\n    external = true;\n    return x.minus(q);\n  };\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\n\n\n  P.naturalExponential = P.exp = function () {\n    return naturalExponential(this);\n  };\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\n\n\n  P.naturalLogarithm = P.ln = function () {\n    return naturalLogarithm(this);\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\n\n\n  P.negated = P.neg = function () {\n    var x = new this.constructor(this);\n    x.s = -x.s;\n    return finalise(x);\n  };\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\n\n\n  P.plus = P.add = function (y) {\n    var carry,\n        d,\n        e,\n        i,\n        k,\n        len,\n        pr,\n        rm,\n        xd,\n        yd,\n        x = this,\n        Ctor = x.constructor;\n    y = new Ctor(y); // If either is not finite...\n\n    if (!x.d || !y.d) {\n      // Return NaN if either is NaN.\n      if (!x.s || !y.s) y = new Ctor(NaN); // Return x if y is finite and x is Infinity.\n      // Return x if both are Infinity with the same sign.\n      // Return NaN if both are Infinity with different signs.\n      // Return y if x is finite and y is Infinity.\n      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\n      return y;\n    } // If signs differ...\n\n\n    if (x.s != y.s) {\n      y.s = -y.s;\n      return x.minus(y);\n    }\n\n    xd = x.d;\n    yd = y.d;\n    pr = Ctor.precision;\n    rm = Ctor.rounding; // If either is zero...\n\n    if (!xd[0] || !yd[0]) {\n      // Return x if y is zero.\n      // Return y if y is non-zero.\n      if (!yd[0]) y = new Ctor(x);\n      return external ? finalise(y, pr, rm) : y;\n    } // x and y are finite, non-zero numbers with the same sign.\n    // Calculate base 1e7 exponents.\n\n\n    k = mathfloor(x.e / LOG_BASE);\n    e = mathfloor(y.e / LOG_BASE);\n    xd = xd.slice();\n    i = k - e; // If base 1e7 exponents differ...\n\n    if (i) {\n      if (i < 0) {\n        d = xd;\n        i = -i;\n        len = yd.length;\n      } else {\n        d = yd;\n        e = k;\n        len = xd.length;\n      } // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\n\n\n      k = Math.ceil(pr / LOG_BASE);\n      len = k > len ? k + 1 : len + 1;\n\n      if (i > len) {\n        i = len;\n        d.length = 1;\n      } // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\n\n\n      d.reverse();\n\n      for (; i--;) {\n        d.push(0);\n      }\n\n      d.reverse();\n    }\n\n    len = xd.length;\n    i = yd.length; // If yd is longer than xd, swap xd and yd so xd points to the longer array.\n\n    if (len - i < 0) {\n      i = len;\n      d = yd;\n      yd = xd;\n      xd = d;\n    } // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\n\n\n    for (carry = 0; i;) {\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n      xd[i] %= BASE;\n    }\n\n    if (carry) {\n      xd.unshift(carry);\n      ++e;\n    } // Remove trailing zeros.\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n\n\n    for (len = xd.length; xd[--len] == 0;) {\n      xd.pop();\n    }\n\n    y.d = xd;\n    y.e = getBase10Exponent(xd, e);\n    return external ? finalise(y, pr, rm) : y;\n  };\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\n\n\n  P.precision = P.sd = function (z) {\n    var k,\n        x = this;\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\n\n    if (x.d) {\n      k = getPrecision(x.d);\n      if (z && x.e + 1 > k) k = x.e + 1;\n    } else {\n      k = NaN;\n    }\n\n    return k;\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\n\n\n  P.round = function () {\n    var x = this,\n        Ctor = x.constructor;\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n  };\n  /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */\n\n\n  P.sine = P.sin = function () {\n    var pr,\n        rm,\n        x = this,\n        Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n    Ctor.rounding = 1;\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n  };\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */\n\n\n  P.squareRoot = P.sqrt = function () {\n    var m,\n        n,\n        sd,\n        r,\n        rep,\n        t,\n        x = this,\n        d = x.d,\n        e = x.e,\n        s = x.s,\n        Ctor = x.constructor; // Negative/NaN/Infinity/zero?\n\n    if (s !== 1 || !d || !d[0]) {\n      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n    }\n\n    external = false; // Initial estimate.\n\n    s = Math.sqrt(+x); // Math.sqrt underflow/overflow?\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n\n    if (s == 0 || s == 1 / 0) {\n      n = digitsToString(d);\n      if ((n.length + e) % 2 == 0) n += '0';\n      s = Math.sqrt(n);\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n\n      if (s == 1 / 0) {\n        n = '5e' + e;\n      } else {\n        n = s.toExponential();\n        n = n.slice(0, n.indexOf('e') + 1) + e;\n      }\n\n      r = new Ctor(n);\n    } else {\n      r = new Ctor(s.toString());\n    }\n\n    sd = (e = Ctor.precision) + 3; // Newton-Raphson iteration.\n\n    for (;;) {\n      t = r;\n      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5); // TODO? Replace with for-loop and checkRoundingDigits.\n\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n        n = n.slice(sd - 3, sd + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\n\n        if (n == '9999' || !rep && n == '4999') {\n          // On the first iteration only, check to see if rounding up gives the exact result as the\n          // nines may infinitely repeat.\n          if (!rep) {\n            finalise(t, e + 1, 0);\n\n            if (t.times(t).eq(x)) {\n              r = t;\n              break;\n            }\n          }\n\n          sd += 4;\n          rep = 1;\n        } else {\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n          // If not, then there are further digits and m will be truthy.\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\n            // Truncate to the first rounding digit.\n            finalise(r, e + 1, 1);\n            m = !r.times(r).eq(x);\n          }\n\n          break;\n        }\n      }\n    }\n\n    external = true;\n    return finalise(r, e, Ctor.rounding, m);\n  };\n  /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */\n\n\n  P.tangent = P.tan = function () {\n    var pr,\n        rm,\n        x = this,\n        Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 10;\n    Ctor.rounding = 1;\n    x = x.sin();\n    x.s = 1;\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n  };\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */\n\n\n  P.times = P.mul = function (y) {\n    var carry,\n        e,\n        i,\n        k,\n        r,\n        rL,\n        t,\n        xdL,\n        ydL,\n        x = this,\n        Ctor = x.constructor,\n        xd = x.d,\n        yd = (y = new Ctor(y)).d;\n    y.s *= x.s; // If either is NaN, Infinity or 0...\n\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd // Return NaN if either is NaN.\n      // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.\n      ? NaN // Return Infinity if either is Infinity.\n      // Return 0 if either is 0.\n      : !xd || !yd ? y.s / 0 : y.s * 0);\n    }\n\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n    xdL = xd.length;\n    ydL = yd.length; // Ensure xd points to the longer array.\n\n    if (xdL < ydL) {\n      r = xd;\n      xd = yd;\n      yd = r;\n      rL = xdL;\n      xdL = ydL;\n      ydL = rL;\n    } // Initialise the result array with zeros.\n\n\n    r = [];\n    rL = xdL + ydL;\n\n    for (i = rL; i--;) {\n      r.push(0);\n    } // Multiply!\n\n\n    for (i = ydL; --i >= 0;) {\n      carry = 0;\n\n      for (k = xdL + i; k > i;) {\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\n        r[k--] = t % BASE | 0;\n        carry = t / BASE | 0;\n      }\n\n      r[k] = (r[k] + carry) % BASE | 0;\n    } // Remove trailing zeros.\n\n\n    for (; !r[--rL];) {\n      r.pop();\n    }\n\n    if (carry) ++e;else r.shift();\n    y.d = r;\n    y.e = getBase10Exponent(r, e);\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n  };\n  /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\n\n\n  P.toBinary = function (sd, rm) {\n    return toStringBinary(this, 2, sd, rm);\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\n\n\n  P.toDecimalPlaces = P.toDP = function (dp, rm) {\n    var x = this,\n        Ctor = x.constructor;\n    x = new Ctor(x);\n    if (dp === void 0) return x;\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n    return finalise(x, dp + x.e + 1, rm);\n  };\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\n\n\n  P.toExponential = function (dp, rm) {\n    var str,\n        x = this,\n        Ctor = x.constructor;\n\n    if (dp === void 0) {\n      str = finiteToString(x, true);\n    } else {\n      checkInt32(dp, 0, MAX_DIGITS);\n      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n      x = finalise(new Ctor(x), dp + 1, rm);\n      str = finiteToString(x, true, dp + 1);\n    }\n\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\n  };\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\n\n\n  P.toFixed = function (dp, rm) {\n    var str,\n        y,\n        x = this,\n        Ctor = x.constructor;\n\n    if (dp === void 0) {\n      str = finiteToString(x);\n    } else {\n      checkInt32(dp, 0, MAX_DIGITS);\n      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n      y = finalise(new Ctor(x), dp + x.e + 1, rm);\n      str = finiteToString(y, false, dp + y.e + 1);\n    } // To determine whether to add the minus sign look at the value before it was rounded,\n    // i.e. look at `x` rather than `y`.\n\n\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\n  };\n  /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */\n\n\n  P.toFraction = function (maxD) {\n    var d,\n        d0,\n        d1,\n        d2,\n        e,\n        k,\n        n,\n        n0,\n        n1,\n        pr,\n        q,\n        r,\n        x = this,\n        xd = x.d,\n        Ctor = x.constructor;\n    if (!xd) return new Ctor(x);\n    n1 = d0 = new Ctor(1);\n    d1 = n0 = new Ctor(0);\n    d = new Ctor(d1);\n    e = d.e = getPrecision(xd) - x.e - 1;\n    k = e % LOG_BASE;\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n\n    if (maxD == null) {\n      // d is 10**e, the minimum max-denominator needed.\n      maxD = e > 0 ? d : n1;\n    } else {\n      n = new Ctor(maxD);\n      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\n      maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n    }\n\n    external = false;\n    n = new Ctor(digitsToString(xd));\n    pr = Ctor.precision;\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\n\n    for (;;) {\n      q = divide(n, d, 0, 1, 1);\n      d2 = d0.plus(q.times(d1));\n      if (d2.cmp(maxD) == 1) break;\n      d0 = d1;\n      d1 = d2;\n      d2 = n1;\n      n1 = n0.plus(q.times(d2));\n      n0 = d2;\n      d2 = d;\n      d = n.minus(q.times(d2));\n      n = d2;\n    }\n\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n    n0 = n0.plus(d2.times(n1));\n    d0 = d0.plus(d2.times(d1));\n    n0.s = n1.s = x.s; // Determine which fraction is closer to x, n0/d0 or n1/d1?\n\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\n    Ctor.precision = pr;\n    external = true;\n    return r;\n  };\n  /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\n\n\n  P.toHexadecimal = P.toHex = function (sd, rm) {\n    return toStringBinary(this, 16, sd, rm);\n  };\n  /*\r\n   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */\n\n\n  P.toNearest = function (y, rm) {\n    var x = this,\n        Ctor = x.constructor;\n    x = new Ctor(x);\n\n    if (y == null) {\n      // If x is not finite, return x.\n      if (!x.d) return x;\n      y = new Ctor(1);\n      rm = Ctor.rounding;\n    } else {\n      y = new Ctor(y);\n\n      if (rm === void 0) {\n        rm = Ctor.rounding;\n      } else {\n        checkInt32(rm, 0, 8);\n      } // If x is not finite, return x if y is not NaN, else NaN.\n\n\n      if (!x.d) return y.s ? x : y; // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\n\n      if (!y.d) {\n        if (y.s) y.s = x.s;\n        return y;\n      }\n    } // If y is not zero, calculate the nearest multiple of y to x.\n\n\n    if (y.d[0]) {\n      external = false;\n      x = divide(x, y, 0, rm, 1).times(y);\n      external = true;\n      finalise(x); // If y is zero, return zero with the sign of x.\n    } else {\n      y.s = x.s;\n      x = y;\n    }\n\n    return x;\n  };\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */\n\n\n  P.toNumber = function () {\n    return +this;\n  };\n  /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\n\n\n  P.toOctal = function (sd, rm) {\n    return toStringBinary(this, 8, sd, rm);\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, 0)                            = 1\r\n     *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\n\n\n  P.toPower = P.pow = function (y) {\n    var e,\n        k,\n        pr,\n        r,\n        rm,\n        s,\n        x = this,\n        Ctor = x.constructor,\n        yn = +(y = new Ctor(y)); // Either Infinity, NaN or 0?\n\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\n    x = new Ctor(x);\n    if (x.eq(1)) return x;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    if (y.eq(1)) return finalise(x, pr, rm); // y exponent\n\n    e = mathfloor(y.e / LOG_BASE); // If y is a small integer use the 'exponentiation by squaring' algorithm.\n\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n      r = intPow(Ctor, x, k, pr);\n      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n    }\n\n    s = x.s; // if x is negative\n\n    if (s < 0) {\n      // if y is not an integer\n      if (e < y.d.length - 1) return new Ctor(NaN); // Result is positive if x is negative and the last digit of integer y is even.\n\n      if ((y.d[e] & 1) == 0) s = 1; // if x.eq(-1)\n\n      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n        x.s = s;\n        return x;\n      }\n    } // Estimate result exponent.\n    // x^y = 10^e,  where e = y * log10(x)\n    // log10(x) = log10(x_significand) + x_exponent\n    // log10(x_significand) = ln(x_significand) / ln(10)\n\n\n    k = mathpow(+x, yn);\n    e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + '').e; // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\n    // Overflow/underflow?\n\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\n    external = false;\n    Ctor.rounding = x.s = 1; // Estimate the extra guard digits needed to ensure five correct rounding digits from\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\n    // new Decimal(2.32456).pow('2087987436534566.46411')\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\n\n    k = Math.min(12, (e + '').length); // r = x^y = exp(y*ln(x))\n\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr); // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\n\n    if (r.d) {\n      // Truncate to the required precision plus five rounding digits.\n      r = finalise(r, pr + 5, 1); // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\n      // the result.\n\n      if (checkRoundingDigits(r.d, pr, rm)) {\n        e = pr + 10; // Truncate to the increased precision plus five rounding digits.\n\n        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1); // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\n\n        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n          r = finalise(r, pr + 1, 0);\n        }\n      }\n    }\n\n    r.s = s;\n    external = true;\n    Ctor.rounding = rm;\n    return finalise(r, pr, rm);\n  };\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\n\n\n  P.toPrecision = function (sd, rm) {\n    var str,\n        x = this,\n        Ctor = x.constructor;\n\n    if (sd === void 0) {\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    } else {\n      checkInt32(sd, 1, MAX_DIGITS);\n      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n      x = finalise(new Ctor(x), sd, rm);\n      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n    }\n\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */\n\n\n  P.toSignificantDigits = P.toSD = function (sd, rm) {\n    var x = this,\n        Ctor = x.constructor;\n\n    if (sd === void 0) {\n      sd = Ctor.precision;\n      rm = Ctor.rounding;\n    } else {\n      checkInt32(sd, 1, MAX_DIGITS);\n      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n    }\n\n    return finalise(new Ctor(x), sd, rm);\n  };\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\n\n\n  P.toString = function () {\n    var x = this,\n        Ctor = x.constructor,\n        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */\n\n\n  P.truncated = P.trunc = function () {\n    return finalise(new this.constructor(this), this.e + 1, 1);\n  };\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */\n\n\n  P.valueOf = P.toJSON = function () {\n    var x = this,\n        Ctor = x.constructor,\n        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    return x.isNeg() ? '-' + str : str;\n  };\n  /*\r\n  // Add aliases to match BigDecimal method names.\r\n  // P.add = P.plus;\r\n  P.subtract = P.minus;\r\n  P.multiply = P.times;\r\n  P.divide = P.div;\r\n  P.remainder = P.mod;\r\n  P.compareTo = P.cmp;\r\n  P.negate = P.neg;\r\n   */\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\n\n  /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */\n\n\n  function digitsToString(d) {\n    var i,\n        k,\n        ws,\n        indexOfLastWord = d.length - 1,\n        str = '',\n        w = d[0];\n\n    if (indexOfLastWord > 0) {\n      str += w;\n\n      for (i = 1; i < indexOfLastWord; i++) {\n        ws = d[i] + '';\n        k = LOG_BASE - ws.length;\n        if (k) str += getZeroString(k);\n        str += ws;\n      }\n\n      w = d[i];\n      ws = w + '';\n      k = LOG_BASE - ws.length;\n      if (k) str += getZeroString(k);\n    } else if (w === 0) {\n      return '0';\n    } // Remove trailing zeros of last w.\n\n\n    for (; w % 10 === 0;) {\n      w /= 10;\n    }\n\n    return str + w;\n  }\n\n  function checkInt32(i, min, max) {\n    if (i !== ~~i || i < min || i > max) {\n      throw Error(invalidArgument + i);\n    }\n  }\n  /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */\n\n\n  function checkRoundingDigits(d, i, rm, repeating) {\n    var di, k, r, rd; // Get the length of the first word of the array d.\n\n    for (k = d[0]; k >= 10; k /= 10) {\n      --i;\n    } // Is the rounding digit in the first word of d?\n\n\n    if (--i < 0) {\n      i += LOG_BASE;\n      di = 0;\n    } else {\n      di = Math.ceil((i + 1) / LOG_BASE);\n      i %= LOG_BASE;\n    } // i is the index (0 - 6) of the rounding digit.\n    // E.g. if within the word 3487563 the first rounding digit is 5,\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\n\n\n    k = mathpow(10, LOG_BASE - i);\n    rd = d[di] % k | 0;\n\n    if (repeating == null) {\n      if (i < 3) {\n        if (i == 0) rd = rd / 100 | 0;else if (i == 1) rd = rd / 10 | 0;\n        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\n      } else {\n        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n      }\n    } else {\n      if (i < 4) {\n        if (i == 0) rd = rd / 1000 | 0;else if (i == 1) rd = rd / 100 | 0;else if (i == 2) rd = rd / 10 | 0;\n        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n      } else {\n        r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\n      }\n    }\n\n    return r;\n  } // Convert string of `baseIn` to an array of numbers of `baseOut`.\n  // Eg. convertBase('255', 10, 16) returns [15, 15].\n  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\n\n\n  function convertBase(str, baseIn, baseOut) {\n    var j,\n        arr = [0],\n        arrL,\n        i = 0,\n        strL = str.length;\n\n    for (; i < strL;) {\n      for (arrL = arr.length; arrL--;) {\n        arr[arrL] *= baseIn;\n      }\n\n      arr[0] += NUMERALS.indexOf(str.charAt(i++));\n\n      for (j = 0; j < arr.length; j++) {\n        if (arr[j] > baseOut - 1) {\n          if (arr[j + 1] === void 0) arr[j + 1] = 0;\n          arr[j + 1] += arr[j] / baseOut | 0;\n          arr[j] %= baseOut;\n        }\n      }\n    }\n\n    return arr.reverse();\n  }\n  /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\n\n\n  function cosine(Ctor, x) {\n    var k,\n        y,\n        len = x.d.length; // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\n    // Estimate the optimum number of times to use the argument reduction.\n\n    if (len < 32) {\n      k = Math.ceil(len / 3);\n      y = (1 / tinyPow(4, k)).toString();\n    } else {\n      k = 16;\n      y = '2.3283064365386962890625e-10';\n    }\n\n    Ctor.precision += k;\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1)); // Reverse argument reduction\n\n    for (var i = k; i--;) {\n      var cos2x = x.times(x);\n      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n    }\n\n    Ctor.precision -= k;\n    return x;\n  }\n  /*\r\n   * Perform division in the specified base.\r\n   */\n\n\n  var divide = function () {\n    // Assumes non-zero x and k, and hence non-zero result.\n    function multiplyInteger(x, k, base) {\n      var temp,\n          carry = 0,\n          i = x.length;\n\n      for (x = x.slice(); i--;) {\n        temp = x[i] * k + carry;\n        x[i] = temp % base | 0;\n        carry = temp / base | 0;\n      }\n\n      if (carry) x.unshift(carry);\n      return x;\n    }\n\n    function compare(a, b, aL, bL) {\n      var i, r;\n\n      if (aL != bL) {\n        r = aL > bL ? 1 : -1;\n      } else {\n        for (i = r = 0; i < aL; i++) {\n          if (a[i] != b[i]) {\n            r = a[i] > b[i] ? 1 : -1;\n            break;\n          }\n        }\n      }\n\n      return r;\n    }\n\n    function subtract(a, b, aL, base) {\n      var i = 0; // Subtract b from a.\n\n      for (; aL--;) {\n        a[aL] -= i;\n        i = a[aL] < b[aL] ? 1 : 0;\n        a[aL] = i * base + a[aL] - b[aL];\n      } // Remove leading zeros.\n\n\n      for (; !a[0] && a.length > 1;) {\n        a.shift();\n      }\n    }\n\n    return function (x, y, pr, rm, dp, base) {\n      var cmp,\n          e,\n          i,\n          k,\n          logBase,\n          more,\n          prod,\n          prodL,\n          q,\n          qd,\n          rem,\n          remL,\n          rem0,\n          sd,\n          t,\n          xi,\n          xL,\n          yd0,\n          yL,\n          yz,\n          Ctor = x.constructor,\n          sign = x.s == y.s ? 1 : -1,\n          xd = x.d,\n          yd = y.d; // Either NaN, Infinity or 0?\n\n      if (!xd || !xd[0] || !yd || !yd[0]) {\n        return new Ctor( // Return NaN if either NaN, or both Infinity or 0.\n        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\n        xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\n      }\n\n      if (base) {\n        logBase = 1;\n        e = x.e - y.e;\n      } else {\n        base = BASE;\n        logBase = LOG_BASE;\n        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n      }\n\n      yL = yd.length;\n      xL = xd.length;\n      q = new Ctor(sign);\n      qd = q.d = []; // Result exponent may be one less than e.\n      // The digit array of a Decimal from toStringBinary may have trailing zeros.\n\n      for (i = 0; yd[i] == (xd[i] || 0); i++) {\n        ;\n      }\n\n      if (yd[i] > (xd[i] || 0)) e--;\n\n      if (pr == null) {\n        sd = pr = Ctor.precision;\n        rm = Ctor.rounding;\n      } else if (dp) {\n        sd = pr + (x.e - y.e) + 1;\n      } else {\n        sd = pr;\n      }\n\n      if (sd < 0) {\n        qd.push(1);\n        more = true;\n      } else {\n        // Convert precision in number of base 10 digits to base 1e7 digits.\n        sd = sd / logBase + 2 | 0;\n        i = 0; // divisor < 1e7\n\n        if (yL == 1) {\n          k = 0;\n          yd = yd[0];\n          sd++; // k is the carry.\n\n          for (; (i < xL || k) && sd--; i++) {\n            t = k * base + (xd[i] || 0);\n            qd[i] = t / yd | 0;\n            k = t % yd | 0;\n          }\n\n          more = k || i < xL; // divisor >= 1e7\n        } else {\n          // Normalise xd and yd so highest order digit of yd is >= base/2\n          k = base / (yd[0] + 1) | 0;\n\n          if (k > 1) {\n            yd = multiplyInteger(yd, k, base);\n            xd = multiplyInteger(xd, k, base);\n            yL = yd.length;\n            xL = xd.length;\n          }\n\n          xi = yL;\n          rem = xd.slice(0, yL);\n          remL = rem.length; // Add zeros to make remainder as long as divisor.\n\n          for (; remL < yL;) {\n            rem[remL++] = 0;\n          }\n\n          yz = yd.slice();\n          yz.unshift(0);\n          yd0 = yd[0];\n          if (yd[1] >= base / 2) ++yd0;\n\n          do {\n            k = 0; // Compare divisor and remainder.\n\n            cmp = compare(yd, rem, yL, remL); // If divisor < remainder.\n\n            if (cmp < 0) {\n              // Calculate trial digit, k.\n              rem0 = rem[0];\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0); // k will be how many times the divisor goes into the current remainder.\n\n              k = rem0 / yd0 | 0; //  Algorithm:\n              //  1. product = divisor * trial digit (k)\n              //  2. if product > remainder: product -= divisor, k--\n              //  3. remainder -= product\n              //  4. if product was < remainder at 2:\n              //    5. compare new remainder and divisor\n              //    6. If remainder > divisor: remainder -= divisor, k++\n\n              if (k > 1) {\n                if (k >= base) k = base - 1; // product = divisor * trial digit.\n\n                prod = multiplyInteger(yd, k, base);\n                prodL = prod.length;\n                remL = rem.length; // Compare product and remainder.\n\n                cmp = compare(prod, rem, prodL, remL); // product > remainder.\n\n                if (cmp == 1) {\n                  k--; // Subtract divisor from product.\n\n                  subtract(prod, yL < prodL ? yz : yd, prodL, base);\n                }\n              } else {\n                // cmp is -1.\n                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\n                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\n                if (k == 0) cmp = k = 1;\n                prod = yd.slice();\n              }\n\n              prodL = prod.length;\n              if (prodL < remL) prod.unshift(0); // Subtract product from remainder.\n\n              subtract(rem, prod, remL, base); // If product was < previous remainder.\n\n              if (cmp == -1) {\n                remL = rem.length; // Compare divisor and new remainder.\n\n                cmp = compare(yd, rem, yL, remL); // If divisor < new remainder, subtract divisor from remainder.\n\n                if (cmp < 1) {\n                  k++; // Subtract divisor from remainder.\n\n                  subtract(rem, yL < remL ? yz : yd, remL, base);\n                }\n              }\n\n              remL = rem.length;\n            } else if (cmp === 0) {\n              k++;\n              rem = [0];\n            } // if cmp === 1, k will be 0\n            // Add the next digit, k, to the result array.\n\n\n            qd[i++] = k; // Update the remainder.\n\n            if (cmp && rem[0]) {\n              rem[remL++] = xd[xi] || 0;\n            } else {\n              rem = [xd[xi]];\n              remL = 1;\n            }\n          } while ((xi++ < xL || rem[0] !== void 0) && sd--);\n\n          more = rem[0] !== void 0;\n        } // Leading zero?\n\n\n        if (!qd[0]) qd.shift();\n      } // logBase is 1 when divide is being used for base conversion.\n\n\n      if (logBase == 1) {\n        q.e = e;\n        inexact = more;\n      } else {\n        // To calculate q.e, first get the number of digits of qd[0].\n        for (i = 1, k = qd[0]; k >= 10; k /= 10) {\n          i++;\n        }\n\n        q.e = i + e * logBase - 1;\n        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n      }\n\n      return q;\n    };\n  }();\n  /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */\n\n\n  function finalise(x, sd, rm, isTruncated) {\n    var digits,\n        i,\n        j,\n        k,\n        rd,\n        roundUp,\n        w,\n        xd,\n        xdi,\n        Ctor = x.constructor; // Don't round if sd is null or undefined.\n\n    out: if (sd != null) {\n      xd = x.d; // Infinity/NaN.\n\n      if (!xd) return x; // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\n      // w: the word of xd containing rd, a base 1e7 number.\n      // xdi: the index of w within xd.\n      // digits: the number of digits of w.\n      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\n      // they had leading zeros)\n      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\n      // Get the length of the first word of the digits array xd.\n\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10) {\n        digits++;\n      }\n\n      i = sd - digits; // Is the rounding digit in the first word of xd?\n\n      if (i < 0) {\n        i += LOG_BASE;\n        j = sd;\n        w = xd[xdi = 0]; // Get the rounding digit at index j of w.\n\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n      } else {\n        xdi = Math.ceil((i + 1) / LOG_BASE);\n        k = xd.length;\n\n        if (xdi >= k) {\n          if (isTruncated) {\n            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\n            for (; k++ <= xdi;) {\n              xd.push(0);\n            }\n\n            w = rd = 0;\n            digits = 1;\n            i %= LOG_BASE;\n            j = i - LOG_BASE + 1;\n          } else {\n            break out;\n          }\n        } else {\n          w = k = xd[xdi]; // Get the number of digits of w.\n\n          for (digits = 1; k >= 10; k /= 10) {\n            digits++;\n          } // Get the index of rd within w.\n\n\n          i %= LOG_BASE; // Get the index of rd within w, adjusted for leading zeros.\n          // The number of leading zeros of w is given by LOG_BASE - digits.\n\n          j = i - LOG_BASE + digits; // Get the rounding digit at index j of w.\n\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n        }\n      } // Are there any non-zero digits after the rounding digit?\n\n\n      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1)); // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\n      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\n      // will give 714.\n\n      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.\n      (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n\n      if (sd < 1 || !xd[0]) {\n        xd.length = 0;\n\n        if (roundUp) {\n          // Convert sd to decimal places.\n          sd -= x.e + 1; // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n          x.e = -sd || 0;\n        } else {\n          // Zero.\n          xd[0] = x.e = 0;\n        }\n\n        return x;\n      } // Remove excess digits.\n\n\n      if (i == 0) {\n        xd.length = xdi;\n        k = 1;\n        xdi--;\n      } else {\n        xd.length = xdi + 1;\n        k = mathpow(10, LOG_BASE - i); // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n        // j > 0 means i > number of leading zeros of w.\n\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n      }\n\n      if (roundUp) {\n        for (;;) {\n          // Is the digit to be rounded up in the first word of xd?\n          if (xdi == 0) {\n            // i will be the length of xd[0] before k is added.\n            for (i = 1, j = xd[0]; j >= 10; j /= 10) {\n              i++;\n            }\n\n            j = xd[0] += k;\n\n            for (k = 1; j >= 10; j /= 10) {\n              k++;\n            } // if i != k the length has increased.\n\n\n            if (i != k) {\n              x.e++;\n              if (xd[0] == BASE) xd[0] = 1;\n            }\n\n            break;\n          } else {\n            xd[xdi] += k;\n            if (xd[xdi] != BASE) break;\n            xd[xdi--] = 0;\n            k = 1;\n          }\n        }\n      } // Remove trailing zeros.\n\n\n      for (i = xd.length; xd[--i] === 0;) {\n        xd.pop();\n      }\n    }\n\n    if (external) {\n      // Overflow?\n      if (x.e > Ctor.maxE) {\n        // Infinity.\n        x.d = null;\n        x.e = NaN; // Underflow?\n      } else if (x.e < Ctor.minE) {\n        // Zero.\n        x.e = 0;\n        x.d = [0]; // Ctor.underflow = true;\n      } // else Ctor.underflow = false;\n\n    }\n\n    return x;\n  }\n\n  function finiteToString(x, isExp, sd) {\n    if (!x.isFinite()) return nonFiniteToString(x);\n    var k,\n        e = x.e,\n        str = digitsToString(x.d),\n        len = str.length;\n\n    if (isExp) {\n      if (sd && (k = sd - len) > 0) {\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\n      } else if (len > 1) {\n        str = str.charAt(0) + '.' + str.slice(1);\n      }\n\n      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\n    } else if (e < 0) {\n      str = '0.' + getZeroString(-e - 1) + str;\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\n    } else if (e >= len) {\n      str += getZeroString(e + 1 - len);\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\n    } else {\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\n\n      if (sd && (k = sd - len) > 0) {\n        if (e + 1 === len) str += '.';\n        str += getZeroString(k);\n      }\n    }\n\n    return str;\n  } // Calculate the base 10 exponent from the base 1e7 exponent.\n\n\n  function getBase10Exponent(digits, e) {\n    var w = digits[0]; // Add the number of digits of the first word of the digits array.\n\n    for (e *= LOG_BASE; w >= 10; w /= 10) {\n      e++;\n    }\n\n    return e;\n  }\n\n  function getLn10(Ctor, sd, pr) {\n    if (sd > LN10_PRECISION) {\n      // Reset global state in case the exception is caught.\n      external = true;\n      if (pr) Ctor.precision = pr;\n      throw Error(precisionLimitExceeded);\n    }\n\n    return finalise(new Ctor(LN10), sd, 1, true);\n  }\n\n  function getPi(Ctor, sd, rm) {\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\n    return finalise(new Ctor(PI), sd, rm, true);\n  }\n\n  function getPrecision(digits) {\n    var w = digits.length - 1,\n        len = w * LOG_BASE + 1;\n    w = digits[w]; // If non-zero...\n\n    if (w) {\n      // Subtract the number of trailing zeros of the last word.\n      for (; w % 10 == 0; w /= 10) {\n        len--;\n      } // Add the number of digits of the first word.\n\n\n      for (w = digits[0]; w >= 10; w /= 10) {\n        len++;\n      }\n    }\n\n    return len;\n  }\n\n  function getZeroString(k) {\n    var zs = '';\n\n    for (; k--;) {\n      zs += '0';\n    }\n\n    return zs;\n  }\n  /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */\n\n\n  function intPow(Ctor, x, n, pr) {\n    var isTruncated,\n        r = new Ctor(1),\n        // Max n of 9007199254740991 takes 53 loop iterations.\n    // Maximum digits array length; leaves [28, 34] guard digits.\n    k = Math.ceil(pr / LOG_BASE + 4);\n    external = false;\n\n    for (;;) {\n      if (n % 2) {\n        r = r.times(x);\n        if (truncate(r.d, k)) isTruncated = true;\n      }\n\n      n = mathfloor(n / 2);\n\n      if (n === 0) {\n        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\n        n = r.d.length - 1;\n        if (isTruncated && r.d[n] === 0) ++r.d[n];\n        break;\n      }\n\n      x = x.times(x);\n      truncate(x.d, k);\n    }\n\n    external = true;\n    return r;\n  }\n\n  function isOdd(n) {\n    return n.d[n.d.length - 1] & 1;\n  }\n  /*\r\n   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n   */\n\n\n  function maxOrMin(Ctor, args, ltgt) {\n    var y,\n        x = new Ctor(args[0]),\n        i = 0;\n\n    for (; ++i < args.length;) {\n      y = new Ctor(args[i]);\n\n      if (!y.s) {\n        x = y;\n        break;\n      } else if (x[ltgt](y)) {\n        x = y;\n      }\n    }\n\n    return x;\n  }\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */\n\n\n  function naturalExponential(x, sd) {\n    var denominator,\n        guard,\n        j,\n        pow,\n        sum,\n        t,\n        wpr,\n        rep = 0,\n        i = 0,\n        k = 0,\n        Ctor = x.constructor,\n        rm = Ctor.rounding,\n        pr = Ctor.precision; // 0/NaN/Infinity?\n\n    if (!x.d || !x.d[0] || x.e > 17) {\n      return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n    }\n\n    if (sd == null) {\n      external = false;\n      wpr = pr;\n    } else {\n      wpr = sd;\n    }\n\n    t = new Ctor(0.03125); // while abs(x) >= 0.1\n\n    while (x.e > -2) {\n      // x = x / 2^5\n      x = x.times(t);\n      k += 5;\n    } // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\n    // necessary to ensure the first 4 rounding digits are correct.\n\n\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n    wpr += guard;\n    denominator = pow = sum = new Ctor(1);\n    Ctor.precision = wpr;\n\n    for (;;) {\n      pow = finalise(pow.times(x), wpr, 1);\n      denominator = denominator.times(++i);\n      t = sum.plus(divide(pow, denominator, wpr, 1));\n\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n        j = k;\n\n        while (j--) {\n          sum = finalise(sum.times(sum), wpr, 1);\n        } // Check to see if the first 4 rounding digits are [49]999.\n        // If so, repeat the summation with a higher precision, otherwise\n        // e.g. with precision: 18, rounding: 1\n        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\n        // `wpr - guard` is the index of first rounding digit.\n\n\n        if (sd == null) {\n          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n            Ctor.precision = wpr += 10;\n            denominator = pow = t = new Ctor(1);\n            i = 0;\n            rep++;\n          } else {\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\n          }\n        } else {\n          Ctor.precision = pr;\n          return sum;\n        }\n      }\n\n      sum = t;\n    }\n  }\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */\n\n\n  function naturalLogarithm(y, sd) {\n    var c,\n        c0,\n        denominator,\n        e,\n        numerator,\n        rep,\n        sum,\n        t,\n        wpr,\n        x1,\n        x2,\n        n = 1,\n        guard = 10,\n        x = y,\n        xd = x.d,\n        Ctor = x.constructor,\n        rm = Ctor.rounding,\n        pr = Ctor.precision; // Is x negative or Infinity, NaN, 0 or 1?\n\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n    }\n\n    if (sd == null) {\n      external = false;\n      wpr = pr;\n    } else {\n      wpr = sd;\n    }\n\n    Ctor.precision = wpr += guard;\n    c = digitsToString(xd);\n    c0 = c.charAt(0);\n\n    if (Math.abs(e = x.e) < 1.5e15) {\n      // Argument reduction.\n      // The series converges faster the closer the argument is to 1, so using\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\n      // later be divided by this number, then separate out the power of 10 using\n      // ln(a*10^b) = ln(a) + b*ln(10).\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\n      // max n is 6 (gives 0.7 - 1.3)\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\n        x = x.times(y);\n        c = digitsToString(x.d);\n        c0 = c.charAt(0);\n        n++;\n      }\n\n      e = x.e;\n\n      if (c0 > 1) {\n        x = new Ctor('0.' + c);\n        e++;\n      } else {\n        x = new Ctor(c0 + '.' + c.slice(1));\n      }\n    } else {\n      // The argument reduction method above may result in overflow if the argument y is a massive\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\n      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\n      Ctor.precision = pr;\n      return sd == null ? finalise(x, pr, rm, external = true) : x;\n    } // x1 is x reduced to a value near 1.\n\n\n    x1 = x; // Taylor series.\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\n\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n    x2 = finalise(x.times(x), wpr, 1);\n    denominator = 3;\n\n    for (;;) {\n      numerator = finalise(numerator.times(x2), wpr, 1);\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n        sum = sum.times(2); // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\n        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\n\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\n        sum = divide(sum, new Ctor(n), wpr, 1); // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\n        // been repeated previously) and the first 4 rounding digits 9999?\n        // If so, restart the summation with a higher precision, otherwise\n        // e.g. with precision: 12, rounding: 1\n        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\n        // `wpr - guard` is the index of first rounding digit.\n\n        if (sd == null) {\n          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n            Ctor.precision = wpr += guard;\n            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n            x2 = finalise(x.times(x), wpr, 1);\n            denominator = rep = 1;\n          } else {\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\n          }\n        } else {\n          Ctor.precision = pr;\n          return sum;\n        }\n      }\n\n      sum = t;\n      denominator += 2;\n    }\n  } // Infinity, NaN.\n\n\n  function nonFiniteToString(x) {\n    // Unsigned.\n    return String(x.s * x.s / 0);\n  }\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\n\n\n  function parseDecimal(x, str) {\n    var e, i, len; // Decimal point?\n\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', ''); // Exponential form?\n\n    if ((i = str.search(/e/i)) > 0) {\n      // Determine exponent.\n      if (e < 0) e = i;\n      e += +str.slice(i + 1);\n      str = str.substring(0, i);\n    } else if (e < 0) {\n      // Integer.\n      e = str.length;\n    } // Determine leading zeros.\n\n\n    for (i = 0; str.charCodeAt(i) === 48; i++) {\n      ;\n    } // Determine trailing zeros.\n\n\n    for (len = str.length; str.charCodeAt(len - 1) === 48; --len) {\n      ;\n    }\n\n    str = str.slice(i, len);\n\n    if (str) {\n      len -= i;\n      x.e = e = e - i - 1;\n      x.d = []; // Transform base\n      // e is the base 10 exponent.\n      // i is where to slice str to get the first word of the digits array.\n\n      i = (e + 1) % LOG_BASE;\n      if (e < 0) i += LOG_BASE;\n\n      if (i < len) {\n        if (i) x.d.push(+str.slice(0, i));\n\n        for (len -= LOG_BASE; i < len;) {\n          x.d.push(+str.slice(i, i += LOG_BASE));\n        }\n\n        str = str.slice(i);\n        i = LOG_BASE - str.length;\n      } else {\n        i -= len;\n      }\n\n      for (; i--;) {\n        str += '0';\n      }\n\n      x.d.push(+str);\n\n      if (external) {\n        // Overflow?\n        if (x.e > x.constructor.maxE) {\n          // Infinity.\n          x.d = null;\n          x.e = NaN; // Underflow?\n        } else if (x.e < x.constructor.minE) {\n          // Zero.\n          x.e = 0;\n          x.d = [0]; // x.constructor.underflow = true;\n        } // else x.constructor.underflow = false;\n\n      }\n    } else {\n      // Zero.\n      x.e = 0;\n      x.d = [0];\n    }\n\n    return x;\n  }\n  /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */\n\n\n  function parseOther(x, str) {\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n\n    if (str === 'Infinity' || str === 'NaN') {\n      if (!+str) x.s = NaN;\n      x.e = NaN;\n      x.d = null;\n      return x;\n    }\n\n    if (isHex.test(str)) {\n      base = 16;\n      str = str.toLowerCase();\n    } else if (isBinary.test(str)) {\n      base = 2;\n    } else if (isOctal.test(str)) {\n      base = 8;\n    } else {\n      throw Error(invalidArgument + str);\n    } // Is there a binary exponent part?\n\n\n    i = str.search(/p/i);\n\n    if (i > 0) {\n      p = +str.slice(i + 1);\n      str = str.substring(2, i);\n    } else {\n      str = str.slice(2);\n    } // Convert `str` as an integer then divide the result by `base` raised to a power such that the\n    // fraction part will be restored.\n\n\n    i = str.indexOf('.');\n    isFloat = i >= 0;\n    Ctor = x.constructor;\n\n    if (isFloat) {\n      str = str.replace('.', '');\n      len = str.length;\n      i = len - i; // log[10](16) = 1.2041... , log[10](88) = 1.9444....\n\n      divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n    }\n\n    xd = convertBase(str, base, BASE);\n    xe = xd.length - 1; // Remove trailing zeros.\n\n    for (i = xe; xd[i] === 0; --i) {\n      xd.pop();\n    }\n\n    if (i < 0) return new Ctor(x.s * 0);\n    x.e = getBase10Exponent(xd, xe);\n    x.d = xd;\n    external = false; // At what precision to perform the division to ensure exact conversion?\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\n    // Therefore using 4 * the number of digits of str will always be enough.\n\n    if (isFloat) x = divide(x, divisor, len * 4); // Multiply by the binary exponent part if present.\n\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n    external = true;\n    return x;\n  }\n  /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\n\n\n  function sine(Ctor, x) {\n    var k,\n        len = x.d.length;\n    if (len < 3) return taylorSeries(Ctor, 2, x, x); // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\n    // Estimate the optimum number of times to use the argument reduction.\n\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x); // Reverse argument reduction\n\n    var sin2_x,\n        d5 = new Ctor(5),\n        d16 = new Ctor(16),\n        d20 = new Ctor(20);\n\n    for (; k--;) {\n      sin2_x = x.times(x);\n      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n    }\n\n    return x;\n  } // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\n\n\n  function taylorSeries(Ctor, n, x, y, isHyperbolic) {\n    var j,\n        t,\n        u,\n        x2,\n        i = 1,\n        pr = Ctor.precision,\n        k = Math.ceil(pr / LOG_BASE);\n    external = false;\n    x2 = x.times(x);\n    u = new Ctor(y);\n\n    for (;;) {\n      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n      u = isHyperbolic ? y.plus(t) : y.minus(t);\n      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n      t = u.plus(y);\n\n      if (t.d[k] !== void 0) {\n        for (j = k; t.d[j] === u.d[j] && j--;) {\n          ;\n        }\n\n        if (j == -1) break;\n      }\n\n      j = u;\n      u = y;\n      y = t;\n      t = j;\n      i++;\n    }\n\n    external = true;\n    t.d.length = k + 1;\n    return t;\n  } // Exponent e must be positive and non-zero.\n\n\n  function tinyPow(b, e) {\n    var n = b;\n\n    while (--e) {\n      n *= b;\n    }\n\n    return n;\n  } // Return the absolute value of `x` reduced to less than or equal to half pi.\n\n\n  function toLessThanHalfPi(Ctor, x) {\n    var t,\n        isNeg = x.s < 0,\n        pi = getPi(Ctor, Ctor.precision, 1),\n        halfPi = pi.times(0.5);\n    x = x.abs();\n\n    if (x.lte(halfPi)) {\n      quadrant = isNeg ? 4 : 1;\n      return x;\n    }\n\n    t = x.divToInt(pi);\n\n    if (t.isZero()) {\n      quadrant = isNeg ? 3 : 2;\n    } else {\n      x = x.minus(t.times(pi)); // 0 <= x < pi\n\n      if (x.lte(halfPi)) {\n        quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n        return x;\n      }\n\n      quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n    }\n\n    return x.minus(pi).abs();\n  }\n  /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */\n\n\n  function toStringBinary(x, baseOut, sd, rm) {\n    var base,\n        e,\n        i,\n        k,\n        len,\n        roundUp,\n        str,\n        xd,\n        y,\n        Ctor = x.constructor,\n        isExp = sd !== void 0;\n\n    if (isExp) {\n      checkInt32(sd, 1, MAX_DIGITS);\n      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n    } else {\n      sd = Ctor.precision;\n      rm = Ctor.rounding;\n    }\n\n    if (!x.isFinite()) {\n      str = nonFiniteToString(x);\n    } else {\n      str = finiteToString(x);\n      i = str.indexOf('.'); // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\n      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\n      // minBinaryExponent = floor(decimalExponent * log[2](10))\n      // log[2](10) = 3.321928094887362347870319429489390175864\n\n      if (isExp) {\n        base = 2;\n\n        if (baseOut == 16) {\n          sd = sd * 4 - 3;\n        } else if (baseOut == 8) {\n          sd = sd * 3 - 2;\n        }\n      } else {\n        base = baseOut;\n      } // Convert the number as an integer then divide the result by its base raised to a power such\n      // that the fraction part will be restored.\n      // Non-integer.\n\n\n      if (i >= 0) {\n        str = str.replace('.', '');\n        y = new Ctor(1);\n        y.e = str.length - i;\n        y.d = convertBase(finiteToString(y), 10, base);\n        y.e = y.d.length;\n      }\n\n      xd = convertBase(str, 10, base);\n      e = len = xd.length; // Remove trailing zeros.\n\n      for (; xd[--len] == 0;) {\n        xd.pop();\n      }\n\n      if (!xd[0]) {\n        str = isExp ? '0p+0' : '0';\n      } else {\n        if (i < 0) {\n          e--;\n        } else {\n          x = new Ctor(x);\n          x.d = xd;\n          x.e = e;\n          x = divide(x, y, sd, rm, 0, base);\n          xd = x.d;\n          e = x.e;\n          roundUp = inexact;\n        } // The rounding digit, i.e. the digit after the digit that may be rounded up.\n\n\n        i = xd[sd];\n        k = base / 2;\n        roundUp = roundUp || xd[sd + 1] !== void 0;\n        roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n        xd.length = sd;\n\n        if (roundUp) {\n          // Rounding up may mean the previous digit has to be rounded up and so on.\n          for (; ++xd[--sd] > base - 1;) {\n            xd[sd] = 0;\n\n            if (!sd) {\n              ++e;\n              xd.unshift(1);\n            }\n          }\n        } // Determine trailing zeros.\n\n\n        for (len = xd.length; !xd[len - 1]; --len) {\n          ;\n        } // E.g. [4, 11, 15] becomes 4bf.\n\n\n        for (i = 0, str = ''; i < len; i++) {\n          str += NUMERALS.charAt(xd[i]);\n        } // Add binary exponent suffix?\n\n\n        if (isExp) {\n          if (len > 1) {\n            if (baseOut == 16 || baseOut == 8) {\n              i = baseOut == 16 ? 4 : 3;\n\n              for (--len; len % i; len++) {\n                str += '0';\n              }\n\n              xd = convertBase(str, base, baseOut);\n\n              for (len = xd.length; !xd[len - 1]; --len) {\n                ;\n              } // xd[0] will always be be 1\n\n\n              for (i = 1, str = '1.'; i < len; i++) {\n                str += NUMERALS.charAt(xd[i]);\n              }\n            } else {\n              str = str.charAt(0) + '.' + str.slice(1);\n            }\n          }\n\n          str = str + (e < 0 ? 'p' : 'p+') + e;\n        } else if (e < 0) {\n          for (; ++e;) {\n            str = '0' + str;\n          }\n\n          str = '0.' + str;\n        } else {\n          if (++e > len) for (e -= len; e--;) {\n            str += '0';\n          } else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\n        }\n      }\n\n      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\n    }\n\n    return x.s < 0 ? '-' + str : str;\n  } // Does not strip trailing zeros.\n\n\n  function truncate(arr, len) {\n    if (arr.length > len) {\n      arr.length = len;\n      return true;\n    }\n  } // Decimal methods\n\n  /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  set\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */\n\n  /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function abs(x) {\n    return new this(x).abs();\n  }\n  /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function acos(x) {\n    return new this(x).acos();\n  }\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\n\n\n  function acosh(x) {\n    return new this(x).acosh();\n  }\n  /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function add(x, y) {\n    return new this(x).plus(y);\n  }\n  /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function asin(x) {\n    return new this(x).asin();\n  }\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\n\n\n  function asinh(x) {\n    return new this(x).asinh();\n  }\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function atan(x) {\n    return new this(x).atan();\n  }\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\n\n\n  function atanh(x) {\n    return new this(x).atanh();\n  }\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|Decimal} The y-coordinate.\r\n   * x {number|string|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(0, -0)               = pi\r\n   * atan2(0, +0)               = 0\r\n   * atan2(0, -x)               = pi for x > 0\r\n   * atan2(0, x)                = 0 for x > 0\r\n   * atan2(-y, 0)               = -pi/2 for y > 0\r\n   * atan2(y, 0)                = pi/2 for y > 0\r\n   * atan2(y, -Infinity)        = pi for finite y > 0\r\n   * atan2(y, +Infinity)        = 0 for finite y > 0\r\n   * atan2(Infinity, x)         = pi/2 for finite x\r\n   * atan2(Infinity, -Infinity) = 3*pi/4\r\n   * atan2(Infinity, +Infinity) = pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */\n\n\n  function atan2(y, x) {\n    y = new this(y);\n    x = new this(x);\n    var r,\n        pr = this.precision,\n        rm = this.rounding,\n        wpr = pr + 4; // Either NaN\n\n    if (!y.s || !x.s) {\n      r = new this(NaN); // Both Infinity\n    } else if (!y.d && !x.d) {\n      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n      r.s = y.s; // x is Infinity or y is 0\n    } else if (!x.d || y.isZero()) {\n      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n      r.s = y.s; // y is Infinity or x is 0\n    } else if (!y.d || x.isZero()) {\n      r = getPi(this, wpr, 1).times(0.5);\n      r.s = y.s; // Both non-zero and finite\n    } else if (x.s < 0) {\n      this.precision = wpr;\n      this.rounding = 1;\n      r = this.atan(divide(y, x, wpr, 1));\n      x = getPi(this, wpr, 1);\n      this.precision = pr;\n      this.rounding = rm;\n      r = y.s < 0 ? r.minus(x) : r.plus(x);\n    } else {\n      r = this.atan(divide(y, x, wpr, 1));\n    }\n\n    return r;\n  }\n  /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function cbrt(x) {\n    return new this(x).cbrt();\n  }\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function ceil(x) {\n    return finalise(x = new this(x), x.e + 1, 2);\n  }\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number}\r\n   *   defaults   {true}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\n\n\n  function config(obj) {\n    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\n    var i,\n        p,\n        v,\n        useDefaults = obj.defaults === true,\n        ps = ['precision', 1, MAX_DIGITS, 'rounding', 0, 8, 'toExpNeg', -EXP_LIMIT, 0, 'toExpPos', 0, EXP_LIMIT, 'maxE', 0, EXP_LIMIT, 'minE', -EXP_LIMIT, 0, 'modulo', 0, 9];\n\n    for (i = 0; i < ps.length; i += 3) {\n      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\n\n      if ((v = obj[p]) !== void 0) {\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;else throw Error(invalidArgument + p + ': ' + v);\n      }\n    }\n\n    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];\n\n    if ((v = obj[p]) !== void 0) {\n      if (v === true || v === false || v === 0 || v === 1) {\n        if (v) {\n          if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n            this[p] = true;\n          } else {\n            throw Error(cryptoUnavailable);\n          }\n        } else {\n          this[p] = false;\n        }\n      } else {\n        throw Error(invalidArgument + p + ': ' + v);\n      }\n    }\n\n    return this;\n  }\n  /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\n\n\n  function cos(x) {\n    return new this(x).cos();\n  }\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\n\n\n  function cosh(x) {\n    return new this(x).cosh();\n  }\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\n\n\n  function clone(obj) {\n    var i, p, ps;\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|Decimal} A numeric value.\r\n     *\r\n     */\n\n    function Decimal(v) {\n      var e,\n          i,\n          t,\n          x = this; // Decimal called without new.\n\n      if (!(x instanceof Decimal)) return new Decimal(v); // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\n      // which points to Object.\n\n      x.constructor = Decimal; // Duplicate.\n\n      if (v instanceof Decimal) {\n        x.s = v.s;\n\n        if (external) {\n          if (!v.d || v.e > Decimal.maxE) {\n            // Infinity.\n            x.e = NaN;\n            x.d = null;\n          } else if (v.e < Decimal.minE) {\n            // Zero.\n            x.e = 0;\n            x.d = [0];\n          } else {\n            x.e = v.e;\n            x.d = v.d.slice();\n          }\n        } else {\n          x.e = v.e;\n          x.d = v.d ? v.d.slice() : v.d;\n        }\n\n        return;\n      }\n\n      t = typeof v;\n\n      if (t === 'number') {\n        if (v === 0) {\n          x.s = 1 / v < 0 ? -1 : 1;\n          x.e = 0;\n          x.d = [0];\n          return;\n        }\n\n        if (v < 0) {\n          v = -v;\n          x.s = -1;\n        } else {\n          x.s = 1;\n        } // Fast path for small integers.\n\n\n        if (v === ~~v && v < 1e7) {\n          for (e = 0, i = v; i >= 10; i /= 10) {\n            e++;\n          }\n\n          if (external) {\n            if (e > Decimal.maxE) {\n              x.e = NaN;\n              x.d = null;\n            } else if (e < Decimal.minE) {\n              x.e = 0;\n              x.d = [0];\n            } else {\n              x.e = e;\n              x.d = [v];\n            }\n          } else {\n            x.e = e;\n            x.d = [v];\n          }\n\n          return; // Infinity, NaN.\n        } else if (v * 0 !== 0) {\n          if (!v) x.s = NaN;\n          x.e = NaN;\n          x.d = null;\n          return;\n        }\n\n        return parseDecimal(x, v.toString());\n      } else if (t !== 'string') {\n        throw Error(invalidArgument + v);\n      } // Minus sign?\n\n\n      if ((i = v.charCodeAt(0)) === 45) {\n        v = v.slice(1);\n        x.s = -1;\n      } else {\n        // Plus sign?\n        if (i === 43) v = v.slice(1);\n        x.s = 1;\n      }\n\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n    }\n\n    Decimal.prototype = P;\n    Decimal.ROUND_UP = 0;\n    Decimal.ROUND_DOWN = 1;\n    Decimal.ROUND_CEIL = 2;\n    Decimal.ROUND_FLOOR = 3;\n    Decimal.ROUND_HALF_UP = 4;\n    Decimal.ROUND_HALF_DOWN = 5;\n    Decimal.ROUND_HALF_EVEN = 6;\n    Decimal.ROUND_HALF_CEIL = 7;\n    Decimal.ROUND_HALF_FLOOR = 8;\n    Decimal.EUCLID = 9;\n    Decimal.config = Decimal.set = config;\n    Decimal.clone = clone;\n    Decimal.isDecimal = isDecimalInstance;\n    Decimal.abs = abs;\n    Decimal.acos = acos;\n    Decimal.acosh = acosh; // ES6\n\n    Decimal.add = add;\n    Decimal.asin = asin;\n    Decimal.asinh = asinh; // ES6\n\n    Decimal.atan = atan;\n    Decimal.atanh = atanh; // ES6\n\n    Decimal.atan2 = atan2;\n    Decimal.cbrt = cbrt; // ES6\n\n    Decimal.ceil = ceil;\n    Decimal.cos = cos;\n    Decimal.cosh = cosh; // ES6\n\n    Decimal.div = div;\n    Decimal.exp = exp;\n    Decimal.floor = floor;\n    Decimal.hypot = hypot; // ES6\n\n    Decimal.ln = ln;\n    Decimal.log = log;\n    Decimal.log10 = log10; // ES6\n\n    Decimal.log2 = log2; // ES6\n\n    Decimal.max = max;\n    Decimal.min = min;\n    Decimal.mod = mod;\n    Decimal.mul = mul;\n    Decimal.pow = pow;\n    Decimal.random = random;\n    Decimal.round = round;\n    Decimal.sign = sign; // ES6\n\n    Decimal.sin = sin;\n    Decimal.sinh = sinh; // ES6\n\n    Decimal.sqrt = sqrt;\n    Decimal.sub = sub;\n    Decimal.tan = tan;\n    Decimal.tanh = tanh; // ES6\n\n    Decimal.trunc = trunc; // ES6\n\n    if (obj === void 0) obj = {};\n\n    if (obj) {\n      if (obj.defaults !== true) {\n        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\n\n        for (i = 0; i < ps.length;) {\n          if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\n        }\n      }\n    }\n\n    Decimal.config(obj);\n    return Decimal;\n  }\n  /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function div(x, y) {\n    return new this(x).div(y);\n  }\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */\n\n\n  function exp(x) {\n    return new this(x).exp();\n  }\n  /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function floor(x) {\n    return finalise(x = new this(x), x.e + 1, 3);\n  }\n  /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function hypot() {\n    var i,\n        n,\n        t = new this(0);\n    external = false;\n\n    for (i = 0; i < arguments.length;) {\n      n = new this(arguments[i++]);\n\n      if (!n.d) {\n        if (n.s) {\n          external = true;\n          return new this(1 / 0);\n        }\n\n        t = n;\n      } else if (t.d) {\n        t = t.plus(n.times(n));\n      }\n    }\n\n    external = true;\n    return t.sqrt();\n  }\n  /*\r\n   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n   * otherwise return false.\r\n   *\r\n   */\n\n\n  function isDecimalInstance(obj) {\n    return obj instanceof Decimal || obj && obj.name === '[object Decimal]' || false;\n  }\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function ln(x) {\n    return new this(x).ln();\n  }\n  /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|Decimal} The argument of the logarithm.\r\n   * y {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\n\n\n  function log(x, y) {\n    return new this(x).log(y);\n  }\n  /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function log2(x) {\n    return new this(x).log(2);\n  }\n  /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function log10(x) {\n    return new this(x).log(10);\n  }\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function max() {\n    return maxOrMin(this, arguments, 'lt');\n  }\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function min() {\n    return maxOrMin(this, arguments, 'gt');\n  }\n  /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function mod(x, y) {\n    return new this(x).mod(y);\n  }\n  /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function mul(x, y) {\n    return new this(x).mul(y);\n  }\n  /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The base.\r\n   * y {number|string|Decimal} The exponent.\r\n   *\r\n   */\n\n\n  function pow(x, y) {\n    return new this(x).pow(y);\n  }\n  /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */\n\n\n  function random(sd) {\n    var d,\n        e,\n        k,\n        n,\n        i = 0,\n        r = new this(1),\n        rd = [];\n    if (sd === void 0) sd = this.precision;else checkInt32(sd, 1, MAX_DIGITS);\n    k = Math.ceil(sd / LOG_BASE);\n\n    if (!this.crypto) {\n      for (; i < k;) {\n        rd[i++] = Math.random() * 1e7 | 0;\n      } // Browsers supporting crypto.getRandomValues.\n\n    } else if (crypto.getRandomValues) {\n      d = crypto.getRandomValues(new Uint32Array(k));\n\n      for (; i < k;) {\n        n = d[i]; // 0 <= n < 4294967296\n        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\n\n        if (n >= 4.29e9) {\n          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n        } else {\n          // 0 <= n <= 4289999999\n          // 0 <= (n % 1e7) <= 9999999\n          rd[i++] = n % 1e7;\n        }\n      } // Node.js supporting crypto.randomBytes.\n\n    } else if (crypto.randomBytes) {\n      // buffer\n      d = crypto.randomBytes(k *= 4);\n\n      for (; i < k;) {\n        // 0 <= n < 2147483648\n        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24); // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\n\n        if (n >= 2.14e9) {\n          crypto.randomBytes(4).copy(d, i);\n        } else {\n          // 0 <= n <= 2139999999\n          // 0 <= (n % 1e7) <= 9999999\n          rd.push(n % 1e7);\n          i += 4;\n        }\n      }\n\n      i = k / 4;\n    } else {\n      throw Error(cryptoUnavailable);\n    }\n\n    k = rd[--i];\n    sd %= LOG_BASE; // Convert trailing digits to zeros according to sd.\n\n    if (k && sd) {\n      n = mathpow(10, LOG_BASE - sd);\n      rd[i] = (k / n | 0) * n;\n    } // Remove trailing words which are zero.\n\n\n    for (; rd[i] === 0; i--) {\n      rd.pop();\n    } // Zero?\n\n\n    if (i < 0) {\n      e = 0;\n      rd = [0];\n    } else {\n      e = -1; // Remove leading words which are zero and adjust exponent accordingly.\n\n      for (; rd[0] === 0; e -= LOG_BASE) {\n        rd.shift();\n      } // Count the digits of the first word of rd to determine leading zeros.\n\n\n      for (k = 1, n = rd[0]; n >= 10; n /= 10) {\n        k++;\n      } // Adjust the exponent for leading zeros of the first word of rd.\n\n\n      if (k < LOG_BASE) e -= LOG_BASE - k;\n    }\n\n    r.e = e;\n    r.d = rd;\n    return r;\n  }\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function round(x) {\n    return finalise(x = new this(x), x.e + 1, this.rounding);\n  }\n  /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function sign(x) {\n    x = new this(x);\n    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n  }\n  /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\n\n\n  function sin(x) {\n    return new this(x).sin();\n  }\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\n\n\n  function sinh(x) {\n    return new this(x).sinh();\n  }\n  /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function sqrt(x) {\n    return new this(x).sqrt();\n  }\n  /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function sub(x, y) {\n    return new this(x).sub(y);\n  }\n  /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\n\n\n  function tan(x) {\n    return new this(x).tan();\n  }\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\n\n\n  function tanh(x) {\n    return new this(x).tanh();\n  }\n  /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\n\n\n  function trunc(x) {\n    return finalise(x = new this(x), x.e + 1, 1);\n  } // Create and configure initial Decimal constructor.\n\n\n  Decimal = clone(DEFAULTS);\n  Decimal['default'] = Decimal.Decimal = Decimal; // Create the internal constants from their string values.\n\n  LN10 = new Decimal(LN10);\n  PI = new Decimal(PI); // Export.\n  // AMD.\n\n  if (typeof define == 'function' && define.amd) {\n    define(function () {\n      return Decimal;\n    }); // Node and other environments that support module.exports.\n  } else if (typeof module != 'undefined' && module.exports) {\n    if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {\n      P[Symbol.for('nodejs.util.inspect.custom')] = P.toString;\n      P[Symbol.toStringTag] = 'Decimal';\n    }\n\n    module.exports = Decimal; // Browser.\n  } else {\n    if (!globalScope) {\n      globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;\n    }\n\n    noConflict = globalScope.Decimal;\n\n    Decimal.noConflict = function () {\n      globalScope.Decimal = noConflict;\n      return Decimal;\n    };\n\n    globalScope.Decimal = Decimal;\n  }\n})(this);","/*\n* Author : Martin Donk\n* Website : http://www.nerdamer.com\n* Email : martin.r.donk@gmail.com\n* License : MIT\n* Source : https://github.com/jiggzson/nerdamer\n*/\n\n/* eslint-disable */\n\nvar nerdamer = require('./core.js');\nrequire('./Calculus.js');\n\n(function() {\n    \"use strict\";\n    \n    /*shortcuts*/\n    var core = nerdamer.getCore(),\n        _ = core.PARSER,\n        N = core.groups.N,\n        P = core.groups.P,\n        S = core.groups.S,\n        EX = core.groups.EX,\n        FN = core.groups.FN,\n        PL = core.groups.PL,\n        CP = core.groups.CP,\n        CB = core.groups.CB,\n        keys = core.Utils.keys,\n        variables = core.Utils.variables,\n        format = core.Utils.format,\n        round = core.Utils.round,\n        Frac = core.Frac,\n        isInt = core.Utils.isInt,\n        Symbol = core.Symbol,\n        CONST_HASH = core.Settings.CONST_HASH,\n        math = core.Utils.importFunctions(),\n        evaluate = core.Utils.evaluate;\n    //*************** CLASSES ***************//\n    /**\n    * Converts a symbol into an equivalent polynomial arrays of \n    * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\n    * Univariate polymials only. \n    * @param {Symbol|Number} symbol\n    * @param {String} variable The variable name of the polynomial\n    * @param {int} order\n    */\n    function Polynomial(symbol, variable, order) { \n        if(core.Utils.isSymbol(symbol)) {\n            this.parse(symbol);\n            this.variable = this.variable || variable;\n        }\n        else if(!isNaN(symbol)) { \n            order = order || 0;\n            if(variable === undefined) \n                throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\n            this.coeffs = [];\n            this.coeffs[order] = symbol;\n            this.fill(symbol);\n        }\n        else if(typeof symbol === 'string') {\n            this.parse(_.parse(symbol));\n        }\n    }\n    /**\n     * Creates a Polynomial given an array of coefficients\n     * @param {int[]} arr\n     * @param {String} variable\n     * @returns {Polynomial}\n     */\n    Polynomial.fromArray = function(arr, variable) {\n        if(typeof variable === 'undefined') \n            throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\n        var p = new Polynomial();\n        p.coeffs = arr;\n        p.variable = variable;\n        return p;\n    };\n    \n    Polynomial.fit = function(c1, c2, n, base, p, variable) {\n        //after having looped through and mod 10 the number to get the matching factor\n        var terms = new Array(p+1),\n            t = n-c2;\n        terms[0] = c2; //the constants is assumed to be correct\n        //constant for x^p is also assumed know so add\n        terms[p] = c1;\n        t -= c1*Math.pow(base, p);\n        //start fitting\n        for(var i=p-1; i>0; i--) {\n            var b = Math.pow(base, i), //we want as many wholes as possible\n                q = t/b,\n                sign = Math.sign(q); \n            var c = sign*Math.floor(Math.abs(q));\n            t -= c*b;\n            terms[i] = c;\n        }\n        if(t !== 0) return null;\n        for(var i=0; i<terms.length; i++)\n            terms[i] = new Frac(terms[i]);\n        \n        return Polynomial.fromArray(terms, variable);\n    };\n\n    Polynomial.prototype = { \n        /**\n         * Converts Symbol to Polynomial\n         * @param {Symbol} symbol\n         * @param {Array} c - a collector array\n         * @returns {Polynomial}\n         */\n        parse: function(symbol, c) { \n            this.variable = variables(symbol)[0]; \n            if(!symbol.isPoly()) throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received '+core.Utils.text(symbol));\n            c = c || [];\n            if(!symbol.power.absEquals(1)) symbol = _.expand(symbol);\n\n            if(symbol.group === core.groups.N) {\n                c[0] = symbol.multiplier; \n            }\n            else if(symbol.group === core.groups.S) { \n                c[symbol.power.toDecimal()] = symbol.multiplier; \n            }\n            else { \n                for(var x in symbol.symbols) { \n                    var sub = symbol.symbols[x],\n                        p = sub.power; \n                    if(core.Utils.isSymbol(p)) throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\n\n                    p = sub.group === N ? 0 : p.toDecimal();\n                    if(sub.symbols){ \n                        this.parse(sub, c);  \n                    }\n                    else { \n                        c[p] = sub.multiplier; \n                    }\n                }\n            }\n\n            this.coeffs = c;\n\n            this.fill();\n        },\n        /**\n        * Fills in the holes in a polynomial with zeroes\n        * @param {Number} x - The number to fill the holes with\n        */\n        fill: function(x) {\n            x = Number(x) || 0;\n            var l = this.coeffs.length;\n            for(var i=0; i<l; i++) {\n                if(this.coeffs[i] === undefined) { this.coeffs[i] = new Frac(x); }\n            }\n            return this;\n        },\n        /**\n        * Removes higher order zeros or a specific coefficient\n        * @returns {Array}\n        */\n        trim: function() { \n            var l = this.coeffs.length;\n            while(l--) {\n                var c = this.coeffs[l];\n                var equalsZero = c.equals(0);\n                if(c && equalsZero) {\n                    if(l === 0) break;\n                    this.coeffs.pop();\n                }\n                else break;\n            }\n\n            return this;\n        },\n        /*\n         * Returns polynomial mod p **currently fails**\n         * @param {Number} p\n         * @returns {Polynomial}\n         */\n        modP: function(p) {\n            var l = this.coeffs.length;\n            for(var i=0; i<l; i++) {\n                var c = this.coeffs[i];\n                if(c < 0) { //go borrow\n                    var b; //a coefficient > 0\n                    for(var j=i; j<l; j++) {//starting from where we left off\n                        if(this.coeffs[j] > 0) {\n                            b = this.coeffs[j];\n                            break;\n                        }\n                    }\n\n                    if(b) { //if such a coefficient exists\n                        for(j; j>i; j--) { //go down the line and adjust using p\n                            this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\n                            this.coeffs[j-1] = this.coeffs[j-1].add(new Frac(p));\n                        }\n                        c = this.coeffs[i]; //reset c\n                    }\n                }\n\n                var d = c.mod(p);\n                var w = c.subtract(d).divide(p);\n                if(!w.equals(0)) {\n                    var up_one = i+1;\n                    var next = this.coeffs[up_one] || new Frac(0);\n                    next = next.add(w);\n                    this.coeffs[up_one] = new Frac(next);\n                    this.coeffs[i] = new Frac(d);\n                }\n            }\n\n            return this;\n        },\n        /**\n        * Adds together 2 polynomials\n        * @param {Polynomial} poly\n        */\n        add: function(poly) {\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\n            for(var i=0; i<l; i++) {\n                var a = (this.coeffs[i] || new Frac(0)),\n                    b = (poly.coeffs[i] || new Frac(0));\n                this.coeffs[i] = a.add(b);\n            }\n            return this;\n        },\n        /**\n        * Adds together 2 polynomials\n        * @param {Polynomial} poly\n        */\n        subtract: function(poly) {\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\n            for(var i=0; i<l; i++) {\n                var a = (this.coeffs[i] || new Frac(0)),\n                    b = (poly.coeffs[i] || new Frac(0));\n                this.coeffs[i] = a.subtract(b);\n            }\n            return this;\n        },\n        divide: function(poly) {\n            var variable = this.variable,\n                dividend = core.Utils.arrayClone(this.coeffs),\n                divisor = core.Utils.arrayClone(poly.coeffs),\n                n = dividend.length,\n                mp = divisor.length-1,\n                quotient = [];\n\n            //loop through the dividend\n            for(var i=0; i<n; i++) {\n                var p = n-(i+1);\n                //get the difference of the powers\n                var d = p - mp;\n                //get the quotient of the coefficients\n                var q = dividend[p].divide(divisor[mp]);\n\n                if(d < 0) break;//the divisor is not greater than the dividend\n                //place it in the quotient\n                quotient[d] = q;\n\n                for(var j=0; j<=mp; j++) {\n                    //reduce the dividend\n                    dividend[j+d] = dividend[j+d].subtract((divisor[j].multiply(q)));\n                }\n            }\n\n            //clean up\n            var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(), //pass in x for safety\n                p2 = Polynomial.fromArray(quotient, variable || 'x');\n            return [p2, p1];\n        },\n        multiply: function(poly) {\n            var l1 = this.coeffs.length, l2 = poly.coeffs.length, \n                c = []; //array to be returned\n            for(var i=0; i<l1; i++) {\n                var x1 = this.coeffs[i];\n                for(var j=0; j<l2; j++) {\n                    var k = i+j, //add the powers together\n                        x2 = poly.coeffs[j],\n                        e = c[k] || new Frac(0); //get the existing term from the new array\n                    c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\n                }\n            }\n            this.coeffs = c;\n            return this;\n        },\n        /**\n         * Checks if a polynomial is zero\n         * @returns {Boolean}\n         */\n        isZero: function() {\n            var l = this.coeffs.length;\n            for(var i=0; i<l; i++) {\n                var e = this.coeffs[i];\n                if(!e.equals(0)) return false;\n            }\n            return true;\n        },\n        /** \n         * Substitutes in a number n into the polynomial p(n)\n         * @param {Number} n\n         * @returns {Frac}\n         */\n        sub: function(n) {\n            var sum = new Frac(0), l=this.coeffs.length;\n            for(var i=0; i<l; i++) {\n                var t = this.coeffs[i];\n                if(!t.equals(0)) sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\n            }\n            return sum;\n        },\n        /**\n         * Returns a clone of the polynomial\n         * @returns {Polynomial}\n         */\n        clone: function() {\n            var p = new Polynomial();\n            p.coeffs = this.coeffs;\n            p.variable = this.variable;\n            return p;\n        },\n        /**\n         * Gets the degree of the polynomial\n         * @returns {Number}\n         */\n        deg: function() {\n            this.trim();\n            return this.coeffs.length-1;\n        },\n        /**\n         * Returns a lead coefficient\n         * @returns {Frac}\n         */\n        lc: function() { \n            return this.coeffs[this.deg()].clone();\n        },\n        /**\n         * Converts polynomial into a monic polynomial\n         * @returns {Polynomial}\n         */\n        monic: function() {\n            var lc = this.lc(), l = this.coeffs.length; \n            for(var i=0; i<l; i++) this.coeffs[i] = this.coeffs[i].divide(lc);\n            return this;\n        },\n        /**\n         * Returns the GCD of two polynomials\n         * @param {Polynomial} poly\n         * @returns {Polynomial}\n         */\n        gcd: function(poly) { \n            //get the maximum power of each\n            var mp1 = this.coeffs.length-1, \n                mp2 = poly.coeffs.length-1,\n                T;\n            //swap so we always have the greater power first\n            if(mp1 < mp2) {\n                return poly.gcd(this);\n            }\n            var a = this;\n\n            while(!poly.isZero()) {   \n                var t = poly.clone(); \n                a = a.clone(); \n                T = a.divide(t);\n                poly = T[1]; \n                a = t; \n            }\n\n            var gcd = core.Math2.QGCD.apply(null, a.coeffs);\n            if(!gcd.equals(1)) { \n                var l = a.coeffs.length;\n                for(var i=0; i<l; i++) {\n                    a.coeffs[i] = a.coeffs[i].divide(gcd);\n                }\n            }\n            return a;\n        },\n        /**\n         * Differentiates the polynomial\n         * @returns {Polynomial}\n         */\n        diff: function() {\n            var new_array = [], l = this.coeffs.length;\n            for(var i=1; i<l; i++) new_array.push(this.coeffs[i].multiply(new Frac(i)));\n            this.coeffs = new_array;\n            return this;\n        },\n        /**\n         * Integrates the polynomial\n         * @returns {Polynomial} \n         */\n        integrate: function() {\n            var new_array = [0], l = this.coeffs.length;\n            for(var i=0; i<l; i++) {\n                var c = new Frac(i+1);\n                new_array[c] = this.coeffs[i].divide(c);\n            }\n            this.coeffs = new_array;\n            return this;\n        },\n        /**\n         * Returns the Greatest common factor of the polynomial\n         * @param {bool} toPolynomial - true if a polynomial is wanted\n         * @returns {Frac|Polynomial}\n         */\n        gcf: function(toPolynomial) {\n            //get the first nozero coefficient and returns its power\n            var fnz = function(a) {\n                    for(var i=0; i<a.length; i++)\n                        if(!a[i].equals(0)) return i;\n                },\n                ca = [];\n            for(var i=0; i<this.coeffs.length; i++) {\n                var c = this.coeffs[i];\n                if(!c.equals(0) && ca.indexOf(c) === -1) ca.push(c);\n            }\n            var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal(); \n\n            if(toPolynomial) {\n                var parr = [];\n                parr[p[1]-1] = p[0];\n                p = Polynomial.fromArray(parr, this.variable).fill();\n            }\n\n            return p;\n        },\n        /**\n         * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\n         * @param {bool} incl_img - Include imaginary numbers \n         */\n        quad: function(incl_img) {\n            var roots = [];\n            if(this.coeffs.length > 3) throw new Error('Cannot calculate quadratic order of '+(this.coeffs.length-1));\n            if(this.coeffs.length === 0) throw new Error('Polynomial array has no terms');\n            var a = this.coeffs[2] || 0, b = this.coeffs[1] || 0, c = this.coeffs[0];\n            var dsc = b*b-4*a*c;\n            if(dsc < 0 && !incl_img) return roots;\n            else {\n                roots[0] = (-b+Math.sqrt(dsc))/(2*a);\n                roots[1] = (-b-Math.sqrt(dsc))/(2*a);\n            }\n            return roots;\n        },\n        /**\n         * Makes polynomial square free\n         * @returns {Array}\n         */\n        squareFree: function() { \n            var a = this.clone(),\n                i = 1,\n                b = a.clone().diff(),\n                c = a.clone().gcd(b),\n                w = a.divide(c)[0];\n            var output = Polynomial.fromArray([new Frac(1)], a.variable);\n            while(!c.equalsNumber(1)) { \n                var y = w.gcd(c); \n                var z = w.divide(y)[0];\n                //one of the factors may have shown up since it's square but smaller than the \n                //one where finding\n                if(!z.equalsNumber(1) && i>1) {\n                    var t = z.clone();\n                    for(var j=1; j<i; j++)\n                        t.multiply(z.clone());\n                    z = t;\n                }\n                output = output.multiply(z); \n                i++;\n                w = y;\n                c = c.divide(y)[0];\n            }\n            return [output, w, i];\n        },\n        /**\n         * Converts polynomial to Symbol\n         * @returns {Symbol}\n         */\n        toSymbol: function() {\n            var l = this.coeffs.length,\n                variable = this.variable;\n            if(l === 0) return new core.Symbol(0);\n            var end = l -1, str = '';\n\n            for(var i=0; i<l; i++) {\n                //place the plus sign for all but the last one\n                var plus = i === end ? '' : '+',\n                    e = this.coeffs[i];\n                if(!e.equals(0)) str += (e+'*'+variable+'^'+i+plus);\n            }\n            return _.parse(str);\n        },\n        /**\n         * Checks if polynomial is equal to a number\n         * @param {Number} x\n         * @returns {Boolean}\n         */\n        equalsNumber: function(x) { \n            this.trim();\n            return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\n        },\n        toString: function() {\n            return this.toSymbol().toString();\n        }\n    };\n\n    /**\n     * TODO\n     * ===================================================================================\n     * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \n     * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\n     * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \n     * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\n     * ===================================================================================\n    * If the symbols is of group PL or CP it will return the multipliers of each symbol\n    * as these are polynomial coefficients. CB symbols are glued together by multiplication\n    * so the symbol multiplier carries the coefficients for all contained symbols.\n    * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\n    * @param {Array} c The coefficient array\n    * @param {boolean} with_order \n    * @return {Array}\n    */\n    Symbol.prototype.coeffs = function(c, with_order) {\n        if(with_order && !this.isPoly(true)) _.error('Polynomial expected when requesting coefficients with order');\n        c = c || [];\n        var s = this.clone().distributeMultiplier(); \n        if(s.isComposite()) {\n            for(var x in s.symbols) { \n                var sub = s.symbols[x];\n                if(sub.isComposite()) { \n                    sub.clone().distributeMultiplier().coeffs(c, with_order);\n                }\n                else { \n                    if(with_order) c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;\n                    else {\n                        c.push(sub.multiplier);\n                    }\n                }\n            }\n        }\n        else { \n            if(with_order) c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;\n            else {\n                if(s.group === CB && s.isImaginary()) {\n                    var m = new Symbol(s.multiplier);\n                    s.each(function(x) {\n                       //add the imaginary part\n                       if(x.isConstant(true) || x.imaginary)\n                           m = _.multiply(m, x);\n                    });\n                    c.push(m);\n                }\n                else\n                    c.push(s.multiplier);\n            }\n        }\n        //fill the holes\n        if(with_order) {\n            for(var i=0; i<c.length; i++)\n                if(c[i] === undefined) c[i] = new Symbol(0);\n        }\n        return c;\n    };\n    Symbol.prototype.tBase = function(map) {\n        if(typeof map === 'undefined') throw new Error('Symbol.tBase requires a map object!');\n        var terms= [];\n        var symbols = this.collectSymbols(null, null, null, true),\n            l = symbols.length;\n        for(var i=0; i<l; i++) {\n            var symbol = symbols[i],\n                g = symbol.group,\n                nterm = new MVTerm(symbol.multiplier, [], map);\n            if(g === CB) {\n                for(var x in symbol.symbols) {\n                    var sym = symbol.symbols[x];\n                    nterm.terms[map[x]] = sym.power;\n                }\n            }\n            else {\n                nterm.terms[map[symbol.value]] = symbol.power;\n            }\n            \n            terms.push(nterm.fill());\n            nterm.updateCount();\n        }\n        return terms;\n    };\n    Symbol.prototype.altVar = function(x) {\n        var m = this.multiplier.toString(), p = this.power.toString();\n        return (m === '1' ? '' : m+'*')+ x + (p === '1' ? '' : '^'+p);\n    };\n    /**\n     * Checks to see if the symbols contain the same variables\n     * @param {Symbol} symbol\n     * @returns {Boolean}\n     */\n    Symbol.prototype.sameVars = function(symbol) {\n        if(!(this.symbols || this.group === symbol.group)) return false;\n        for(var x in this.symbols) {\n            var a = this.symbols[x], b = symbol.symbols[x];\n            if(!b) return false;\n            if(a.value !== b.value) return false;\n        }\n        return true;\n    };\n    /**\n     * Groups the terms in a symbol with respect to a variable\n     * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\n     * @returns {Factors}\n     */\n    Symbol.prototype.groupTerms = function(x) {\n        x = String(x);\n        var f, p, egrouped;\n        var grouped = [];\n        this.each(function(e) {\n            if(e.group === PL) {\n                egrouped = e.groupTerms(x);\n                for(var i=0; i<egrouped.length; i++) {\n                    var el = egrouped[i];\n                    if(el)\n                        grouped[i] = el;\n                }\n            }\n            else {\n                f = core.Utils.decompose_fn(e, x, true);\n                p = f.x.value === x ? Number(f.x.power) : 0;\n                //check if there's an existing value\n                grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\n            }   \n        });\n        return grouped;\n    };\n    /**\n     * Use this to collect Factors\n     * @returns {Symbol[]}\n     */\n    Symbol.prototype.collectFactors = function() {\n        var factors = [];\n        if(this.group === CB)\n            this.each(function(x) {\n               factors.push(x.clone());\n            });\n        else\n            factors.push(this.clone());\n        return factors;\n    };\n    /**\n     * A container class for factors\n     * @returns {Factors}\n     */\n    function Factors() {\n        this.factors = {};\n        this.length = 0;\n    };\n    Factors.prototype.getNumberSymbolics = function() {\n        var n = 0;\n        this.each(function(x) {\n            if(!x.isConstant(true))\n                n++;\n        });\n        return n;\n    };\n    /**\n     * Adds the factors to the factor object\n     * @param {Symbo} s\n     * @returns {Factors}\n     */\n    Factors.prototype.add = function(s) {\n        if(s.equals(0)) \n            return this; //nothing to add\n        \n        //we don't want to carry -1 as a factor. If a factor already exists,\n        //then add the minus one to that factor and return.\n        if(s.equals(-1) && this.length > 0) { \n            var fo = core.Utils.firstObject(this.factors, null, true);\n            this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\n            delete this.factors[fo.key];\n            this.length--;\n            return this;\n        }\n        \n        if(s.group === CB) { \n            var factors = this;\n            if(!s.multiplier.equals(1)) \n                factors.add(new Symbol(s.multiplier));\n            s.each(function(x){\n                factors.add(x);\n            });\n        }\n        else {\n            if(this.preAdd) //if a preAdd function was defined call it to do prep\n                s = this.preAdd(s);\n            if(this.pFactor) //if the symbol isn't linear add back the power\n                s = _.pow(s, new Symbol(this.pFactor));\n\n            var is_constant = s.isConstant();\n            if(is_constant && s.equals(1)) return this; //don't add 1\n            var v = is_constant ? s.value: s.text();\n            if(v in this.factors) {\n                this.factors[v] = _.multiply(this.factors[v], s);\n                //did the addition cancel out the existing factor? If so remove it and decrement the length\n                if(this.factors[v].equals(1)) {\n                    delete this.factors[v];\n                    this.length--;\n                }\n            }\n            else {\n                this.factors[v] = s;\n                this.length++;\n            }\n        }\n        return this;\n    };\n    /**\n     * Converts the factor object to a Symbol\n     * @returns {Symbol}\n     */\n    Factors.prototype.toSymbol = function() {\n        var factored = new Symbol(1);\n        var factors = Object.values(this.factors).sort(function(a, b) {\n            return a.group > b.group;\n        });\n        \n        for(var i=0, l=factors.length; i<l; i++) {\n            var f = factors[i];\n\n            //don't wrap group S or FN\n            var factor = f.power.equals(1) && f.fname !== '' /* don't wrap it twice */? \n                _.symfunction(core.PARENTHESIS, [f]) : f;\n\n            factored = _.multiply(factored, factor);\n        }\n        if(factored.fname === '')\n            factored = Symbol.unwrapPARENS(factored);\n        return factored;\n    };\n    /**\n     * Merges 2 factor objects into one\n     * @param {Factor} o\n     * @returns {Factors}\n     */\n    Factors.prototype.merge = function(o) {\n        for(var x in o) {\n            if(x in this.factors) \n                this.factors[x] = _.multiply(this.factors[x], o[x]);\n            else this.factors[x] = o[x];\n        }\n        return this;\n    };\n    /**\n     * The iterator for the factor object\n     * @param {Function} f - callback\n     * @returns {Factor}\n     */\n    Factors.prototype.each = function(f) {\n        for(var x in this.factors) {\n            var factor = this.factors[x];\n            if(factor.fname === core.PARENTHESIS && factor.isLinear())\n                factor = factor.args[0];\n            f.call(this, factor, x);\n        }\n        return this;\n    };\n    /**\n     * Return the number of factors contained in the factor object\n     * @returns {int}\n     */\n    Factors.prototype.count = function() {\n        return keys(this.factors).length;\n    };\n    /**\n     * Cleans up factors from -1\n     * @returns {undefined}\n     */\n    Factors.prototype.clean = function() {\n        try {\n            var h = core.Settings.CONST_HASH;\n            if(this.factors[h].lessThan(0)) {\n                if(this.factors[h].equals(-1))\n                    delete this.factors[h];\n                else\n                    this.factors[h].negate();\n                this.each(function(x) {\n                    x.negate();\n                });\n            }\n        }\n        catch(e){};\n    };\n    Factors.prototype.toString = function() {\n        return this.toSymbol().toString();\n    };\n    \n    //a wrapper for performing multivariate division\n    function MVTerm(coeff, terms, map) {\n        this.terms = terms || [];\n        this.coeff = coeff;\n        this.map = map; //careful! all maps are the same object\n        this.sum = new core.Frac(0);\n        this.image = undefined;\n    };\n    MVTerm.prototype.updateCount = function() {\n        this.count = this.count || 0;\n        for(var i=0; i<this.terms.length; i++) {\n            if(!this.terms[i].equals(0)) this.count++;\n        }\n        return this;\n    };\n    MVTerm.prototype.getVars = function() {\n        var vars = [];\n        for(var i=0; i<this.terms.length; i++) {\n            var term = this.terms[i],\n                rev_map = this.getRevMap();\n            if(!term.equals(0)) vars.push(this.rev_map[i]);\n        }\n        return vars.join(' ');\n    };\n    MVTerm.prototype.len = function() {\n        if(typeof this.count === 'undefined') {\n            this.updateCount();\n        }\n        return this.count;\n    };\n    MVTerm.prototype.toSymbol = function(rev_map) {\n        rev_map = rev_map || this.getRevMap();\n        var symbol = new Symbol(this.coeff); \n        for(var i=0; i<this.terms.length; i++) {\n            var v = rev_map[i],\n                t = this.terms[i];\n            if(t.equals(0) || v === CONST_HASH) continue;\n            var mapped = new Symbol(v);\n            mapped.power = t;\n            symbol = _.multiply(symbol, mapped);\n        }\n        return symbol;\n    };\n    MVTerm.prototype.getRevMap = function() {\n        if(this.rev_map) return this.rev_map;\n        var o = {};\n        for(var x in this.map) o[this.map[x]] = x;\n        this.rev_map = o;\n        return o;\n    };\n    MVTerm.prototype.generateImage = function() {\n        this.image = this.terms.join(' ');\n        return this;\n    };\n    MVTerm.prototype.getImg = function() {\n        if(!this.image) this.generateImage();\n        return this.image;\n    };\n    MVTerm.prototype.fill = function() {\n        var l = this.map.length;\n        for(var i=0; i<l; i++) {\n            if(typeof this.terms[i] === 'undefined') this.terms[i] = new core.Frac(0);\n            else {\n                this.sum = this.sum.add(this.terms[i]);\n            }\n        }\n        return this;\n    };\n    MVTerm.prototype.divide = function(mvterm) {\n        var c = this.coeff.divide(mvterm.coeff),\n            l = this.terms.length,\n            new_mvterm = new MVTerm(c, [], this.map);\n        for(var i=0; i<l; i++) {\n            new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n        }\n        return new_mvterm;\n    };\n    MVTerm.prototype.multiply = function(mvterm) {\n        var c = this.coeff.multiply(mvterm.coeff),\n            l = this.terms.length,\n            new_mvterm = new MVTerm(c, [], this.map);\n        for(var i=0; i<l; i++) {\n            new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n        }\n        return new_mvterm;\n    };\n    MVTerm.prototype.isZero = function() {\n        return this.coeff.equals(0);\n    };\n    MVTerm.prototype.toString = function() {\n        return '{ coeff: '+this.coeff.toString()+', terms: ['+\n                this.terms.join(',')+']: sum: '+this.sum.toString()+', count: '+this.count+'}';\n    };\n    \n    core.Utils.toMapObj = function(arr) {\n        var c = 0, o = {};\n        for(var i=0; i<arr.length; i++) {\n            var v = arr[i];\n            if(typeof o[v] === 'undefined') {\n                o[v] = c; c++;\n            }\n        }\n        o.length = c;\n        return o;\n    };\n    core.Utils.filledArray = function(v, n, clss) {\n        var a = [];\n        while (n--) {\n          a[n] = clss ? new clss(v) : v;\n        }\n        return a;\n    };\n    core.Utils.arrSum = function(arr) {\n        var sum = 0, l = arr.length;\n        for(var i=0; i<l; i++) sum += arr[i];\n        return sum;\n    };    \n    /**\n     * Determines if 2 arrays have intersecting elements.\n     * @param {Array} a\n     * @param {Array} b\n     * @returns {Boolean} True if a and b have intersecting elements.\n     */\n    core.Utils.haveIntersection = function(a, b) {\n        var t;\n        if (b.length > a.length) {\n            t = b;\n            b = a;\n            a = t;\n        }  // indexOf to loop over shorter\n        return a.some(function (e) {\n            return b.indexOf(e) > -1;\n        });\n    };\n    /**\n     * Substitutes out functions as variables so they can be used in regular algorithms\n     * @param {Symbol} symbol\n     * @param {Object} map\n     * @returns {String} The expression string\n     */\n    core.Utils.subFunctions = function(symbol, map) {\n        map = map || {};\n        var subbed = [];\n        symbol.each(function(x) {\n            if(x.group === FN || x.previousGroup === FN) {\n                //we need a new variable name so why not use one of the existing\n                var val = core.Utils.text(x, 'hash'), tvar = map[val];\n                if(!tvar) {\n                    //generate a unique enough name\n                    var t = x.fname+keys(map).length;\n                    map[val] = t;\n                    subbed.push(x.altVar(t));\n                }\n                else subbed.push(x.altVar(tvar));\n            }\n            else if(x.group === CB || x.group === PL || x.group === CP) {\n                subbed.push(core.Utils.subFunctions(x, map));\n            }\n            else subbed.push(x.text());\n        });\n        if(symbol.group === CP || symbol.group === PL) return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));;\n        if(symbol.group === CB) return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\n        return symbol.text();\n    };\n    core.Utils.getFunctionsSubs = function(map) {\n        var subs = {};\n        //prepare substitutions\n        for(var x in map) subs[map[x]] = _.parse(x);\n        return subs;\n    };\n    var __ = core.Algebra = {\n        version: '1.4.6',\n        proots: function(symbol, decp) { \n            //the roots will be rounded up to 7 decimal places.\n            //if this causes trouble you can explicitly pass in a different number of places\n            //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\n            decp = decp || 7;\n            var zeros = 0;\n            var known_roots = [];\n            var get_roots = function(rarr, powers, max) {\n                var roots = calcroots(rarr, powers, max).concat(known_roots);\n                for(var i=0;i<zeros;i++) roots.unshift(0);\n                return roots;\n            };\n            \n            if(symbol instanceof Symbol && symbol.isPoly()) { \n                symbol.distributeMultiplier();\n                //make it so the symbol has a constants as the lowest term\n                if(symbol.group === PL) {\n                    var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\n                    var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\n                    symbol = _.expand(_.divide(symbol, lowest_symbol));\n                    known_roots.push(0); //add zero since this is a known root\n                }\n                if(symbol.group === core.groups.S) { \n                    return [0];\n                }\n                else if(symbol.group === core.groups.PL) { \n                    var powers = keys(symbol.symbols),\n                        minpower = core.Utils.arrayMin(powers),\n                    symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value+'^'+minpower));\n                }\n\n                var variable = keys(symbol.symbols).sort().pop(), \n                    sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable], \n                    g = sym.group,\n                    powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\n                    rarr = [],\n                    max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\n\n                // Prepare the data\n                for(var i=1; i<=max; i++) { \n                    var c = 0; //if there is no power then the hole must be filled with a zero\n                    if(powers.indexOf(i+'') !== -1) { \n                        if(g === S) { \n                            c = sym.multiplier; \n                        }\n                        else {\n                            c = sym.symbols[i].multiplier;\n                        }\n                    }\n                    // Insert the coeffient but from the front\n                    rarr.unshift(c);\n                }\n                \n                rarr.push(symbol.symbols[CONST_HASH].multiplier);\n\n                if(sym.group === S) rarr[0] = sym.multiplier;//the symbol maybe of group CP with one variable\n\n                return get_roots(rarr, powers, max);\n            }\n            else if(core.Utils.isArray(symbol)) {\n                var parr = symbol;\n                var rarr = [],\n                    powers = [],\n                    last_power = 0;\n                for(var i=0; i<parr.length; i++) {\n                    \n                    var coeff = parr[i][0],\n                        pow = parr[i][1],\n                        d = pow - last_power - 1;\n                    //insert the zeros\n                    for(var j=0; j<d; j++) rarr.unshift(0);\n                    \n                    rarr.unshift(coeff);\n                    if(pow !== 0) powers.push(pow);\n                    last_power = pow;\n                }\n                var max = Math.max.apply(undefined, powers);\n\n                return get_roots(rarr, powers, max);\n            }\n            else {\n                throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\n            }\n\n            function calcroots(rarr, powers, max){\t\n                var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\n\n                // Make a clone of the coefficients before appending the max power\n                var p = rarr.slice(0);\n\n                // Divide the string up into its individual entries, which--presumably--are separated by whitespace\n                rarr.unshift(max);\n\n                if (max > MAXDEGREE){\n                    throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\n                }\n\n                var zeroi = [],   // Vector of imaginary components of roots\n                    degreePar = {};    // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\n                degreePar.Degree = max; \n\n                for (i = 0; i < max; i++) {\n                    zeroi.push(0);\n                }\n                var zeror = zeroi.slice(0); // Vector of real components of roots\n\n                // Find the roots\n                //--> Begin Jenkins-Traub\n\n                /*\n                 * A verbatim copy of Mr. David Binner's Jenkins-Traub port\n                */\n               function QuadSD_ak1(NN, u, v, p, q, iPar){\n                   // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\n                   // iPar is a dummy variable for passing in the two parameters--a and b--by reference\n                   q[0] = iPar.b = p[0];\n                   q[1] = iPar.a = -(u*iPar.b) + p[1];\n\n                   for (var i = 2; i < NN; i++){\n                       q[i] = -(u*iPar.a + v*iPar.b) + p[i];\n                       iPar.b = iPar.a;\n                       iPar.a = q[i];\n                   } \n                   return;\n               } \n\n               function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk){\n                   // This routine calculates scalar quantities used to compute the next K polynomial and\n                   // new estimates of the quadratic coefficients.\n                   // calcSC -\tinteger variable set here indicating how the calculations are normalized\n                   // to avoid overflow.\n                   // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\n\n                   // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\n                   var sdPar = new Object(),    \n                   // TYPE = 3 indicates the quadratic is almost a factor of K\n                       dumFlag = 3;\t\n\n                   // Synthetic division of K by the quadratic 1, u, v\n                   sdPar.b =  sdPar.a = 0.0;\n                   QuadSD_ak1(N, u, v, K, qk, sdPar);\n                   iPar.c = sdPar.a;\n                   iPar.d = sdPar.b;\n\n                   if (Math.abs(iPar.c) <= (100.0*DBL_EPSILON*Math.abs(K[N - 1]))) {\n                       if (Math.abs(iPar.d) <= (100.0*DBL_EPSILON*Math.abs(K[N - 2])))  return dumFlag;\n                   } \n\n                   iPar.h = v*b;\n                   if (Math.abs(iPar.d) >= Math.abs(iPar.c)){\n                         // TYPE = 2 indicates that all formulas are divided by d\n                       dumFlag = 2;\t\t\n                       iPar.e = a/(iPar.d);\n                       iPar.f = (iPar.c)/(iPar.d);\n                       iPar.g = u*b;\n                       iPar.a3 = (iPar.e)*((iPar.g) + a) + (iPar.h)*(b/(iPar.d));\n                       iPar.a1 = -a + (iPar.f)*b;\n                       iPar.a7 = (iPar.h) + ((iPar.f) + u)*a;\n                   } \n                   else {\n                       // TYPE = 1 indicates that all formulas are divided by c;\n                       dumFlag = 1;\t\t\n                       iPar.e = a/(iPar.c);\n                       iPar.f = (iPar.d)/(iPar.c);\n                       iPar.g = (iPar.e)*u;\n                       iPar.a3 = (iPar.e)*a + ((iPar.g) + (iPar.h)/(iPar.c))*b;\n                       iPar.a1 = -(a*((iPar.d)/(iPar.c))) + b;\n                       iPar.a7 = (iPar.g)*(iPar.d) + (iPar.h)*(iPar.f) + a;\n                   } \n                   return dumFlag;\n               } \n\n               function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp){\n                   // Computes the next K polynomials using the scalars computed in calcSC_ak1\n                   // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\n                   var temp;\n                   if (tFlag == 3){\t// Use unscaled form of the recurrence\n                       K[1] = K[0] = 0.0;\n                       for (var i = 2; i < N; i++)\t { K[i] = qk[i - 2]; }\n                       return;\n                   } \n\n                   temp = ((tFlag == 1) ? b : a);\n                   if (Math.abs(iPar.a1) > (10.0*DBL_EPSILON*Math.abs(temp))){\n                       // Use scaled form of the recurrence\n                       iPar.a7 /= iPar.a1;\n                       iPar.a3 /= iPar.a1;\n                       K[0] = qp[0];\n                       K[1] = -(qp[0]*iPar.a7) + qp[1];\n                       for (var i = 2; i < N; i++)\t K[i] = -(qp[i - 1]*iPar.a7) + qk[i - 2]*iPar.a3 + qp[i];\n                   } \n                   else {\n                       // If a1 is nearly zero, then use a special form of the recurrence\n                       K[0] = 0.0;\n                       K[1] = -(qp[0]*iPar.a7);\n                       for (var i = 2; i < N; i++) { K[i] = -(qp[i - 1]*iPar.a7) + qk[i - 2]*iPar.a3; }\n                   } \n                   return;\n               }\n\n               function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p){\n                   // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\n                   // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\n                   // iPar.a = uu, iPar.b = vv\n\n                   var a4, a5, b1, b2, c1, c2, c3, c4, temp;\n                   iPar.b = iPar.a = 0.0;// The quadratic is zeroed\n\n                   if (tFlag != 3){\n                       if (tFlag != 2){\n                           a4 = a + u*b + h*f;\n                           a5 = c + (u + v*f)*d;\n                       } \n                       else { \n                           a4 = (a + g)*f + h;\n                           a5 = (f + u)*c + v*d;\n                       } \n\n                       // Evaluate new quadratic coefficients\n                       b1 = -(K[N - 1]/p[N]);\n                       b2 = -(K[N - 2] + b1*p[N - 1])/p[N];\n                       c1 = v*b2*a1;\n                       c2 = b1*a7;\n                       c3 = b1*b1*a3;\n                       c4 = -(c2 + c3) + c1;\n                       temp = -c4 + a5 + b1*a4;\n                       if (temp != 0.0) {\n                           iPar.a = -((u*(c3 + c2) + v*(b1*a1 + b2*a7))/temp) + u;\n                           iPar.b = v*(1.0 + c4/temp);\n                       } \n                   } \n                   return;\n               } \n\n               function Quad_ak1(a, b1, c, iPar){\n                   // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\n                   // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\n                   // zeros are real and both zeros are complex. The smaller real zero is found directly from\n                   // the product of the zeros c/a.\n\n                   // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\n\n                   var b, d, e;\n                   iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\n\n                   if (a == 0) {\n                       iPar.sr = ((b1 != 0) ? -(c/b1) : iPar.sr);\n                       return;\n                   } \n                   if (c == 0){\n                       iPar.lr = -(b1/a);\n                       return;\n                   } \n\n                   // Compute discriminant avoiding overflow\n                   b = b1/2.0;\n                   if (Math.abs(b) < Math.abs(c)){\n                       e = ((c >= 0) ? a : -a);\n                       e = -e + b*(b/Math.abs(c));\n                       d = Math.sqrt(Math.abs(e))*Math.sqrt(Math.abs(c));\n                   } \n                   else { \n                       e = -((a/b)*(c/b)) + 1.0;\n                       d = Math.sqrt(Math.abs(e))*(Math.abs(b));\n                   } \n\n                   if (e >= 0) {\n                       // Real zeros\n                       d = ((b >= 0) ? -d : d);\n                       iPar.lr = (-b + d)/a;\n                       iPar.sr = ((iPar.lr != 0) ? (c/(iPar.lr))/a : iPar.sr);\n                   }\n                   else { \n                       // Complex conjugate zeros\n                       iPar.lr = iPar.sr = -(b/a);\n                       iPar.si = Math.abs(d/a);\n                       iPar.li = -(iPar.si);\n                   } \n                   return;\n               }  \n\n               function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K){\n                   // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\n                   // zeros are equimodular or nearly so.\n                   // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n                   // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\n                   // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\n\n                   // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\n                   var qPar = new Object(),    \n                       ee, mp, omp, relstp, t, u, ui, v, vi, zm,\n                       i, j = 0, tFlag, triedFlag = 0;   // Integer variables\n\n                   iPar.NZ = 0;// Number of zeros found\n                   u = uu; // uu and vv are coefficients of the starting quadratic\n                   v = vv;\n\n                   do {\n                       qPar.li = qPar.lr =  qPar.si = qPar.sr = 0.0;\n                       Quad_ak1(1.0, u, v, qPar);\n                       iPar.szr = qPar.sr;\n                       iPar.szi = qPar.si;\n                       iPar.lzr = qPar.lr;\n                       iPar.lzi = qPar.li;\n\n                       // Return if roots of the quadratic are real and not close to multiple or nearly\n                       // equal and of opposite sign.\n                       if (Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01*Math.abs(iPar.lzr))  break;\n\n                       // Evaluate polynomial by quadratic synthetic division\n\n                       QuadSD_ak1(NN, u, v, p, qp, sdPar);\n\n                       mp = Math.abs(-((iPar.szr)*(sdPar.b)) + (sdPar.a)) + Math.abs((iPar.szi)*(sdPar.b));\n\n                       // Compute a rigorous bound on the rounding error in evaluating p\n\n                       zm = Math.sqrt(Math.abs(v));\n                       ee = 2.0*Math.abs(qp[0]);\n                       t = -((iPar.szr)*(sdPar.b));\n\n                       for (i = 1; i < N; i++)  { ee = ee*zm + Math.abs(qp[i]); }\n\n                       ee = ee*zm + Math.abs(t + sdPar.a);\n                       ee = (9.0*ee + 2.0*Math.abs(t) - 7.0*(Math.abs((sdPar.a) + t) + zm*Math.abs((sdPar.b))))*DBL_EPSILON;\n\n                       // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\n                       if (mp <= 20.0*ee){\n                           iPar.NZ = 2;\n                           break;\n                       } \n\n                       j++;\n                       // Stop iteration after 20 steps\n                       if (j > 20)  break;\n                       if (j >= 2){\n                           if ((relstp <= 0.01) && (mp >= omp) && (!triedFlag)){\n                               // A cluster appears to be stalling the convergence. Five fixed shift\n                               // steps are taken with a u, v close to the cluster.\n                               relstp = ((relstp < DBL_EPSILON) ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp));\n                               u -= u*relstp;\n                               v += v*relstp;\n\n                               QuadSD_ak1(NN, u, v, p, qp, sdPar);\n                               for (i = 0; i < 5; i++){\n                                   tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n                                   nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n                               } \n\n                               triedFlag = 1;\n                               j = 0;\n\n                           } \n                       }\n                       omp = mp;\n\n                       // Calculate next K polynomial and new u and v\n                       tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n                       nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n                       tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n                       newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n                       ui = sdPar.a;\n                       vi = sdPar.b;\n\n                       // If vi is zero, the iteration is not converging\n                       if (vi != 0){\n                           relstp = Math.abs((-v + vi)/vi);\n                           u = ui;\n                           v = vi;\n                       } \n                   } while (vi != 0); \n                   return;\n               } \n\n               function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk){\n                   // Variable-shift H-polynomial iteration for a real zero\n                   // sss\t- starting iterate = sdPar.a\n                   // NZ\t\t- number of zeros found = iPar.NZ\n                   // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\n\n                   var ee, kv, mp, ms, omp, pv, s, t,\n                       dumFlag, i, j, nm1 = N - 1;   // Integer variables\n\n                   iPar.NZ = j = dumFlag = 0;\n                   s = sdPar.a;\n\n                   for ( ; ; ) {\n                       pv = p[0];\n\n                       // Evaluate p at s\n                       qp[0] = pv;\n                       for (i = 1; i < NN; i++)  { qp[i] = pv = pv*s + p[i]; }\n                       mp = Math.abs(pv);\n\n                       // Compute a rigorous bound on the error in evaluating p\n                       ms = Math.abs(s);\n                       ee = 0.5*Math.abs(qp[0]);\n                       for (i = 1; i < NN; i++)  { ee = ee*ms + Math.abs(qp[i]); }\n\n                       // Iteration has converged sufficiently if the polynomial value is less than\n                       // 20 times this bound\n                       if (mp <= 20.0*DBL_EPSILON*(2.0*ee - mp)){\n                           iPar.NZ = 1;\n                           iPar.szr = s;\n                           iPar.szi = 0.0;\n                           break;\n                       } \n                       j++;\n                       // Stop iteration after 10 steps\n                       if (j > 10)  break;\n\n                       if (j >= 2){\n                           if ((Math.abs(t) <= 0.001*Math.abs(-t + s)) && (mp > omp)){\n                               // A cluster of zeros near the real axis has been encountered.\n                               // Return with iFlag set to initiate a quadratic iteration.\n                               dumFlag = 1;\n                               iPar.a = s;\n                               break;\n                           } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\n                       } //End if (j >= 2)\n\n                       // Return if the polynomial value has increased significantly\n                       omp = mp;\n\n                       // Compute t, the next polynomial and the new iterate\n                       qk[0] = kv = K[0];\n                       for (i = 1; i < N; i++)\t { qk[i] = kv = kv*s + K[i]; }\n\n                       if (Math.abs(kv) > Math.abs(K[nm1])*10.0*DBL_EPSILON){\n                           // Use the scaled form of the recurrence if the value of K at s is non-zero\n                           t = -(pv/kv);\n                           K[0] = qp[0];\n                           for (i = 1; i < N; i++) { K[i] = t*qk[i - 1] + qp[i]; }\n                       }\n                       else { \n                           // Use unscaled form\n                           K[0] = 0.0;\n                           for (i = 1; i < N; i++)\t K[i] = qk[i - 1];\n                       }\n\n                       kv = K[0];\n                       for (i = 1; i < N; i++) { kv = kv*s + K[i]; }\n                       t = ((Math.abs(kv) > (Math.abs(K[nm1])*10.0*DBL_EPSILON)) ? -(pv/kv) : 0.0);\n                       s += t;\n                   } \n                   return dumFlag;\n               } \n\n               function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar){\n\n                   // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\n                   // quadratic case. Initiates one of the variable shift iterations and returns with the\n                   // number of zeros found.\n                   // L2\tlimit of fixed shift steps\n                   // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n                   // NZ\tnumber of zeros found\n                   var sdPar = new Object(),    // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\n                       calcPar = new Object(),\n                       // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\n\n                       qk = new Array(MDP1),\n                       svk = new Array(MDP1),\n                       a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, ui, vi, vv,\n                       fflag, i, iFlag = 1, j, spass, stry, tFlag, vpass, vtry;     // Integer variables\n\n                   iPar.NZ = 0;\n                   betav = betas = 0.25;\n                   oss = sr;\n                   ovv = v;\n\n                   //Evaluate polynomial by synthetic division\n                   sdPar.b =  sdPar.a = 0.0;\n                   QuadSD_ak1(NN, u, v, p, qp, sdPar);\n                   a = sdPar.a;\n                   b = sdPar.b;\n                   calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\n                   tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n\n                   for (j = 0; j < L2; j++){\n                       fflag = 1;\n\n                       // Calculate next K polynomial and estimate v\n                       nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\n                       tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n\n                       // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\n                       // sdPar.a = ui, sdPar.b = vi\n                       newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n                       ui = sdPar.a;\n                       vv = vi = sdPar.b;\n\n                       // Estimate s\n                       ss = ((K[N - 1] != 0.0) ? -(p[N]/K[N - 1]) : 0.0);\n                       ts = tv = 1.0;\n\n                       if ((j != 0) && (tFlag != 3)){\n                           // Compute relative measures of convergence of s and v sequences\n                           tv = ((vv != 0.0) ? Math.abs((vv - ovv)/vv) : tv);\n                           ts = ((ss != 0.0) ? Math.abs((ss - oss)/ss) : ts);\n\n                           // If decreasing, multiply the two most recent convergence measures\n                           tvv = ((tv < otv) ? tv*otv : 1.0);\n                           tss = ((ts < ots) ? ts*ots : 1.0);\n\n                           // Compare with convergence criteria\n                           vpass = ((tvv < betav) ? 1 : 0);\n                           spass = ((tss < betas) ? 1 : 0);\n\n                           if ((spass) || (vpass)){\n\n                               // At least one sequence has passed the convergence test.\n                               // Store variables before iterating\n\n                               for (i = 0; i < N; i++) { svk[i] = K[i]; }\n                               s = ss;\n\n                               // Choose iteration according to the fastest converging sequence\n\n                                 stry = vtry = 0;\n\n                               for ( ; ; ) {\n                                   if ((fflag && ((fflag = 0) == 0)) && ((spass) && (!vpass || (tss < tvv)))){\n                                       ;// Do nothing. Provides a quick \"short circuit\".\n                                   } \n                                   else { \n                                       QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\n                                       a = sdPar.a;\n                                       b = sdPar.b;\n\n                                       if ((iPar.NZ) > 0) return;\n\n                                       // Quadratic iteration has failed. Flag that it has been tried and decrease the\n                                       // convergence criterion\n                                       iFlag = vtry = 1;\n                                       betav *= 0.25;\n\n                                       // Try linear iteration if it has not been tried and the s sequence is converging\n                                       if (stry || (!spass)){\n                                           iFlag = 0;\n                                       }\n                                       else {\n                                           for (i = 0; i < N; i++) K[i] = svk[i];\n                                       } \n                                   }\n                                   //fflag = 0;\n                                   if (iFlag != 0){\n                                       // Use sdPar for passing in s instead of defining a brand-new variable.\n                                       // sdPar.a = s\n                                       sdPar.a = s;\n                                       iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\n                                       s = sdPar.a;\n\n                                       if ((iPar.NZ) > 0) return;\n\n                                       // Linear iteration has failed. Flag that it has been tried and decrease the\n                                       // convergence criterion\n                                       stry = 1;\n                                       betas *= 0.25;\n\n                                       if (iFlag != 0){\n                                           // If linear iteration signals an almost double real zero, attempt quadratic iteration\n                                           ui = -(s + s);\n                                           vi = s*s;\n                                           continue;\n\n                                       } \n                                   } \n\n                                   // Restore variables\n                                   for (i = 0; i < N; i++) K[i] = svk[i];\n\n                                   // Try quadratic iteration if it has not been tried and the v sequence is converging\n                                   if (!vpass || vtry) break;\t\t// Break out of infinite for loop\n\n                               } \n\n                               // Re-compute qp and scalar values to continue the second stage\n\n                               QuadSD_ak1(NN, u, v, p, qp, sdPar);\n                               a = sdPar.a;\n                               b = sdPar.b;\n\n                               tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n                           } \n                       } \n                       ovv = vv;\n                       oss = ss;\n                       otv = tv;\n                       ots = ts;\n                   } \n                   return;\n               }  \n\n               function rpSolve(degPar, p, zeror, zeroi){ \n                   var N = degPar.Degree,\n                       RADFAC = 3.14159265358979323846/180,  // Degrees-to-radians conversion factor = PI/180\n                       LB2 = Math.LN2,// Dummy variable to avoid re-calculating this value in loop below\n                       MDP1 = degPar.Degree + 1,\n                       K = new Array(MDP1),\n                       pt = new Array(MDP1),\n                       qp = new Array(MDP1),\n                       temp = new Array(MDP1),\n                       // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\n                       qPar = new Object(),\n                       // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\n                       Fxshfr_Par = new Object(),\n                       bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm,\n                       aa, bb, cc, sr, t, u, xxx,\n                       j, jj, l, NM1, NN, zerok;// Integer variables\n\n                   // Calculate the machine epsilon and store in the variable DBL_EPSILON.\n                   // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\n                   aa = 1.0;\n                   do {\n                       DBL_EPSILON = aa;\n                       aa /= 2;\n                       bb = 1.0 + aa;\n                   } while (bb > 1.0);\n\n                   var LO = Number.MIN_VALUE/DBL_EPSILON,\n                       cosr = Math.cos(94.0*RADFAC),// = -0.069756474\n                       sinr = Math.sin(94.0*RADFAC),// = 0.99756405\n                       xx = Math.sqrt(0.5),// = 0.70710678\n                       yy = -xx;\n\n                   Fxshfr_Par.NZ = j = 0;\n                   Fxshfr_Par.szr = Fxshfr_Par.szi =  Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0;\n\n                   // Remove zeros at the origin, if any\n                   while (p[N] == 0){\n                       zeror[j] = zeroi[j] = 0;\n                       N--;\n                       j++;\n                   }\n                   NN = N + 1;\n\n                   // >>>>> Begin Main Loop <<<<<\n                   while (N >= 1){ // Main loop\n                       // Start the algorithm for one zero\n                       if (N <= 2){\n                           // Calculate the final zero or pair of zeros\n                           if (N < 2){\n                               zeror[degPar.Degree - 1] = -(p[1]/p[0]);\n                               zeroi[degPar.Degree - 1] = 0;\n                           } \n                           else { \n                               qPar.li = qPar.lr =  qPar.si = qPar.sr = 0.0;\n                               Quad_ak1(p[0], p[1], p[2], qPar);\n                               zeror[degPar.Degree - 2] = qPar.sr;\n                               zeroi[degPar.Degree - 2] = qPar.si;\n                               zeror[degPar.Degree - 1] = qPar.lr;\n                               zeroi[degPar.Degree - 1] = qPar.li;\n                           } \n                             break;\n                       } \n\n                       // Find the largest and smallest moduli of the coefficients\n                       moduli_max = 0.0;\n                       moduli_min = Number.MAX_VALUE;\n\n                       for (i = 0; i < NN; i++){\n                           x = Math.abs(p[i]);\n                           if (x > moduli_max) moduli_max = x;\n                           if ((x != 0) && (x < moduli_min)) moduli_min = x;\n                       }\n\n                       // Scale if there are large or very small coefficients\n                       // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\n                       // is done to avoid overflow and to avoid undetected underflow interfering with the\n                       // convergence criterion.\n                       // The factor is a power of the base.\n                       sc = LO/moduli_min;\n\n                       if (((sc <= 1.0) && (moduli_max >= 10)) || ((sc > 1.0) && (Number.MAX_VALUE/sc >= moduli_max))){\n                           sc = ((sc == 0) ? Number.MIN_VALUE : sc);\n                           l = Math.floor(Math.log(sc)/LB2 + 0.5);\n                           factor = Math.pow(2.0, l);\n                           if (factor != 1.0){\n                               for (i = 0; i < NN; i++) p[i] *= factor;\n                           } \n                       } \n\n                       // Compute lower bound on moduli of zeros\n                       for (var i = 0; i < NN; i++) pt[i] = Math.abs(p[i]);\n                       pt[N] = -(pt[N]);\n                       NM1 = N - 1;\n\n                       // Compute upper estimate of bound\n                       x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0]))/N);\n\n                       if (pt[NM1] != 0) {\n                           // If Newton step at the origin is better, use it\n                           xm = -pt[N]/pt[NM1];\n                           x = ((xm < x) ? xm : x);\n                       } \n\n                       // Chop the interval (0, x) until ff <= 0\n                       xm = x;\n                       do {\n                           x = xm;\n                           xm = 0.1*x;\n                           ff = pt[0];\n                           for (var i = 1; i < NN; i++) { ff = ff *xm + pt[i]; }\n                       } while (ff > 0); // End do-while loop\n\n                       dx = x;\n                       // Do Newton iteration until x converges to two decimal places\n\n                       do {\n                           df = ff = pt[0];\n                           for (var i = 1; i < N; i++){\n                               ff = x*ff + pt[i];\n                               df = x*df + ff;\n                           } // End for i\n                           ff = x*ff + pt[N];\n                           dx = ff/df;\n                           x -= dx;\n                       } while (Math.abs(dx/x) > 0.005); // End do-while loop\n\n                       bnd = x;\n\n                       // Compute the derivative as the initial K polynomial and do 5 steps with no shift\n                       for (var i = 1; i < N; i++) K[i] = (N - i)*p[i]/N;\n                       K[0] = p[0];\n                       aa = p[N];\n                       bb = p[NM1];\n                       zerok = ((K[NM1] == 0) ? 1 : 0);\n\n                       for (jj = 0; jj < 5; jj++) {\n                           cc = K[NM1];\n                               if (zerok){\n                                   // Use unscaled form of recurrence\n                                   for (var i = 0; i < NM1; i++){\n                                       j = NM1 - i;\n                                       K[j] = K[j - 1];\n                                   } // End for i\n                                   K[0] = 0;\n                                   zerok = ((K[NM1] == 0) ? 1 : 0);\n                               } \n                               else { \n                                   // Used scaled form of recurrence if value of K at 0 is nonzero\n                                   t = -aa/cc;\n                                   for (var i = 0; i < NM1; i++){\n                                       j = NM1 - i;\n                                       K[j] = t*K[j - 1] + p[j];\n                                   } // End for i\n                                   K[0] = p[0];\n                                   zerok = ((Math.abs(K[NM1]) <= Math.abs(bb)*DBL_EPSILON*10.0) ? 1 : 0);\n                               } \n                       } \n\n                       // Save K for restarts with new shifts\n                       for (var i = 0; i < N; i++) temp[i] = K[i];\n\n                       // Loop to select the quadratic corresponding to each new shift\n                       for (jj = 1; jj <= 20; jj++){\n\n                           // Quadratic corresponds to a double shift to a non-real point and its\n                           // complex conjugate. The point has modulus BND and amplitude rotated\n                           // by 94 degrees from the previous shift.\n\n                           xxx = -(sinr*yy) + cosr*xx;\n                           yy = sinr*xx + cosr*yy;\n                           xx = xxx;\n                           sr = bnd*xx;\n                           u = -(2.0*sr);\n\n                           // Second stage calculation, fixed quadratic\n                           Fxshfr_ak1(DBL_EPSILON, MDP1, 20*jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\n\n                           if (Fxshfr_Par.NZ != 0){\n                               // The second stage jumps directly to one of the third stage iterations and\n                               // returns here if successful. Deflate the polynomial, store the zero or\n                               // zeros, and return to the main algorithm.\n                               j = degPar.Degree - N;\n                               zeror[j] = Fxshfr_Par.szr;\n                               zeroi[j] = Fxshfr_Par.szi;\n                               NN = NN - Fxshfr_Par.NZ;\n                               N = NN - 1;\n                               for (var i = 0; i < NN; i++) p[i] = qp[i];\n                               if (Fxshfr_Par.NZ != 1){\n                                   zeror[j + 1] = Fxshfr_Par.lzr;\n                                   zeroi[j + 1] = Fxshfr_Par.lzi;\n                               }\n                               break;\n                           } \n                           else { \n                             // If the iteration is unsuccessful, another quadratic is chosen after restoring K\n                             for (var i = 0; i < N; i++) { K[i] = temp[i]; }\n                           } \n                       } \n                       // Return with failure if no convergence with 20 shifts\n                       if (jj > 20) {\n                           degPar.Degree -= N;\n                           break;\n                       } \n                   }\n                   // >>>>> End Main Loop <<<<<\n                   return;\n               }\n                //--> End Jenkins-Traub\n                rpSolve(degreePar, p, zeror, zeroi);\n\n                var l = zeroi.length;\n                //format the output\n                for( i=0; i<l; i++ ) {\n                    // We round the imaginary part to avoid having something crazy like 5.67e-16.\n                    var img = round( zeroi[i], decp+8 ),\n                        real = round( zeror[i], decp+8 );\n                    // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\n                    // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \n                    // the original otherwise the rounding was worth it.\n                    real = decp - String( real ).length > 2 ? real : zeror[i];\n                    var sign = img < 0 ? '-' : '';\n\n                    // Remove the zeroes\n                    if( real === 0 ) { real = ''; }\n                    if( img === 0 ) { img = ''; }\n\n                    // Remove 1 as the multiplier and discard imaginary part if there isn't one.\n                    img = Math.abs( img ) === 1 ? sign+'i' : ( img ? img+'*i' : '' );\n\n                    var num = ( real && img ) ? real + '+' + img : real+img;\n                    zeror[i] = num.replace(/\\+\\-/g, '-');\n                }\n                return zeror;\n            } \n         },\n        roots: function(symbol) {\n            \n            if(symbol.isConstant(true, true)) {\n                return core.Utils.nroots(symbol);\n            }\n            var roots = __.proots(symbol).map(function(x) {\n                return _.parse(x);\n            });\n            return core.Vector.fromArray(roots);\n        },\n        froot: function(f, guess, dx) { \n            var newtonraph = function(xn) {\n                var mesh = 1e-12,\n                    // If the derivative was already provided then don't recalculate.\n                    df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\n                    \n                    // If the function was passed in as a function then don't recalculate.\n                    fn = f instanceof Function ? f : core.Utils.build(f),\n                    max = 10000,\n                    done = false, \n                    safety = 0;\n                while( !done ) { \n                    var x = xn-(fn(xn)/df(xn));\n                    //absolute values for both x & xn ensures that we indeed have the radius    \n                    var r = Math.abs(x) - Math.abs(xn),\n                        delta = Math.abs(r);\n                    xn = x; \n\n                    if( delta < mesh ) done = true;\n                    else if( safety > max ) {\n                        xn = null;\n                        done = true;\n                    }\n                    \n                    safety++;\n                }\n                return xn;\n            };\n            return newtonraph( Number( guess ) );\n        },\n        quad: function(a, b, c) {\n            var q = function(a, b, c, sign) {\n                return _.parse('-('+b+'+'+sign+'*sqrt(('+b+')^2-4*('+a+')*('+c+')))/(2*'+a+')');\n            };\n            return [q(a, b, c, 1), q(a, b, c, -1)];\n        },\n        sumProd: function(a, b) {\n            return __.quad(-b, a, -1).map(function(x){\n                return x.invert(); \n            });\n        },\n        coeffs: function(symbol, wrt, coeffs) {\n            wrt = String(wrt); \n            symbol = _.expand(symbol);\n            coeffs = coeffs || [new Symbol(0)];\n            //we cannot get coeffs for group EX\n            if(symbol.group === EX && symbol.contains(wrt, true))\n                _.error('Unable to get coefficients using expression '+symbol.toString());\n            var vars = variables(symbol);\n            if(vars.length <=1 && vars[0] === wrt) {\n                var a = new Polynomial(symbol).coeffs.map(function(x) {\n                    return new Symbol(x);\n                });\n                for(var i=0,l=a.length;i<l; i++)  {\n                    var coeff = a[i],\n                        e = coeffs[i]; \n                    if(e)\n                        coeff = _.add(e, coeff);\n                    coeffs[i] = coeff; //transfer it all over\n                }\n            }\n            else { \n                if(!wrt)\n                    _.error('Polynomial contains more than one variable. Please specify which variable is to be used!');\n                //if the variable isn't part of this polynomial then we're looking at x^0\n                \n                if(vars.indexOf(wrt) === -1) {\n                    coeffs[0] = _.add(symbol, coeffs[0]);\n                }\n                else {\n                    coeffs = coeffs || [new Symbol(0)];\n                    if(symbol.group === CB) {\n                        var s = symbol.symbols[wrt];\n                        if(!s)\n                            _.error('Expression is not a polynomial!');\n                        var p = Number(s.power);\n                        coeff = _.divide(symbol.clone(), s.clone());\n                        if(coeff.contains(wrt, true) || p < 0 || !isInt(p))\n                            _.error('Expression is not a polynomial!');\n                        var e = coeffs[p];\n                        if(e)\n                            coeff = _.add(e, coeff);\n                        coeffs[p] = coeff;\n                    }\n                    else if(symbol.group === CP) {\n                        symbol.each(function(x) {\n                           __.coeffs(x.clone(), wrt, coeffs);\n                        }, true);\n                    }\n                }\n            }\n            //fill holes\n            for(var i=0,l=coeffs.length; i<l; i++) \n                if(typeof coeffs[i] === 'undefined')\n                    coeffs[i] = new Symbol(0);\n\n            return coeffs;    \n        },\n        /**\n         * Get's all the powers of a particular polynomial including the denominators. The denominators powers\n         * are returned as negative. All remaining polynomials are returned as zero order polynomials.\n         * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\n         * @param {Symbol} e\n         * @param {String} for_variable\n         * @param {Array} powers\n         * @returns {Array} An array of the powers\n         */\n        //assumes you've already verified that it's a polynomial\n        polyPowers: function(e, for_variable, powers) { \n            powers = powers || [];\n            var g = g = e.group; \n            if(g ===  PL && for_variable === e.value) {\n                powers = powers.concat(keys(e.symbols)); \n            }\n            else if(g === CP) { \n                for(var s in e.symbols) {\n                    var symbol = e.symbols[s]; \n                    var g = symbol.group, v = symbol.value; \n                    if(g === S && for_variable === v) powers.push(symbol.power);\n                    else if(g === PL || g === CP) powers = __.polyPowers(symbol, for_variable, powers);\n                    else if(g === CB && symbol.contains(for_variable)) {\n                        var t = symbol.symbols[for_variable];\n                        if(t) powers.push((t.power));\n                    }\n                    else if(g === N || for_variable !== v) powers.push(0);\n                }\n            }\n            else if(g === CB && e.contains(for_variable)) {\n                powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\n            }\n            return core.Utils.arrayUnique(powers).sort();\n        },\n        //The factor object\n        Factor: {\n            //splits the symbol in symbol and constant\n            split: function(symbol) {\n                var c = new Symbol(1); //the constants part\n                var s = new Symbol(1); //the symbolic part\n                __.Factor.factor(symbol, new Factors()).each(function(x) {\n                    var t = _.parse(x);\n                    if(x.isConstant(true)) {\n                        c = _.multiply(c, t);\n                    }\n                    else {\n                        s = _.multiply(s, t);\n                    }\n                });\n                return [c, s];\n            },\n            mix: function(o, include_negatives) {\n                var factors = keys(o);\n                var l = factors.length;\n                var m = [];//create a row which we'r going to be mixing\n                for(var i=0; i<l; i++) {\n                    var factor = factors[i],\n                        p = o[factor];\n                    var ll = m.length;\n                    for(var j=0; j<ll; j++) {\n                        var t = m[j]*factor;\n                        m.push(t);\n                        if(include_negatives) m.push(-t);\n                    }\n \n                    for(var j=1; j<=p; j++)\n                        m.push(Math.pow(factor, j));\n                }\n                return m;\n            },\n            //TODO: this method is to replace common factoring\n            common: function(symbol, factors) {\n                try {\n                    if(symbol.group === CP) { \n                        //this may have the unfortunate side effect of expanding and factoring again\n                        //to only end up with the same result. \n                        //TODO: try to avoid this\n                        //collect the symbols and sort to have the longest first. Thinking is that the longest terms \n                        //has to contain the variable in order for it to be factorable\n                        var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function(a, b) {\n                            return (b.length || 1) - (a.length || 1);\n                        });\n                        \n                        var map = {}; //create a map of common factors\n                        var coeffs = [];\n                        for(var i=0; i<symbols.length; i++) {\n                            var sym = symbols[i]; \n                            coeffs.push(sym.multiplier.clone());\n                            sym.each(function(x) {\n                                var p = Number(x.power);\n                                //This check exits since we have a symbolic power.\n                                //For the future... think about removing this check and modify for symbolic powers\n                                if(isNaN(p))\n                                    throw new Error('exiting');\n                                //loop through the symbols and lump together common terms\n                                if(x.value in map) {\n                                    if(p < map[x.value][0])\n                                        map[x.value][0] = p;\n                                    map[x.value][1].push(x);\n                                }\n                                else\n                                    map[x.value] = [p, [x]];\n                            });\n                        }\n                        //the factor\n                        var factor = new Symbol(1);\n                        for(var x in map) {\n                            //if this factor is found in all terms since the length of \n                            //matching variable terms matches the number of original terms\n                            if(map[x][1].length === symbols.length) {\n                                //generate a symbol and multiply into the factor\n                                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\n                            }\n                        }\n                        //get coefficient factor\n                        var c = core.Math2.QGCD.apply(null, coeffs);\n\n                        if(!c.equals(1)) {\n                            factors.add(new Symbol(c));\n                            for(var i=0; i<symbols.length; i++) {\n                                symbols[i].multiplier = symbols[i].multiplier.divide(c);\n                            }\n                        }\n                            \n                        //if we actuall found any factors\n                        if(!factor.equals(1)) { \n                            factors.add(factor);\n                            symbol = new Symbol(0);\n                            for(var i=0; i<symbols.length; i++) {\n                                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\n                            }\n                        }\n                    }\n                }\n                catch(e){;}\n\n                return symbol;\n            },\n            zeroes: function(symbol, factors) {\n                var exit = function() {\n                    throw new core.exceptions.ValueLimitExceededError('Exiting');\n                };\n                try {\n                    var vars, term, sum, p, e;\n                    symbol = _.expand(symbol.clone());\n                    e = symbol.toString();\n                    vars = variables(symbol);\n\n                    sum = new Symbol(0);\n                    \n                    var terms = [];\n                    var powers = [];\n                    \n                    //start setting each variable to zero\n                    for(var i=0, l=vars.length; i<vars.length; i++) {\n                        var subs = {};\n                        //we want to create a subs object with all but the current variable set to zero\n                        for(var j=0; j<l; j++) \n                            if(i !== j) //make sure we're not looking at the same variable\n                                subs[vars[j]] = 0;\n                        term = _.parse(e, subs);\n                        var tp = term.power;\n                        //the temporary power has to be an integer as well\n                        if(!isInt(tp))\n                            exit();\n                        terms.push(term);\n                        powers.push(term.power);\n                    }\n\n                    //get the gcd. This will be the p in (a^n+b^m)^p\n                    //if the gcd equals 1 meaning n = m then we need a tie breakder\n                    if(core.Utils.allSame(powers)) { \n                        //get p given x number of terms\n                        var n_terms = symbol.length;\n                        //the number of zeroes determines\n                        var n_zeroes = terms.length;\n                        if(n_zeroes === 2) {\n                            p = new Frac(powers[0]/(n_terms-1));\n                        }\n                        if(n_zeroes === 3) {\n                            p = new Frac(powers[0]/Math.round((Math.sqrt(8*n_terms-1)-3)/2));\n                        }\n                        /*\n                        //get the lowest possible power\n                        //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\n                        symbol.each(function(x) {\n                            if(x.group === CB)\n                                x.each(function(y) {\n                                    if(!p || y.power.lessThan(p))\n                                        //p = Number(y.power);\n                                        p = y.power;\n                                });\n                            else if(!p || x.power.lessThan(p))\n                                //p = Number(x.power);\n                                p = x.power;\n                        });\n                        */\n                    }\n                    else\n                        //p is just the gcd of the powers\n                        p = core.Math2.QGCD.apply(null, powers);\n\n                    //if we don't have an integer then exit\n                    if(!isInt(p))\n                        exit();\n\n                    //build the factor\n                    for(var i=0; i<terms.length; i++) {\n                        var t = terms[i];\n                        var n = t.power.clone().divide(p);\n                        t.multiplier = new Frac(Math.pow(t.multiplier, 1/n));\n                        t.power = p.clone();\n                        sum = _.add(sum, t);\n                    }\n\n                    //by now we have the factor of zeroes. We'll know if we got it right because \n                    //we'll get a remainder of zero each time we divide by it\n                    if(sum.group !== CP)\n                        return symbol; //nothing to do\n\n                    while(true) {\n                        var d = __.div(symbol.clone(), sum.clone());\n                        if(d[1].equals(0)) {\n                            symbol = d[0];\n                            factors.add(sum.clone());\n                            if(symbol.equals(1)) //we've reached 1 so done.\n                                break;\n                        }\n                        else\n                            break;\n                    }\n                }\n                catch(e){};\n                \n                return symbol;\n            },\n            factor: function(symbol, factors) {\n                var _symbol = _.parse(symbol);\n                var retval = __.Factor._factor(_symbol, factors);\n                \n                if(retval.equals(symbol)) {\n                    return retval;\n                }\n                \n                if(retval.group === CB) {\n                    var t = new Symbol(1);\n                    var p = _.parse(retval.power);\n                    //store the multiplier and strip it\n                    var m = _.parse(retval.multiplier);\n                    \n                    retval.toUnitMultiplier();\n                    /* \n                     * NOTE: for sign issues with factor START DEBUGGING HERE\n                     */\n                    //move the sign to t\n                    if(retval.multiplier.lessThan(0)) {\n                        t.negate();\n                        retval.negate();\n                    }\n                    retval.each(function(x) {\n                        var factored = __.Factor._factor(x);\n                        \n                        if(factored.group === CB) {\n                            factored.each(function(y) {\n                                var _factored = __.Factor._factor(y);\n                                t = _.multiply(t, _factored);\n                            });\n                        }\n                        else {\n                            t = _.multiply(t, factored);\n                        }\n                    });\n                    //put back the multiplier and power\n                    retval = _.pow(_.multiply(m, t), p);\n                }  \n                \n                return retval;\n            },\n            quadFactor: function(symbol, factors) {\n                if(symbol.isPoly() && __.degree(symbol.equals(2))) {\n                    //We've  already checked that we're dealing with a polynomial\n                    var v = core.Utils.variables(symbol)[0]; //get the variable\n                    var coeffs = __.coeffs(symbol, v);\n                    //factor the lead coefficient\n                    var cf = __.Factor._factor(coeffs[2].clone());\n                    //check if we have factors\n                    if(cf.group === CB) {\n                        var symbols = cf.collectSymbols();\n                        //if the factors are greater than 2 we're done so exit\n                        if(symbols.length > 2)\n                            return symbol; \n                        //if we have two factors then attempt to factor the polynomial\n                        //let the factors be f1 and f1\n                        //let the factors be (ax+b)(cx+d)\n                        //let the coefficients be c1x^2+c2x+c3\n                        //then a(x1)+c(x2)=c2 and x1*x2=c3\n                        //we can solve for x1 and x2\n                        var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\n                        var b = _.parse(coeffs[1]).negate();\n                        var a = _.parse(symbols[1]);\n                        //solve the system\n                        var root = __.quad(a, b, c).filter(function(x) {\n                            if(core.Utils.isInt(x))\n                                return x;\n                        });\n                        //if we have one root then find the other one by dividing the constant\n                        if(root.length === 1) {\n                            var root1 = root[0];\n                            var root2 = _.divide(coeffs[0], _.parse(root1));\n                            if(core.Utils.isInt(root2)) {\n                                //we found them both\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\n                                symbol = new Symbol(1);\n                            }\n                        }\n                    }\n                }\n                return symbol;    \n            },\n            _factor: function(symbol, factors) {\n                //some items cannot be factored any further so return those right away\n                if(symbol.group === FN) {\n                    var arg = symbol.args[0];\n                    if(arg.group === S && arg.isSimple())\n                        return symbol;\n                }\n                else if(symbol.group === S && symbol.isSimple())\n                    return symbol;\n                \n                //expand the symbol to get it in a predictable form. If this step\n                //is skipped some factors are missed.\n                if(symbol.group === CP) {\n                    symbol.distributeMultiplier();\n                    var t = new Symbol(0);\n                    symbol.each(function(x) {\n                        if((x.group === CP && x.power.greaterThan(1) || x.group === CB))\n                            x = _.expand(x);\n                        t = _.add(t, x);\n                    });\n                    t.power = symbol.power;\n                    \n                    symbol = t;\n                }\n                \n                if(symbol.group === FN && symbol.fname !== 'sqrt')\n                    symbol = core.Utils.evaluate(symbol);\n                //make a copy of the symbol to return if something goes wrong\n                var untouched = symbol.clone();\n                try {\n                    if(symbol.group === CB) {\n                        var p = _.parse(symbol.power);\n                        \n                        var den_array, num_array, den, num, dfact, nfact;\n                        //grab the denominator and strip the multiplier and power. Store them in an array\n                        den_array = __.Simplify.strip(symbol.getDenom());\n                        num_array = __.Simplify.strip(symbol.getNum());\n                        \n                        den = den_array.pop();\n                        num = num_array.pop();\n                        \n                        //if the numerator equals the symbol then we've hit the simplest form and then we're done\n                        if(num.equals(symbol))\n                            return symbol;\n                        nfact = __.Factor.factor(num);\n                        dfact = __.Factor.factor(den);\n\n                        var n = __.Simplify.unstrip(num_array, nfact);\n                        var d = __.Simplify.unstrip(den_array, dfact);\n \n                        var retval = _.divide(n, d);\n\n                        return retval;\n                    }\n                    if(symbol.group === S) \n                        return symbol; //absolutely nothing to do\n\n                    if(symbol.isConstant()) {\n                        if(symbol.equals(1))\n                            return symbol.clone();\n                        var ret = core.Math2.factor(symbol);\n                        return ret;\n                    }\n\n                    var p = symbol.power.clone();\n                    \n                    if(isInt(p) && !(p.lessThan(0) && symbol.group === FN)) { \n                        var sign = p.sign();\n                        symbol.toLinear();\n                        factors = factors || new Factors();\n                        var map = {};\n                        symbol = _.parse(core.Utils.subFunctions(symbol, map));\n                        if(keys(map).length > 0) { //it might have functions\n                            factors.preAdd = function(factor) {\n                                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\n                                return ret;\n                            };\n                        }\n\n                        //strip the power\n                        if(!symbol.isLinear()) {\n                            factors.pFactor = symbol.power.toString();\n                            symbol.toLinear();\n                        } \n                        \n                        var vars = variables(symbol);\n                        //bypass for imaginary. TODO: find a better solution\n                        if(symbol.isImaginary()) {\n                            vars.push(core.Settings.IMAGINARY);\n                        }\n                        var multiVar = vars.length > 1;\n                        \n                        //minor optimization. Seems to cut factor time by half in some cases.\n                        if(multiVar) { \n                            var all_S = true, all_unit = true;\n                            symbol.each(function(x) {\n                                if(x.group !== S) all_S = false;\n                                if(!x.multiplier.equals(1)) all_unit = false;\n                            });       \n                            if(all_S && all_unit) {\n                                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\n                            }\n                        }\n                        //factor the coefficients\n                        var coeff_factors = new Factors();\n                        \n                        symbol = __.Factor.coeffFactor(symbol, coeff_factors);\n                        \n                        coeff_factors.each(function(x) {\n                            if(sign < 0)\n                                x.invert();\n                            factors.add(x);\n                        });\n                        //factor the power\n                        var power_factors = new Factors();\n                        symbol = __.Factor.powerFactor(symbol, power_factors);  \n                        power_factors.each(function(x) {\n                            if(sign < 0)\n                                x.invert();\n                            factors.add(x);\n                        });\n                        \n                        if(!multiVar) { \n                            //pass in vars[0] for safety\n                            var v = vars[0];\n                            symbol = __.Factor.squareFree(symbol, factors, v);\n                            \n                            var t_factors = new Factors();\n                            symbol = __.Factor.trialAndError(symbol, t_factors, v);\n                            \n                            //generate a symbol based off the last factors\n                            var tf_symbol = t_factors.toSymbol();\n                            //if nothing was factored then return the factors\n                            if(tf_symbol.equals(untouched))\n                                return tf_symbol;\n                            for(var x in t_factors.factors) {\n                                //store the current factor in t_factor\n                                var t_factor = t_factors.factors[x];\n                                factors.add(_.pow(t_factor, _.parse(p)));\n                            }\n                            //if we still don't have a factor and it's quadratic then let's just do a quad factor\n                            if(symbol.equals(untouched))\n                                symbol = __.Factor.quadFactor(symbol, factors);\n                           \n                        }\n                        else {\n                            symbol = __.Factor.mfactor(symbol, factors);\n                            \n                            //put back the sign of power\n                            factors.each(function(x) {\n                                if(sign < 0)\n                                    x.power.negate();\n                            });\n                        }\n                        \n                        //last minute clean up\n                        symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\n                        factors.add(_.pow(symbol, _.parse(p)));\n                        \n                        var retval = factors.toSymbol();\n                        return retval;\n                    }\n                    \n                    return symbol;    \n                }\n                catch(e) {\n                    //no need to stop the show because something went wrong :). Just return the unfactored.\n                    return untouched;\n                }\n            },\n            reduce: function(symbol, factors) {\n                if(symbol.group === CP && symbol.length === 2) {\n                    var symbols = symbol.collectSymbols().sort(function(a, b) {\n                        return b.multiplier - a.multiplier;\n                    });\n                    if(symbols[0].power.equals(symbols[1].power)) {\n                        //x^n-a^n\n                        var n = _.parse(symbols[0].power),\n                            a = symbols[0].clone().toLinear(),\n                            b = symbols[1].clone().toLinear();\n                    \n                        //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\n                        factors.add(_.add(a.clone(), b.clone()));\n                        //flip the sign\n                        b.negate();\n                        //turn n into a number\n                        var nn = Number(n);\n                        //the remainder\n                        var result = new Symbol(0);\n                        for(var i=1; i<=nn; i++) {\n                            var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\n                                bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\n                            result = _.add(result, _.multiply(aa, bb));\n                        }\n                        return result;\n                    }\n                }\n                return symbol;\n            },\n            /**\n             * Makes Symbol square free\n             * @param {Symbol} symbol\n             * @param {Factors} factors\n             * @@param {String} variable The variable which is being factored \n             * @returns {[Symbol, Factor]}\n             */\n            squareFree: function(symbol, factors, variable) {\n                if(symbol.isConstant() || symbol.group === S) return symbol;\n                var poly = new Polynomial(symbol, variable);\n                var sqfr = poly.squareFree();\n                var p = sqfr[2];\n                //if we found a square then the p entry in the array will be non-unit\n                if(p !== 1) {\n                    //make sure the remainder doesn't have factors\n                    var t = sqfr[1].toSymbol();\n                    t.power = t.power.multiply(new Frac(p));\n                    //send the factor to be fatored to be sure it's completely factored\n                    factors.add(__.Factor.factor(t));\n                    return __.Factor.squareFree(sqfr[0].toSymbol(), factors);\n                }\n                return symbol;\n            },\n            /**\n             * Factors the powers such that the lowest power is a constant\n             * @param {Symbol} symbol\n             * @param {Factors} factors\n             * @returns {[Symbol, Factor]}\n             */\n            powerFactor: function(symbol, factors) {\n                //only PL need apply\n                if(symbol.group !== PL || symbol.previousGroup === EX) \n                    return symbol; \n                var k = keys(symbol.symbols);\n                //we expect only numeric powers so return all else\n                if(!core.Utils.allNumeric(k))\n                    return symbol;\n                \n                var d = core.Utils.arrayMin(k);\n                var retval = new Symbol(0);\n                var q = _.parse(symbol.value+'^'+d);\n                symbol.each(function(x) {\n                    x = _.divide(x, q.clone());\n                    retval = _.add(retval, x);\n                });\n\n                factors.add(q);\n                return retval;\n            },\n            /**\n             * Removes GCD from coefficients\n             * @param {Symbol} symbol\n             * @param {Factor} factors\n             * @returns {Symbol}\n             */\n            coeffFactor: function(symbol, factors) {\n                if(symbol.isComposite()) {\n                    var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\n                    if(!gcd.equals(1)) { \n                        symbol.each(function(x) {\n                            if(x.isComposite()) {\n                                x.each(function(y){\n                                    y.multiplier = y.multiplier.divide(gcd);\n                                });\n                            }\n                            else x.multiplier = x.multiplier.divide(gcd);\n                        });\n                        \n                    }\n                    symbol.updateHash();\n                    if(factors) \n                        factors.add(new Symbol(gcd));\n                }\n                \n                return symbol;\n            },\n            /**\n             * The name says it all :)\n             * @param {Symbol} symbol\n             * @param {Factor} factors\n             * @@param {String} variable \n             * @returns {Symbol}\n             */\n            trialAndError: function(symbol, factors, variable) {\n                if(symbol.isConstant() || symbol.group === S) return symbol;\n                var poly = new Polynomial(symbol, variable),\n                    cnst = poly.coeffs[0],\n                    cfactors = core.Math2.ifactor(cnst),\n                    roots = __.proots(symbol); \n                for(var i=0; i<roots.length; i++) {\n                    var r = roots[i],\n                        p = 1;\n                    if(!isNaN(r)) { //if it's a number\n                        for(var x in cfactors) {\n                            //check it's raised to a power\n                            var n = core.Utils.round(Math.log(x)/Math.log(Math.abs(r)), 8);\n                            if(isInt(n)) {\n                                r = x; //x must be the root since n gave us a whole\n                                p = n; break;\n                            }\n                        }\n                        var root = new Frac(r),\n                            terms = [new Frac(root.num).negate()];\n                        terms[p] = new Frac(root.den);\n                            //convert to Frac. The den is coeff of LT and the num is coeff of constant\n                        var div = Polynomial.fromArray(terms, poly.variable).fill(),\n                            t = poly.divide(div);\n                        if(t[1].equalsNumber(0)) { //if it's zero we have a root and divide it out\n                            poly = t[0];\n                            factors.add(div.toSymbol());\n                        }\n                    }\n                }\n                \n                if(!poly.equalsNumber(1)) {\n                    poly = __.Factor.search(poly, factors);\n                }\n\n                return poly.toSymbol();\n            },\n            search: function(poly, factors, base) {\n                base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\n                var v = poly.variable; //the polynmial variable name\n                /**\n                 * Attempt to remove a root by division given a number by first creating\n                 * a polynomial fromt he given information\n                 * @param {int} c1 - coeffient for the constant\n                 * @param {int} c2 - coefficient for the LT\n                 * @param {int} n - the number to be used to construct the polynomial\n                 * @param {int} p - the power at which to create the polynomial\n                 * @returns {null|Polynomial} - returns polynomial if successful otherwise null\n                 */\n                var check = function(c1, c2, n, p) {\n                    var candidate = Polynomial.fit(c1, c2, n, base, p, v);\n                    if(candidate && candidate.coeffs.length > 1) {\n                        var t = poly.divide(candidate);\n                        if(t[1].equalsNumber(0)) {\n                            factors.add(candidate.toSymbol());\n                            return [t[0], candidate];\n                        }\n                    }\n                    return null;\n                };\n                var cnst = poly.coeffs[0];\n                var cfactors = core.Math2.ifactor(cnst);\n                var lc = poly.lc();\n                var ltfactors = core.Math2.ifactor(lc);\n                var subbed = poly.sub(base);\n                var isubbed = core.Math2.ifactor(subbed);\n                var nfactors = __.Factor.mix(isubbed, subbed < 0);\n                var cp = Math.ceil(poly.coeffs.length/2);\n                var lc_is_neg = lc.lessThan(0);\n                var cnst_is_neg = cnst.lessThan(0);\n                ltfactors['1'] = 1;\n                cfactors['1'] = 1;\n                while(cp--) {\n                    for(var x in ltfactors) {\n                        for(var y in cfactors) {\n                            for(var i=0; i<nfactors.length; i++) {\n                                var factor_found = check(x, y, nfactors[i], cp);\n                                if(factor_found) {\n                                    poly = factor_found[0];\n                                    if(!core.Utils.isPrime(poly.sub(base)))\n                                        poly = __.Factor.search(poly, factors);\n                                    return poly;\n                                }\n                                else if(!factor_found) {\n                                    if(lc_is_neg && cnst_is_neg)\n                                        factor_found = check(-x, -y, nfactors[i], cp);\n                                    else if(lc_is_neg) \n                                        factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\n                                    else if(cnst_is_neg) \n                                        factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\n                                }\n                            }\n                        }\n                    }\n                }\n                return poly;\n            },\n            /**\n             * Equivalent of square free factor for multivariate polynomials\n             * @param {type} symbol\n             * @param {type} factors\n             * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\n             */\n            mSqfrFactor: function(symbol, factors) {\n                if(symbol.group !== FN) {\n                    var vars = variables(symbol).reverse();\n                    for(var i=0; i<vars.length; i++) {\n                        do {\n                            if(vars[i] === symbol.value){\n                                //the derivative tells us nothing since this symbol is already the factor\n                                factors.add(symbol);\n                                symbol = new Symbol(1);\n                                continue;\n                            }\n                            var diff = core.Calculus.diff(symbol, vars[i]);\n                            var d = __.Factor.coeffFactor(diff);\n\n                            if(d.equals(0)) \n                                break;\n                            \n                            //trial division to see if factors have whole numbers. \n                            //This can be optimized by stopping as soon as can_divide is false\n                            //this will also need utilize big number at some point\n                            var can_divide = true;\n                            if(d.isConstant() && symbol.isComposite()) {\n                                //check the coefficients\n                                \n                                symbol.each(function(x) {\n                                    if(x.multiplier % d !== 0)\n                                        can_divide = false;\n                                }, true);\n                            }\n                            \n                            //if we can divide then do so\n                            if(can_divide) {\n                                var div = __.div(symbol, d.clone()),\n                                is_factor = div[1].equals(0);\n\n                                if(div[0].isConstant()) {\n                                    factors.add(div[0]);\n                                    break;\n                                }\n                            }\n                            else\n                                is_factor = false;\n                                \n                            if(is_factor) {\n                                factors.add(div[0]);\n                                symbol = d;\n                            }\n                        }\n                        while(is_factor)\n                    }\n                }\n                \n                return symbol;\n            },\n            //difference of squares factorization\n            sqdiff: function(symbol, factors) { \n                try {\n                    var remove_square = function(x) {\n                        return core.Utils.block('POSITIVE_MULTIPLIERS', function() {\n                            return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\n                        }, true);\n                    }; \n                    var separated = core.Utils.separate(symbol.clone());\n                    var obj_array = [];\n                    //get the unique variables\n                    for(var x in separated) {\n                        if(x !== 'constants') {\n                            obj_array.push(separated[x]);\n                        }\n                    }\n                    obj_array.sort(function(a, b) {\n                        return b.power - a.power;\n                    });\n\n                    //if we have the same number of variables as unique variables then we can apply the difference of squares\n                    if(obj_array.length === 2) { \n                        var a, b;\n                        a = obj_array.pop();\n                        b = obj_array.pop();\n                        if(a.isComposite() && b.power.equals(2)) {\n                            //remove the square from b\n                            b = remove_square(b);\n                            var f = __.Factor.factor(_.add(a, separated.constants));\n                            if(f.power.equals(2)) {\n                                f.toLinear();\n                                factors.add(_.subtract(f.clone(), b.clone()));\n                                factors.add(_.add(f, b));\n                                symbol = new Symbol(1);\n                            }\n                        }\n                        else {\n                            a = a.powSimp();\n                            b = b.powSimp();\n                            \n                            if((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2)) {\n                                if(a.multiplier.lessThan(0)) {\n                                    var t = b; b = a; a = t;\n                                }\n                                if(a.multiplier.greaterThan(0)) {\n                                    a = remove_square(a);\n                                    b = remove_square(b);\n                                }\n                                factors.add(_.subtract(a.clone(), b.clone()));\n                                factors.add(_.add(a, b));\n                                symbol = new Symbol(1);\n                            }\n                        }\n                    }\n                }\n                catch(e){;}\n                \n                return symbol;\n            },\n            //factoring for multivariate\n            mfactor: function(symbol, factors) {  \n                \n                if(symbol.group === FN) { \n                    if(symbol.fname === 'sqrt') {\n                        var factors2 = new Factors(),\n                            arg = __.Factor.common(symbol.args[0].clone(), factors2);\n                        arg = __.Factor.coeffFactor(arg, factors2);\n                        symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\n                        factors2.each(function(x) {\n                            symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\n                        });\n                    }\n                    else\n                        factors.add(symbol);\n                    \n                }\n                else { \n                    //square free factorization\n                    symbol = __.Factor.mSqfrFactor(symbol, factors);\n                    \n                    //try factor out common factors\n                    //symbol = __.Factor.common(symbol, factors);\n                    \n                    var vars = variables(symbol),\n                        symbols = symbol.collectSymbols().map(function(x) {\n                            return Symbol.unwrapSQRT(x);\n                        }),\n                        sorted = {},\n                        maxes = {},\n                        l = vars.length, n = symbols.length;\n                    //take all the variables in the symbol and organize by variable name\n                    //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\n                    \n                    for(var i=0; i<l; i++) {\n                        var v = vars[i];\n                        sorted[v] = new Symbol(0);\n                        for(var j=0; j<n; j++) {\n                            var s = symbols[j];\n                            if(s.contains(v)) {\n                                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\n                                if(!maxes[v] || p < maxes[v]) maxes[v] = p;\n                                sorted[v] = _.add(sorted[v], s.clone());\n                            }\n                        }\n                    }\n                    \n                    for(var x in sorted) {\n                        var r = _.parse(x+'^'+maxes[x]); \n                        var div = _.divide(sorted[x], r);\n                        var new_factor = _.expand(div); \n                        \n                        if(new_factor.equals(1))\n                            break; //why divide by one. Just move \n                        var divided = __.div(symbol.clone(), new_factor); \n                        if(divided[0].equals(0)) { \n                            //cant factor anymore\n                            break;\n                        }\n                        \n                        var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\n                        \n                        if(divided[1].equals(0) && !neg_numeric_factor) { //we found at least one factor\n                            \n                            //factors.add(new_factor);\n                            var d = __.div(symbol.clone(), divided[0].clone());\n                            var r = d[0];\n                            symbol = d[1];\n                            //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\n                            //and we just return the symbol;\n                            //If r equals zero then there's nothing left to do so we're done\n                            \n                            if(r.equals(-1) && !symbol.equals(0))\n                                return symbol;\n\n                            var factor = divided[0]; \n                            if(symbol.equals(factor)) {\n                                var rem = __.Factor.reduce(factor, factors);\n                                \n                                if(!symbol.equals(rem)) \n                                    return __.Factor.mfactor(rem, factors);\n                            }\n                            else {\n                                factors.add(factor); \n                                //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\n                                if(symbol.equals(0))\n                                    return r;\n                            }\n                            \n                            if(r.isConstant('all')) { \n                                factors.add(r);\n                                return r;\n                            }\n                            \n                            return __.Factor.mfactor(r, factors);\n                        }\n                    }\n                    \n                }\n                \n                //difference of squares factorization\n                symbol = __.Factor.sqdiff(symbol, factors);\n                //factors by fishing for zeroes\n                symbol = __.Factor.zeroes(symbol, factors);\n                \n                return symbol;\n            }\n        },\n        /**\n         * Checks to see if a set of \"equations\" is linear. \n         * @param {type} set\n         * @returns {Boolean}\n         */\n        allLinear: function(set) {\n            var l = set.length;\n            for(var i=0; i<l; i++) {\n                if(!__.isLinear(set[i])) return false;\n            }\n            return true;\n        },\n        /*\n         * Checks to see if the \"equation\" is linear\n         * @param {Symbol} e\n         * @returns {boolean}\n         */\n        isLinear: function(e) {\n            var status = false, g = e.group;\n            if(g === PL || g === CP) {\n                status = true;\n                for(var s in e.symbols) {\n                    var symbol = e.symbols[s], sg = symbol.group;\n                    if(sg === FN || sg === EX) { \n                        status = false;\n                    }\n                    if(sg === CB) {\n                        //needs further checking since it might be imaginary\n                        status = variables(symbol).length === 1;\n                    }\n                    else {\n                        if(sg === PL || sg === CP) status = __.isLinear(symbol);\n                        else {\n                            if(symbol.group !== N && symbol.power.toString() !== '1') { status = false; break; }\n                        }\n                    }\n                }\n            }\n            else if(g === S && e.power === 1) status = true;\n            return status;\n        },\n        gcd: function() {\n            var args;\n            if(arguments.length === 1 && arguments[0] instanceof core.Vector)\n                args = arguments[0].elements;\n            else args = core.Utils.arguments2Array(arguments);\n            \n            //short-circuit early\n            if (args.length === 0) \n                return new Symbol(1);\n            else if (args.length === 1) \n                return args[0];\n            \n            var appeared = [], evaluate = false;\n            for(var i = 0; i < args.length; i++) {\n                if(args[i].group === FN && args[i].fname === 'gcd')\n                {\n                    //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\n                    args = args.concat(arguments[i].args);\n                    //do not keep gcd in args\n                    args.splice(i, 1);\n                }\n                else\n                {\n                    //Look if there are any common variables such that\n                    //gcd(a,b) => gcd(a,b); gcd(a,a) => a\n                    var vars = variables(args[i]);\n                    if(core.Utils.haveIntersection(vars, appeared))\n                    {\n                        //Ok, there are common variables\n                        evaluate = true;\n                        break;\n                    }\n                    else appeared = appeared.concat(vars);\n                }\n            }\n            \n            //appeared.length is 0 when all arguments are group N\n            if (evaluate || appeared.length === 0) {\n                //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\n                if(args.every(function(symbol){return symbol.getDenom().equals(1)})) {\n                    var aggregate = args[0];\n                    \n                    for(var i = 1; i < args.length; i++) {\n                        aggregate = __.gcd_(args[i], aggregate);\n                    }\n                    return aggregate;\n                }\n                else {\n                    //gcd_ cannot handle denominators correctly\n                    return _.divide(__.gcd.apply(null, args.map(function(symbol){return symbol.getNum(); })),\n                                    __.lcm.apply(null, args.map(function(symbol){return symbol.getDenom(); })));\n                }\n            }\n            else return _.symfunction('gcd', args);\n        },\n        gcd_: function(a, b) { \n            if(a.group === FN || a.group === P)\n                a = core.Utils.block('PARSE2NUMBER', function() {\n                   return _.parse(a); \n                });\n\t\t\n            if(b.group === FN)\n                b = core.Utils.block('PARSE2NUMBER', function() {\n                   return _.parse(b); \n                });\n\t\t\n            if(a.isConstant() && b.isConstant()) { \n                // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\n                return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\n            }\n\n            var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\n            a = _.multiply(a.clone(), den.clone());\n            b = _.multiply(b.clone(), den.clone());\n\t\t\n            //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\n            a = _.expand(a);\n            b = _.expand(b);\n\n            if(a.group === CB || b.group === CB) {\n                var q = _.divide(a.clone(), b.clone()); //get the quotient\n                var t = _.multiply(b.clone(), q.getDenom().invert());//multiply by the denominator\n                //if they have a common factor then the result will not equal one \n                if(!t.equals(1))\n                    return t;\n            }\n            \n            //just take the gcd of each component when either of them is in group EX\n            if(a.group === EX || b.group === EX)\n            {\n                var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\n                var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\n                var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\n                return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\n            }\n            \t\t  \n            if(a.length < b.length) { //swap'm\n                var t = a; a = b; b = t;\n            }\n            var vars_a = variables(a), vars_b = variables(b);\n            if((vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0]) \n                    || vars_a.length === 1 && vars_b.length === 0 \n                    || vars_a.length === 0 && vars_b.length === 1) {\n                a = new Polynomial(a); b = new Polynomial(b);\n                return _.divide(a.gcd(b).toSymbol(), den);\n            }\n            else { \n                //get the gcd of the multipiers\n                //get rid of gcd in coeffs\n                var multipliers = [];\n                a.each(function(x) {\n                    multipliers.push(x.multiplier);\n                });\n                b.each(function(x) {\n                    multipliers.push(x.multiplier);\n                });\n                \n                var T;\n                while(!b.equals(0)) {  \n                    var t = b.clone(); \n                    a = a.clone(); \n                    T = __.div(a, t);\n                    \n                    b = T[1]; \n                    if(T[0].equals(0)) {\n                        //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\n                        return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\n                    }\n                    a = t; \n                }\n                \n                var gcd = core.Math2.QGCD.apply(undefined, multipliers);\n\n                if(!gcd.equals(1)) {\n                    a.each(function(x) {\n                        x.multiplier = x.multiplier.divide(gcd);\n                    });\n                }\n                \n                //return symbolic function for gcd in indeterminate form\n                if(a.equals(1) && !a.isConstant() && !b.isConstant())\n                    return _.divide(_.symfunction('gcd', arguments), den);\n                \n                return _.divide(a, den);\n            }\n        },\n        lcm: function() { \n            //https://math.stackexchange.com/a/319310\n            //generalization of the 2-variable formula of lcm\n            \n            var args;\n            if(arguments.length === 1)\n                if (arguments[0] instanceof core.Vector) args = arguments[0].elements;\n                else _.error('lcm expects either 1 vector or 2 or more arguments');\n            else args = core.Utils.arguments2Array(arguments);\n\n            //product of all arguments\n            //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n            var numer = args.reduce(function(prev,curr){return _.multiply(prev, curr.clone())}, new Symbol(1));\n            \n            //gcd of complementary terms\n            var denom_args = \n                //https://stackoverflow.com/a/18223072\n                //take all complementary terms, e.g.\n                //[a,b,c] => [a*b, b*c, a*c]\n                //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\n                (function(input, size) {\n                    var results = [], result, mask, i, total = Math.pow(2, input.length);\n                    for (mask = size; mask < total; mask++) {\n                        result = [];\n                        i = input.length - 1;\n\n                        do {\n                            if ((mask & (1 << i)) !== 0) {\n                                result.push(input[i]);\n                            }\n                        } while (i--);\n\n                        if (result.length == size) {\n                        results.push(result);\n                    }\n                }\n                return results; \n                //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n            })(arguments,arguments.length-1).map(function(x){return x.reduce(function(prev,curr){return _.multiply(prev,curr.clone())},new Symbol(1))});\n             \n            //don't eat the gcd term if all arguments are symbols\n            if(args.every(function(x){return core.Utils.isVariableSymbol(x)}))\n                var denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));\n            else\n                var denom = __.gcd.apply(null, denom_args);\n            \n            //divide product of all arguments by gcd of complementary terms\n            return _.divide(numer, denom);\n        },\n        /**\n         * Divides one expression by another\n         * @param {Symbol} symbol1\n         * @param {Symbol} symbol2\n         * @returns {Array}\n         */\n        divide: function(symbol1, symbol2) {\n            var result, remainder, factored, den;\n            factored = core.Algebra.Factor.factor(symbol1.clone());\n            den = factored.getDenom();\n            if(!den.isConstant('all')) {\n                symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\n            }\n            else\n                //reset the denominator since we're not dividing by it anymore\n                den = new Symbol(1); \n            result = __.div(symbol1, symbol2);\n            remainder = _.divide(result[1], symbol2);\n            return _.divide(_.add(result[0], remainder), den);\n        },\n        div: function(symbol1, symbol2) {\n            //division by constants\n            if(symbol2.isConstant()) {\n                symbol1.each(function(x) { \n                    x.multiplier = x.multiplier.divide(symbol2.multiplier);\n                });\n                return [symbol1, new Symbol(0)];\n            }\n            //so that factorized symbols don't affect the result\n\t    symbol1 = _.expand(symbol1);\n\t    symbol2 = _.expand(symbol2);\n            //special case. May need revisiting\n            if(symbol1.group === S && symbol2.group === CP) { \n                var x = symbol1.value;\n                var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\n                if(symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\n                    var k = Symbol.create(symbol1.multiplier);\n                    return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\n                }\n            }\n            if(symbol1.group === S && symbol2.group === S) {\n                var r = _.divide(symbol1.clone(), symbol2.clone());\n                if(r.isConstant()) //we have a whole\n                    return [r, new Symbol(0)];\n                return [new Symbol(0), symbol1.clone()];\n            }\n            var symbol1_has_func = symbol1.hasFunc(),\n                symbol2_has_func = symbol2.hasFunc(),\n                parse_funcs = false;\n            \n            //substitute out functions so we can treat them as regular variables\n            if(symbol1_has_func || symbol2_has_func) {\n                parse_funcs = true;\n                var map = {},\n                    symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\n                    symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\n                    subs = core.Utils.getFunctionsSubs(map);\n            }\n            //get a list of the variables\n            var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\n                quot, rem;\n        \n            //treat imaginary numbers as variables\n            if(symbol1.isImaginary() || symbol2.isImaginary()) {\n                vars.push(core.Settings.IMAGINARY);\n            }\n            \n            if(vars.length === 1) { \n                var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\n                quot = q[0].toSymbol();\n                rem = q[1].toSymbol();\n            }\n            else {\n                vars.push(CONST_HASH); //this is for the numbers\n                var reconvert = function(arr) {\n                    var symbol = new Symbol(0);\n                    for(var i=0; i<arr.length; i++) {\n                        var x = arr[i].toSymbol();\n                        symbol = _.add(symbol, x);\n                    }\n                    return symbol;\n                };\n                //Silly Martin. This is why you document. I don't remember now\n                var get_unique_max = function(term, any) {\n                    var max = Math.max.apply(null, term.terms),\n                        count = 0, idx;\n\n                    if(!any) {\n                        for(var i=0; i<term.terms.length; i++) {\n                            if(term.terms[i].equals(max)) {\n                                idx = i; count++;\n                            }\n                            if(count > 1) return;\n                        }\n                    }\n                    if(any) {\n                        for(i=0; i<term.terms.length; i++) \n                            if(term.terms[i].equals(max)) {\n                                idx = i; break;\n                            }\n                    }\n                    return [max, idx, term];\n                };\n                //tries to find an LT in the dividend that will satisfy division\n                var get_det = function(s, lookat) { \n                    lookat = lookat || 0;\n                    var det = s[lookat], l = s.length; \n                    if(!det) return;\n                    //eliminate the first term if it doesn't apply\n                    var umax = get_unique_max(det); \n                    for(var i=lookat+1; i<l; i++) {\n                        var term = s[i],   \n                            is_equal = det.sum.equals(term.sum);\n                        if(!is_equal && umax) { \n                            break;\n                        } \n                        if(is_equal) {\n                            //check the differences of their maxes. The one with the biggest difference governs\n                            //e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\n                            var max1, max2, idx1, idx2, l2 = det.terms.length;\n                            for(var j=0; j<l2; j++) {\n                                var item1 = det.terms[j], item2 = term.terms[j];\n                                if(typeof max1 === 'undefined' || item1.greaterThan(max1)) {\n                                    max1 = item1; idx1 = j;\n                                }\n                                if(typeof max2 === 'undefined' || item2.greaterThan(max2)) {\n                                    max2 = item2; idx2 = j;\n                                }\n                            }\n                            //check their differences\n                            var d1 = max1.subtract(term.terms[idx1]),\n                                d2 = max2.subtract(det.terms[idx2]);\n                            if(d2 > d1) {\n                                umax = [max2, idx2, term];\n                                break;\n                            }\n                            if(d1 > d2) {\n                                umax = [max1, idx1, det];\n                                break;\n                            }\n                        }\n                        else { \n                            //check if it's a suitable pick to determine the order\n                            umax = get_unique_max(term); \n                            //if(umax) return umax;\n                            if(umax) break;\n                        }\n                        umax = get_unique_max(term); //calculate a new unique max\n                    }\n\n                    //if still no umax then any will do since we have a tie\n                    if(!umax) return get_unique_max(s[0], true);\n                    var e, idx;\n                    for(var i=0; i<s2.length; i++) {\n                        var cterm = s2[i].terms;\n                        //confirm that this is a good match for the denominator\n                        idx = umax[1];\n                        if(idx === cterm.length - 1) return ;\n                        e = cterm[idx]; \n                        if(!e.equals(0)) break;\n                    }\n                    if(e.equals(0)) return get_det(s, ++lookat); //look at the next term\n\n                    return umax;\n                };\n\n                var t_map = core.Utils.toMapObj(vars);\n                var init_sort = function(a, b) {\n                    return b.sum.subtract(a.sum);\n                };\n                var is_larger = function(a, b) { \n                    if(!a || !b) return false; //it's empty so...\n                    for(var i=0; i<a.terms.length; i++) {\n                        if(a.terms[i].lessThan(b.terms[i])) return false;\n                    }\n                    return true;\n                };\n                var s1 = symbol1.tBase(t_map).sort(init_sort),\n                    s2 = symbol2.tBase(t_map).sort(init_sort);\n                var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\n                var det = get_det(target);//we'll begin by assuming that this will let us know which term \n                var quotient = [];\n                if(det) {\n                    var lead_var = det[1];\n                    var can_divide = function(a, b) { \n                        if(a[0].sum.equals(b[0].sum)) return a.length >= b.length;\n                        return true;\n                    };\n\n                    var try_better_lead_var = function(s1, s2, lead_var) {\n                        var checked = [];\n                        for(var i=0; i<s1.length; i++) { \n                            var t = s1[i];\n                            for(var j=0; j<t.terms.length; j++) {\n                                var cf = checked[j], tt = t.terms[j];\n                                if(i === 0) checked[j] = tt; //add the terms for the first one\n                                else if(cf && !cf.equals(tt)) checked[j] = undefined;\n                            }\n                        }\n                        for(var i=0; i<checked.length; i++) {\n                            var t = checked[i];\n                            if(t && !t.equals(0)) return i;\n                        }\n                        return lead_var;\n                    };\n                    var sf = function(a, b){ \n                        var l1 = a.len(), l2 = b.len();\n                        var blv = b.terms[lead_var], alv = a.terms[lead_var];\n                        if(l2 > l1 && blv.greaterThan(alv)) return l2 - l1;\n                        return blv.subtract(alv); \n                    };\n\n                    //check to see if there's a better lead_var\n                    lead_var = try_better_lead_var(s1, s2, lead_var);\n                    //reorder both according to the max power\n                    s1.sort(sf); //sort them both according to the leading variable power\n                    s2.sort(sf);\n\n                    //try to adjust if den is larger\n                    var fdt = s2[0], fnt = s1[0];\n\n                    var den = new MVTerm(new Frac(1), [], fnt.map);\n                    if(fdt.sum.greaterThan(fnt.sum)&& fnt.len() > 1) {\n                        for(var i=0; i<fnt.terms.length; i++) {\n                            var d = fdt.terms[i].subtract(fnt.terms[i]);\n                            if(!d.equals(0)) {\n                                var nd = d.add(new Frac(1));\n                                den.terms[i] = d;\n                                for(var j=0; j<s1.length; j++) {\n                                    s1[j].terms[i] = s1[j].terms[i].add(nd);\n                                }\n                            }\n                            else den.terms[i] = new Frac(0);\n                        }\n                    }\n\n                    var dividend_larger = is_larger(s1[0], s2[0]);\n\n                    while(dividend_larger && can_divide(s1, s2)) {\n                        var q = s1[0].divide(s2[0]);\n\n                        quotient.push(q); //add what's divided to the quotient\n                        s1.shift();//the first one is guaranteed to be gone so remove from dividend\n                        for(var i=1; i<s2.length; i++) { //loop through the denominator\n                            var t = s2[i].multiply(q).generateImage(), \n                                l2 = s1.length;\n                            //if we're subtracting from 0\n                            if(l2 === 0) { \n                                t.coeff = t.coeff.neg();\n                                s1.push(t); \n                                s1.sort(sf);\n                            }\n\n                            for(var j=0; j<l2; j++) {\n                                var cur = s1[j];\n                                if(cur.getImg() === t.getImg()) {\n                                    cur.coeff = cur.coeff.subtract(t.coeff);\n                                    if(cur.coeff.equals(0)) {\n                                        core.Utils.remove(s1, j);\n                                        j--; //adjust the iterator\n                                    }\n                                    break;\n                                }\n                                if(j === l2 - 1) { \n                                    t.coeff = t.coeff.neg();\n                                    s1.push(t); \n                                    s1.sort(sf);\n                                }\n                            }\n                        }\n                        dividend_larger = is_larger(s1[0], s2[0]);\n\n                        if(!dividend_larger && s1.length >= s2.length) {\n                            //One more try since there might be a terms that is larger than the LT of the divisor\n                            for(var i=1; i<s1.length; i++) {\n                                dividend_larger = is_larger(s1[i], s2[0]);\n                                if(dividend_larger) {\n                                    //take it from its current position and move it to the front\n                                    s1.unshift(core.Utils.remove(s1, i)); \n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                quot = reconvert(quotient);\n                rem = reconvert(s1);\n\n                if(typeof den !== 'undefined') {\n                    den = den.toSymbol();\n                    quot = _.divide(quot, den.clone());\n                    rem = _.divide(rem, den);\n                }\n            }\n\n            //put back the functions\n            if(parse_funcs) {\n                quot = _.parse(quot.text(), subs);\n                rem = _.parse(rem.text(), subs);\n            }\n\n            return [quot, rem];\n        },\n        line: function(v1, v2, x) {\n            if(core.Utils.isArray(v1))\n                v1 = core.Utils.convertToVector(v1);\n            if(core.Utils.isArray(v2))\n                v2 = core.Utils.convertToVector(v2);\n            x = _.parse(x || 'x');\n            if(!core.Utils.isVector(v1)||!core.Utils.isVector(v2))\n                _.error('Line expects a vector! Received \"'+v1+'\" & \"'+v2+'\"');\n            var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\n                dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\n                m = _.divide(dy, dx),\n                a = _.multiply(x, m.clone()),\n                b = _.multiply(v1.e(1).clone(),m);\n            return _.add(_.subtract(a, b), v1.e(2).clone());\n        },\n        PartFrac: {\n            createTemplate: function(den, denom_factors, f_array, v) {\n                //clean up the denominator function by factors so it reduces nicely\n                den = __.Factor.factor(den);\n                \n                //clean up factors. This is so inefficient but factors are wrapped in parens for safety\n                den.each(function(x, key) {\n                    if(x.group === FN && x.fname === '' && x.args[0].group === S) {\n                        var y = x.args[0];\n                        if(this.symbols) {\n                            delete this.symbols[key];\n                            this.symbols[y.value] = y;\n                        }\n                        else {\n                            den = x.args[0];\n                        }\n                    }\n                });\n\n                var factors, factors_vec, f, p, deg, degrees, m;\n                factors = denom_factors.collectFactors();\n                factors_vec = []; //a vector for the template\n                degrees = [];\n                m = new Symbol(1);\n\n                for(var i=0; i<factors.length; i++) { //loop through the factors\n                    var factor = Symbol.unwrapPARENS(factors[i]);\n                    //if in he for P^n where P is polynomial and n = integer\n                    if(factor.power.greaterThan(1)) { \n                        p = Number(factor.power);\n                        f = factor.clone().toLinear(); //remove the power so we have only the function\n                        deg = Number(__.degree(f, v)); //get the degree of f\n                        //expand the factor\n                        for(var j=0; j<p; j++){\n                            var efactor = _.pow(f.clone(), new Symbol(j+1));\n                            f_array.push(efactor.clone());\n                            var d = _.divide(den.clone(), efactor.clone());\n                            degrees.push(deg);\n                            factors_vec.push(d);\n                        }\n                    }\n                    /*\n                    Possible bug.\n                    Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\n                    else if(factor.isConstant('all')) {\n                        m = _.multiply(m, factor);\n                    }\n                    */\n                    else {\n                        //get the degree of the factor so we tack it on tot he factor. This should probably be an array\n                        //but for now we note it on the symbol\n                        deg = Number(__.degree(factor, v)); \n                        f_array.push(factor);\n                        var d = _.divide(den.clone(), factor.clone());\n                        d = _.expand(Symbol.unwrapPARENS(d));\n                        degrees.push(deg);\n                        factors_vec.push(d);\n                    }\n                }\n                //put back the constant\n                f_array = f_array.map(function(x) {\n                    return _.multiply(x, m.clone());\n                });\n                return [f_array, factors_vec, degrees];\n            },\n            partfrac: function(symbol, v, as_array) { \n                \n                var vars = variables(symbol);\n                \n                v = v || _.parse(vars[0]); //make wrt optional and assume first variable\n                try {\n                    var num, den, factors, tfactors, ofactors, nterms, degrees,\n                        dterms, max, M, c, powers, div, r, factors_vec, ks,\n                        template, tfactors;\n                    num = _.expand(symbol.getNum());\n                    den = _.expand(symbol.getDenom().toUnitMultiplier());\n                    //move the entire multipier to the numerator\n                    num.multiplier = symbol.multiplier;\n                    //we only have a meaningful change if n factors > 1. This means that\n                    //the returned group will be a CB\n                    //collect the terms wrt the x\n                    nterms = num.groupTerms(v);\n                    //divide out wholes if top is larger\n                    if(Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\n                        div = __.div(num.clone(), _.expand(den.clone()));\n                        r = div[0]; //remove the wholes\n                        num = div[1]; //work with the remainder\n                        nterms = num.groupTerms(v); //recalculate the nterms\n                    }\n                    else\n                        r = new Symbol(0);\n                    \n                    if(Number(__.degree(den, v)) === 1) {\n                        var q = _.divide(num, den);\n                        if(as_array)\n                            return [r, q];\n                        return _.add(r, q);\n                    }\n                    //first factor the denominator. This means that the strength of this\n                    //algorithm depends on how well we can factor the denominator. \n                    ofactors = __.Factor.factor(den);\n                    //create the template. This method will create the template for solving \n                    //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\n                    template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\n                    tfactors = template[0]; //grab the factors\n                    factors_vec = template[1]; //grab the factor vectors\n                    degrees = template[2]; //grab the degrees\n                    //make note of the powers of each term\n                    powers = [nterms.length];\n                    //create the dterms vector\n                    dterms = [];\n                    factors = [];\n                    ks = []; \n                    var factor, deg;\n                    factors_vec.map(function(x, idx) { \n                        factor = tfactors[idx];\n                        deg = degrees[idx];\n                        for(var i=0; i<deg; i++) {\n                            factors.push(factor.clone());\n                            var k = Symbol.create(v, i);\n                            var t = _.expand(_.multiply(x, k.clone())).groupTerms(v);\n                            //make a note of the power which corresponds to the length of the array\n                            var p = t.length;\n                            powers.push(p); \n                            dterms.push(t);\n                            ks.push(k.clone());\n                        }\n                    });\n                    //get the max power\n                    max = core.Utils.arrayMax(powers);\n\n                    //fill the holes and create a matrix\n                    c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();\n                    //for each of the factors we do the same\n                    M = new core.Matrix();\n                    for(var i=0; i<dterms.length; i++) {\n                        M.elements.push(core.Utils.fillHoles(dterms[i], max));\n                    }\n\n                    //solve the system of equations\n                    var partials = _.multiply(M.transpose().invert(), c);\n                    //the results are backwards to reverse it\n                    //partials.elements.reverse();\n                    //convert it all back\n                    var retval = as_array ? [r] : r;\n                    partials.each(function(e, i) {\n                        var term = _.multiply(ks[i],_.divide(e, factors[i]));\n                        if(as_array)\n                            retval.push(term);\n                        else \n                            retval = _.add(retval, term);\n                    });\n                    \n                    //done\n                    return retval;\n                }\n                catch(e){\n                    //try to group symbols\n                    try {\n                        if(symbol.isComposite()) {\n                            //group denominators\n                            var denominators = {};\n\n                            symbol.each(function(x) {\n                                var d = x.getDenom();\n                                var n = x.getNum();\n                                var e = denominators[d];\n                                denominators[d] = e ? _.add(e, n) : n;\n                            });\n\n                            var t = new Symbol(0);\n\n                            for(var x in denominators) {\n                                t = _.add(t, _.divide(denominators[x], _.parse(x)));\n                            }\n\n                            symbol = t;\n                        }\n                    }\n                    catch(e2) {};\n                };\n\n                return symbol;\n            }\n        },\n        degree: function(symbol, v, o) { \n            o = o || {\n                nd: [], //numeric\n                sd: [], //symbolic\n                depth: 0 //call depth\n            };\n            \n            if(!v) {\n                var vars = variables(symbol);\n                //The user must specify the variable for multivariate\n                if(vars.length > 1)\n                    throw new Error('You must specify the variable for multivariate polynomials!');\n                //if it's empty then we're dealing with a constant\n                if(vars.length === 0)\n                    return new Symbol(0);\n                //assume the variable for univariate\n                v = _.parse(vars[0]);\n            }\n\n            //store the group\n            var g = symbol.group;\n            //we're going to trust the user and assume no EX. Calling isPoly \n            //would eliminate this but no sense in checking twice. \n            if(symbol.isComposite()) { \n                symbol = symbol.clone();\n                symbol.distributeExponent();\n                symbol.each(function(x) {\n                    o.depth++; //mark a depth increase\n                    __.degree(x, v, o);\n                    o.depth--; //we're back\n                });\n            }\n            else if(symbol.group === CB) {\n                symbol.each(function(x) {\n                    o.depth++;\n                    __.degree(x, v, o);\n                    o.depth++;\n                });\n            }\n            else if(g === EX && symbol.value === v.value) { \n                o.sd.push(symbol.power.clone());\n            }\n            else if(g === S && symbol.value === v.value){ \n                o.nd.push(_.parse(symbol.power));\n            }\n            else\n                o.nd.push(new Symbol(0));\n            \n            //get the max out of the array\n            var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\n            \n            if(o.depth === 0 && o.sd.length > 0) {\n                if(deg !== undefined)\n                    o.sd.unshift(deg);\n                return _.symfunction('max', o.sd);\n            }\n            if(!core.Utils.isSymbol(deg))\n                deg = _.parse(deg);\n            //return the degree\n            return deg;\n        },\n        /**\n         * Attempts to complete the square of a polynomial\n         * @param {type} symbol\n         * @param {type} v\n         * @param {type} raw\n         * @throws {Error} \n         * @returns {Object|Symbol[]}\n         */\n        sqComplete: function(symbol, v, raw) {\n            if(!core.Utils.isSymbol(v))\n                v = _.parse(v);\n            var stop = function(msg) {\n                msg = msg || 'Stopping';\n                throw new core.exceptions.ValueLimitExceededError(msg);\n            };\n            //if not CP then nothing to do\n            if(!symbol.isPoly()) \n                stop('Must be a polynomial!');\n            //declare vars\n            var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\n\n            br = core.Utils.inBrackets;\n            //make a copy\n            symbol = symbol.clone();\n            deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\n            //must be in form ax^2 +/- bx +/- c\n            if(!deg.equals(2))\n                stop('Cannot complete square for degree '+deg);\n            //get the coeffs\n            coeffs = core.Algebra.coeffs(symbol, v);\n            a = coeffs[2];\n            //store the sign\n            sign = coeffs[1].sign(); \n            //divide the linear term by two and square it\n            b = _.divide(coeffs[1], new Symbol(2));\n            //add the difference to the constant\n            c = _.pow(b.clone(), new Symbol(2));\n            if(raw)\n                return [a, b, d];\n            sqrt_a = math.sqrt(a);\n            e = _.divide(math.sqrt(c), sqrt_a.clone());\n            //calculate d which is the constant\n            d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2)));\n            //compute the square part\n            sym = _.parse(br(sqrt_a.clone()+'*'+v+(sign < 0 ? '-' : '+')+e));\n            return {\n                a: sym,\n                c: d,\n                f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\n            };\n        },\n        Simplify: {\n            strip: function(symbol) {\n                var c = _.parse(symbol.multiplier);\n                symbol.toUnitMultiplier();\n                var p = _.parse(symbol.power);\n                symbol.toLinear();\n                return [c, p, symbol];\n            },\n            unstrip: function(cp, symbol) {\n                var c = cp[0];\n                var p = cp[1];\n                return _.multiply(c, _.pow(symbol, p));\n            },\n            complexSimp: function(num, den) {\n                var ac, bd, bc, ad, cd, r1, r2, i1, i2;\n                r1 = num.realpart();\n                i1 = num.imagpart();\n                r2 = den.realpart();\n                i2 = den.imagpart();\n                //apply complex arithmatic rule\n                ac = _.multiply(r1.clone(), r2.clone());\n                bd = _.multiply(i1.clone(), i2.clone());\n                bc = _.multiply(r2.clone(), i1);\n                ad = _.multiply(r1, i2.clone());\n                cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\n                \n                return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\n            },\n            trigSimp: function(symbol) { \n                if(symbol.containsFunction(['cos', 'sin', 'tan'])) {\n                    symbol = symbol.clone();\n                    //remove power and multiplier\n                    var sym_array = __.Simplify.strip(symbol);\n                    symbol = sym_array.pop();\n                    //the default return value is the symbol\n                    var retval = symbol.clone();\n\n                    //rewrite the symbol\n                    if(symbol.group === CP) {\n                        var sym = new Symbol(0);\n                        symbol.each(function(x) {\n                            //rewrite the function\n                            var tr = __.Simplify.trigSimp(x.fnTransform());\n                            sym = _.add(sym, tr);\n                        }, true);\n                        //put back the power and multiplier and return\n                        retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\n                    }\n                    else if(symbol.group === CB) {\n                        \n                        var n = symbol.getNum();\n                        var d = symbol.getDenom();\n\n                        //try for tangent\n                        if(n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\n                            retval =_.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\n                        }\n                        if(retval.group === CB) {\n                            var t = new Symbol(1);\n                            retval.each(function(x) {\n                                if(x.fname === 'tan') {\n                                    x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\n                                }\n                                t = _.multiply(t, x);\n                            });\n                            retval = t;\n                        }\n                    }\n\n                    retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\n                    \n                    symbol = retval;\n                }\n                \n                return symbol;\n            },\n            fracSimp: function(symbol) {\n                //try a quick simplify of imaginary numbers\n                var den = symbol.getDenom();\n                var num = symbol.getNum();\n\n                if(num.isImaginary() && den.isImaginary())\n                    symbol = __.Simplify.complexSimp(num, den);\n                \n                if(symbol.isComposite()) {\n                    if(symbol.power > 1) {\n                        symbol = _.expand(symbol);\n                    }\n                    \n                    var symbols = symbol.collectSymbols(); \n                    //assumption 1.\n                    //since it's a composite, it has a length of at least 1\n                    var retval, a, b, d1, d2, n1, n2, x, y, c, den, num;\n                    a = symbols.pop(); //grab the first symbol\n                    //loop through each term and make denominator common\n                    while(symbols.length) {\n                        b = symbols.pop(); //grab the second symbol\n                        d1 = _.parse(a.getDenom());\n                        d2 = _.parse(b.getDenom());\n                        n1 = a.getNum();\n                        n2 = b.getNum();\n                        c = _.multiply(d1.clone(), d2.clone());\n                        x = _.multiply(n1, d2);\n                        y = _.multiply(n2, d1);\n                        a = _.divide(_.add(x, y), c);\n                    }\n                    den = _.expand(a.getDenom());\n                    num = _.expand(a.getNum());\n\n                    //simplify imaginary\n                    if(num.isImaginary() && den.isImaginary()) {\n                        retval = __.Simplify.complexSimp(num, den);\n                    }\n                    else {\n                        retval = _.divide(num, den);\n                    }\n\n                    //we've already hit the simplest form so return that\n                    if(retval.equals(symbol)) {\n                        return symbol;\n                    }\n                    \n                    //otherwise simplify it some more\n                    return __.Simplify.simplify(retval);\n                }\n                return symbol;\n            },\n            ratSimp: function(symbol) {\n                if(symbol.group === CB) {\n                    var den = symbol.getDenom();\n                    var num = symbol.getNum().distributeMultiplier();\n                    var d = __.Simplify.fracSimp(den);\n                    var n = __.Simplify.fracSimp(num);\n                    symbol = _.divide(n, d);\n                }\n                return symbol;\n            },\n            simplify: function(symbol) { \n                //remove the multiplier to make calculation easier;\n                var sym_array = __.Simplify.strip(symbol);\n                symbol = sym_array.pop();\n                \n                //remove gcd from denominator\n                symbol = __.Simplify.fracSimp(symbol);\n\n                //nothing more to do\n                if(symbol.isConstant() || symbol.group === core.groups.S) {\n                    sym_array.push(symbol);\n                    var ret = __.Simplify.unstrip(sym_array, symbol);\n                    return ret;\n                }\n                    \n                var simplified;\n                symbol = symbol.clone(); //make a copy\n                ////1. Try cos(x)^2+sin(x)^2 \n\n                simplified = __.Simplify.trigSimp(symbol);\n         \n                //simplify common denominators\n                simplified = __.Simplify.ratSimp(simplified);\n\n                //first go for the \"cheapest\" simplification which may eliminate \n                //your problems right away. factor -> evaluate. Remember\n                //that there's no need to expand since factor already does that\n                simplified = __.Factor.factor(simplified);\n\n                //If the simplfied is a sum then we can make a few more simplifications\n                //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\n                if(simplified.group === core.groups.CP && simplified.isLinear()) {\n                    var m = simplified.multiplier.clone();\n                    simplified.toUnitMultiplier(); //strip the multiplier\n                    var r = new Symbol(0);\n                    //return the sum of simplifications\n                    simplified.each(function(x) {\n                        var s = __.Simplify.simplify(x);\n                        r = _.add(r, s);\n                    });\n                    simplified = r;\n                    //put back the multiplier\n                    r.multiplier = r.multiplier.multiply(m);\n                }\n                //place back multiplier and return\n                var retval = __.Simplify.unstrip(sym_array, evaluate(simplified));\n\n                return retval;\n            }\n        },\n            \n        Classes: {\n            Polynomial: Polynomial,\n            Factors: Factors,\n            MVTerm: MVTerm\n        }\n    };\n\n    nerdamer.useAlgebraDiv = function() {\n        var divide = __.divideFn = _.divide;\n        var calls = 0; //keep track of how many calls were made\n        _.divide = function(a, b) {\n            calls++;\n            var ans;\n            if(calls === 1) //check if this is the first call. If it is use algebra divide\n                ans = core.Algebra.divide(a, b);\n            else //otherwise use parser divide\n                ans = divide(a, b);\n            calls = 0; //reset the number of calls back to none\n            return ans;\n        };\n    };\n    \n    nerdamer.useParserDiv = function() {\n        if(__.divideFn)\n            _.divide = __.divideFn;\n        delete __.divideFn;\n    };\n\t\n    nerdamer.register([\n        {\n            name: 'factor',\n            visible: true,\n            numargs: 1,\n            build: function() { return __.Factor.factor; }\n        },\n        {\n            name: 'simplify',\n            visible: true,\n            numargs: 1,\n            build: function() { return __.Simplify.simplify; }\n        },\n        {\n            name: 'gcd',\n            visible: true,\n            numargs: [1, ],\n            build: function() { return __.gcd; }\n        },\n        {\n            name: 'lcm',\n            visible: true,\n            numargs: [1, ],\n            build: function() { return __.lcm; }\n        },\n        {\n            name: 'roots',\n            visible: true,\n            numargs: -1,\n            build: function() { return __.roots; }\n        },\n        {\n            name: 'divide',\n            visible: true,\n            numargs: 2,\n            build: function() { return __.divide; }\n        },\n        {\n            name: 'div',\n            visible: true,\n            numargs: 2,\n            build: function() { return __.div; }\n        },\n        {\n            name: 'partfrac',\n            visible: true,\n            numargs: [1,2],\n            build: function() { return __.PartFrac.partfrac; }\n        },\n        {\n            name: 'deg',\n            visible: true,\n            numargs: [1,2],\n            build: function() { return __.degree; }\n        },\n        {\n            name: 'coeffs',\n            visible: true,\n            numargs: [1, 2],\n            build: function() { \n                var f = function() {\n                    var coeffs = __.coeffs.apply(__, arguments);\n                    return new core.Vector(coeffs);\n                };\n                return f;\n            }\n        },\n        {\n            name: 'line',\n            visible: true,\n            numargs: [2, 3],\n            build: function() { return __.line; }\n        },\n        {\n            name: 'sqcomp',\n            visible: true,\n            numargs: [1,2],\n            build: function() { \n                var f = function(x, v) {\n                    try {\n                        v = v || variables(x)[0];\n                        var sq = __.sqComplete(x.clone(), v);\n                        return sq.f;\n                    }\n                    catch(e) {\n                        return x;\n                    }\n                };\n                return f;\n            }\n        }\n    ]);\n    nerdamer.api();\n})();","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('katex')) : typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', 'katex'], factory) : factory(global.ReactKaTeX = global.ReactKaTeX || {}, global.React, global.PropTypes, global.katex);\n})(this, function (exports, React, PropTypes, KaTeX) {\n  'use strict';\n\n  React = React && 'default' in React ? React['default'] : React;\n  PropTypes = PropTypes && 'default' in PropTypes ? PropTypes['default'] : PropTypes;\n  KaTeX = KaTeX && 'default' in KaTeX ? KaTeX['default'] : KaTeX;\n\n  var classCallCheck = function classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var inherits = function inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n\n  var possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  };\n\n  var createMathComponent = function createMathComponent(Component, _ref) {\n    var displayMode = _ref.displayMode;\n\n    var MathComponent = function (_React$Component) {\n      inherits(MathComponent, _React$Component);\n\n      function MathComponent(props) {\n        classCallCheck(this, MathComponent);\n\n        var _this = possibleConstructorReturn(this, (MathComponent.__proto__ || Object.getPrototypeOf(MathComponent)).call(this, props));\n\n        _this.usedProp = props.math ? 'math' : 'children';\n        _this.state = _this.createNewState(null, props);\n        return _this;\n      }\n\n      createClass(MathComponent, [{\n        key: 'componentWillReceiveProps',\n        value: function componentWillReceiveProps() {\n          this.setState(this.createNewState);\n        }\n      }, {\n        key: 'shouldComponentUpdate',\n        value: function shouldComponentUpdate(nextProps) {\n          return nextProps[this.usedProp] !== this.props[this.usedProp];\n        }\n      }, {\n        key: 'createNewState',\n        value: function createNewState(prevState, props) {\n          try {\n            var html = this.generateHtml(props);\n            return {\n              html: html,\n              error: undefined\n            };\n          } catch (error) {\n            if (error instanceof KaTeX.ParseError || error instanceof TypeError) {\n              return {\n                error: error\n              };\n            }\n\n            throw error;\n          }\n        }\n      }, {\n        key: 'generateHtml',\n        value: function generateHtml(props) {\n          var errorColor = props.errorColor,\n              renderError = props.renderError;\n          return KaTeX.renderToString(props[this.usedProp], {\n            displayMode: displayMode,\n            errorColor: errorColor,\n            throwOnError: !!renderError\n          });\n        }\n      }, {\n        key: 'render',\n        value: function render() {\n          var _state = this.state,\n              error = _state.error,\n              html = _state.html;\n          var renderError = this.props.renderError;\n\n          if (error) {\n            return renderError ? renderError(error) : React.createElement(Component, {\n              html: '' + error.message\n            });\n          }\n\n          return React.createElement(Component, {\n            html: html\n          });\n        }\n      }]);\n      return MathComponent;\n    }(React.Component);\n\n    return MathComponent;\n  };\n\n  var InlineMath = function InlineMath(_ref) {\n    var html = _ref.html;\n    return React.createElement('span', {\n      dangerouslySetInnerHTML: {\n        __html: html\n      }\n    });\n  };\n\n  var InlineMath$1 = createMathComponent(InlineMath, {\n    displayMode: false\n  });\n\n  var BlockMath = function BlockMath(_ref) {\n    var html = _ref.html;\n    return React.createElement('div', {\n      dangerouslySetInnerHTML: {\n        __html: html\n      }\n    });\n  };\n\n  var BlockMath$1 = createMathComponent(BlockMath, {\n    displayMode: true\n  });\n  exports.InlineMath = InlineMath$1;\n  exports.BlockMath = BlockMath$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","module.exports = __webpack_public_path__ + \"static/wavestructure-8a614d8f648eda35ec19c540ced5272b.png\";","var pi = Math.PI,\n    tau = 2 * pi,\n    epsilon = 1e-6,\n    tauEpsilon = tau - epsilon;\n\nfunction Path() {\n  this._x0 = this._y0 = // start of current subpath\n  this._x1 = this._y1 = null; // end of current subpath\n\n  this._ = \"\";\n}\n\nfunction path() {\n  return new Path();\n}\n\nPath.prototype = path.prototype = {\n  constructor: Path,\n  moveTo: function moveTo(x, y) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n  },\n  closePath: function closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  },\n  lineTo: function lineTo(x, y) {\n    this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  quadraticCurveTo: function quadraticCurveTo(x1, y1, x, y) {\n    this._ += \"Q\" + +x1 + \",\" + +y1 + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {\n    this._ += \"C\" + +x1 + \",\" + +y1 + \",\" + +x2 + \",\" + +y2 + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  arcTo: function arcTo(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    var x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01; // Is the radius negative? Error.\n\n    if (r < 0) throw new Error(\"negative radius: \" + r); // Is this path empty? Move to (x1,y1).\n\n    if (this._x1 === null) {\n      this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    } // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon)) ; // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n      // Equivalently, is (x1,y1) coincident with (x2,y2)?\n      // Or, is the radius zero? Line to (x1,y1).\n      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n          this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n        } // Otherwise, draw an arc!\n        else {\n            var x20 = x2 - x0,\n                y20 = y2 - y0,\n                l21_2 = x21 * x21 + y21 * y21,\n                l20_2 = x20 * x20 + y20 * y20,\n                l21 = Math.sqrt(l21_2),\n                l01 = Math.sqrt(l01_2),\n                l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n                t01 = l / l01,\n                t21 = l / l21; // If the start tangent is not coincident with (x0,y0), line to.\n\n            if (Math.abs(t01 - 1) > epsilon) {\n              this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n            }\n\n            this._ += \"A\" + r + \",\" + r + \",0,0,\" + +(y01 * x20 > x01 * y20) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n          }\n  },\n  arc: function arc(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r, ccw = !!ccw;\n    var dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0; // Is the radius negative? Error.\n\n    if (r < 0) throw new Error(\"negative radius: \" + r); // Is this path empty? Move to (x0,y0).\n\n    if (this._x1 === null) {\n      this._ += \"M\" + x0 + \",\" + y0;\n    } // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n        this._ += \"L\" + x0 + \",\" + y0;\n      } // Is this arc empty? Were done.\n\n\n    if (!r) return; // Does the angle go the wrong way? Flip the direction.\n\n    if (da < 0) da = da % tau + tau; // Is this a complete circle? Draw two arcs to complete the circle.\n\n    if (da > tauEpsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n    } // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon) {\n        this._ += \"A\" + r + \",\" + r + \",0,\" + +(da >= pi) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n      }\n  },\n  rect: function rect(x, y, w, h) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + +w + \"v\" + +h + \"h\" + -w + \"Z\";\n  },\n  toString: function toString() {\n    return this._;\n  }\n};\nexport default path;","export function x(p) {\n  return p[0];\n}\nexport function y(p) {\n  return p[1];\n}","import { path } from \"d3-path\";\nimport constant from \"./constant.js\";\nimport curveLinear from \"./curve/linear.js\";\nimport { x as pointX, y as pointY } from \"./point.js\";\nexport default function () {\n  var x = pointX,\n      y = pointY,\n      defined = constant(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function line(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) output.lineStart();else output.lineEnd();\n      }\n\n      if (defined0) output.point(+x(d, i, data), +y(d, i, data));\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  line.x = function (_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), line) : x;\n  };\n\n  line.y = function (_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), line) : y;\n  };\n\n  line.defined = function (_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), line) : defined;\n  };\n\n  line.curve = function (_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n\n  line.context = function (_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n\n  return line;\n}","import React, { useRef, useEffect, useMemo } from 'react';\nimport { line, curveNatural } from \"d3-shape\";\nimport { timer } from \"d3-timer\";\nimport { select } from 'd3-selection';\nimport * as waveStyles from '../../styles/waves/waves.module.css';\n\nfunction IntroWave() {\n    const shift = 2 * Math.PI / 3;\n    const speed = 1 / 1000;\n    const frequency = 16;\n    const amplitude = 32;\n    const height = 250;\n    const width = 800;\n    const radius = Math.min(width, height) / 1.5 - amplitude * 2;\n\n    const idxPoints = useMemo(() => {\n        const p = [];\n        for (let i=2; i<104; i+=2) {\n            p.push(i);\n        }\n        return p;\n    }, []);\n\n    const curveFunc = line()\n                .curve(curveNatural)\n                .x((d, i) => idxPoints[i] * 2 * Math.PI)\n                .y(d => d);\n\n    const canvasRef = useRef(null);\n\n    useEffect(() => {\n\n        const buildWave = (canvasRef) => {\n            let svg = select(canvasRef.current).select('svg').style(\"width\", width + 'px').style(\"height\", height + 'px');\n    \n            let cynPath = svg.append('path').attr(\"fill\", \"none\").attr(\"stroke\", \"cyan\").style(\"mix-blend-mode\", \"multiply\").attr(\"stroke-width\", \"0.8rem\").attr(\"stroke-linecap\", \"round\");\n            let magPath = svg.append('path').attr(\"fill\", \"none\").attr(\"stroke\", \"magenta\").style(\"mix-blend-mode\", \"multiply\").attr(\"stroke-width\", \"0.8rem\").attr(\"stroke-linecap\", \"round\");\n            let yelPath = svg.append('path').attr(\"fill\", \"none\").attr(\"stroke\", \"yellow\").style(\"mix-blend-mode\", \"multiply\").attr(\"stroke-width\", \"0.8rem\").attr(\"stroke-linecap\", \"round\");\n    \n            timer(time => {\n                const cynPoints = [];\n                const magPoints = [];\n                const yelPoints = [];\n    \n                // Push cyan points\n                for (const m of idxPoints) {\n                    const a = m * 2 * Math.PI / 250;\n                    const t = time * speed;\n                    const c = Math.cos(a * frequency - 1 * shift + t);\n                    const p = Math.pow((1 + Math.cos(a - t)) / 2, 3);\n                    cynPoints.push(radius + amplitude * c * p);\n                }\n    \n                // Push magenta points\n                for (const m of idxPoints) {\n                    const a = m * 2 * Math.PI / 250;\n                    const t = time * speed;\n                    const c = Math.cos(a * frequency - 2 * shift + t);\n                    const p = Math.pow((1 + Math.cos(a - t)) / 2, 3);\n                    magPoints.push(radius + amplitude * c * p);\n                }\n    \n                // Push yellow points\n                for (const m of idxPoints) {\n                    const a = m * 2 * Math.PI / 250;\n                    const t = time * speed;\n                    const c = Math.cos(a * frequency - 3 * shift + t);\n                    const p = Math.pow((1 + Math.cos(a - t)) / 2, 3);\n                    yelPoints.push(radius + amplitude * c * p);\n                }\n    \n                cynPath.attr(\"d\", curveFunc(cynPoints));\n                magPath.attr(\"d\", curveFunc(magPoints));\n                yelPath.attr(\"d\", curveFunc(yelPoints));\n            })\n        }\n\n        buildWave(canvasRef)\n        \n    }, [canvasRef, curveFunc, idxPoints, radius, shift, speed])\n\n    return (\n        <div ref={canvasRef}>\n            <svg className={waveStyles.image} />\n        </div>\n    )\n}\n\nexport default IntroWave;\n","/* eslint-disable */\n\nvar nerdamer = require('./core.js');\nrequire('./Algebra.js');\nrequire('./Calculus.js');\nrequire('./Solve.js');\n\n//export nerdamer\nexport default nerdamer;","import nerdamer from './nerdamer/nerdamer';\n\nconst derivePoints = (f) => {\n    function calcNums(dx, points) {\n        for (let e of dx) {\n            let num = e.valueOf();\n            if(num<=2*Math.PI) {\n                num = Math.round((num + Number.EPSILON) * 100) / 100;\n                points.add(num);\n            }\n        }\n    }\n    let dx = nerdamer(\"diff(sin(\" + f + \"*x), x)\")\n                .solveFor(\"x\")\n                .filter(x => x.symbol.multiplier.num.sign === false);\n    let dx2 = nerdamer(\"diff(sin(\" + f + \"*x), x, 2)\")\n                .solveFor(\"x\")\n                .filter(x => x.symbol.multiplier.num.sign === false);\n    let p = new Set();\n    calcNums(dx, p);\n    calcNums(dx2, p);\n    p = [...p].sort();\n    return p;\n}\n\nexport default derivePoints;","const formula = {\n    sine: (x, svgHeight, a=0.5, f=2, t=0, c=1) => {\n            const amplitude = a * svgHeight / 4;\n            const velocity = t * c / 100;\n            return amplitude * Math.sin(f * x + velocity);\n        }\n    }\n\nexport default formula;","import derivePoints from '../../constants/waves/derivePoints';\nimport formula from '../../constants/waves/formula';\nimport { line, curveNatural } from 'd3-shape';\nimport { scaleLinear } from 'd3-scale';\nimport { timer } from 'd3-timer';\n\nclass Wave {\n    constructor(type, amplitude, frequency, position=2) {\n        this._type = type;\n        this._amplitude = amplitude;\n        this._frequency = frequency;\n        this._position = position;\n        this._time = 0;\n        this._speed = 1;\n        this._svgHeight = 0;\n        this._svgWidth = 0;\n        this._derivedPoints = derivePoints(frequency);\n    }\n\n    get svgVerticalShift() {\n        return this._svgHeight / this._position;\n    }\n\n    get formula() {\n        return formula[this._type];\n    }\n\n    get points() {\n        let p = [];\n        let dx = this._derivedPoints;\n        for (let e of dx) {\n            p.push({\n                \"x\": this._x(e),\n                \"y\": this._y(e)\n            });\n        }\n        return p;\n    }\n\n    _x(d) {\n        return this._scale(d);\n    }\n\n    _y(d) {\n        return this.formula(d, this._svgHeight, this._amplitude, this._frequency, this._time, this._speed)+this.svgVerticalShift;\n    }\n\n    _scale(d) {\n        return scaleLinear().domain([0, 2*Math.PI]).range([0.02*this._svgWidth, 0.98*this._svgWidth])(d);\n    }\n\n    setSize(height, width) {\n        this._svgHeight = height;\n        this._svgWidth = width;\n        return this;\n    }\n\n    animate(speed=1) {\n        this._time = 1;\n        this._speed = speed;\n        return this;\n    }\n\n    apply(...selection) {\n        selection = selection[1][0];\n        let curveFunc = line()\n                            .curve(curveNatural)\n                            .x(function(d) { return d.x; })\n                            .y(function(d) { return d.y; });\n        selection = selection.append(\"path\");\n        if (this._time) {\n            timer((time) => {\n                this._time = time;\n                selection = selection.attr(\"d\", curveFunc(this.points));\n            });\n        } else {\n            selection = selection.attr(\"d\", curveFunc(this.points));\n        }\n        selection.attr(\"fill\", \"none\")\n            .attr(\"stroke\", \"#8838a7\")\n            .attr(\"stroke-width\", \"1rem\")\n            .attr(\"stroke-linecap\", \"round\");\n    }\n}\n\nexport default Wave;","import nerdamer from './nerdamer/nerdamer';\n\nconst buildPoints = (formula) => {\n    function calcNums(dx, points) {\n        for (let e of dx) {\n            let num = e.valueOf();\n            if(num<=2*Math.PI) {\n                num = Math.round((num + Number.EPSILON) * 100) / 100;\n                points.add(num);\n            }\n        }\n    }\n    let dx = nerdamer(\"diff(\" + formula + \", x)\")\n                .solveFor(\"x\")\n                .filter(x => x.symbol.multiplier.num.sign === false);\n    let dx2 = nerdamer(\"diff(\" + formula + \", x, 2)\")\n                .solveFor(\"x\")\n                .filter(x => x.symbol.multiplier.num.sign === false);\n    let p = new Set();\n    calcNums(dx, p);\n    calcNums(dx2, p);\n    p = [...p].sort();\n    return p;\n}\n\nconst buildFormula = (waves) => {\n    let formula = '';\n    for (let w of waves) {\n        formula = formula + w._amplitude + '*sin(' + w._frequency + '*x)+';\n    }\n    formula = formula.slice(0, -1);\n    return buildPoints(formula);\n}\n\nexport default buildFormula;","import buildFormula from '../../constants/waves/buildFormula';\nimport { line, curveNatural } from 'd3-shape';\nimport { scaleLinear } from 'd3-scale';\nimport { timer } from 'd3-timer';\n\nclass WaveBuilder {\n    constructor(waves, position=2) {\n        this.waves = waves;\n        this._position = position;\n        this._time = 0;\n        this._speed = 1;\n        this._svgHeight = 0;\n        this._svgWidth = 0;\n        this._derivedPoints = buildFormula(waves);  // now build formula in points function?\n    }\n\n    get svgVerticalShift() {\n        return this._svgHeight / this._position;\n    }\n\n    get points() {  // need to fix this -- loop through each wave to calculate ys, create array for each wave, then add up numpoints and array for each index at end\n        let p = [];\n        let dx = this._derivedPoints;\n        for (let e of dx) {\n            p.push({\n                \"x\": this._x(e),\n                \"y\": this._y(e)\n            });\n        }\n        return p;\n    }\n\n    _x(d) {\n        return this._scale(d);\n    }\n\n    _y(d, waves) {\n        let y = 0;\n        for (let w of this.waves) {\n            y = y + w.formula(d, w._svgHeight, w._amplitude, w._frequency, this._time, this._speed);\n        }\n        y = y + this.svgVerticalShift;\n        return y;\n    }\n\n    _scale(d) {\n        return scaleLinear().domain([0, 2*Math.PI]).range([0.02*this._svgWidth, 0.98*this._svgWidth])(d);\n    }\n\n    setSize(height, width) {\n        this._svgHeight = height;\n        this._svgWidth = width;\n        return this;\n    }\n\n    animate(speed=1) {\n        this._time = 1;\n        this._speed = speed;\n        return this;\n    }\n\n    apply(...selection) {\n        selection = selection[1][0];\n        let curveFunc = line()\n                            .curve(curveNatural)\n                            .x(function(d) { return d.x; })\n                            .y(function(d) { return d.y; });\n        selection = selection.append(\"path\");\n        if (this._time) {\n            timer((time) => {\n                this._time = time;\n                selection = selection.attr(\"d\", curveFunc(this.points));\n            });\n        } else {\n            selection = selection.attr(\"d\", curveFunc(this.points));\n        }\n        selection.attr(\"fill\", \"none\")\n            .attr(\"stroke\", \"#8838a7\")\n            .attr(\"stroke-width\", \"1rem\")\n            .attr(\"stroke-linecap\", \"round\");\n    }\n}\n\nexport default WaveBuilder;","import React, { useEffect, useRef } from 'react';\nimport Wave from './wave';\nimport WaveBuilder from './waveBuilder';\nimport { select } from 'd3-selection';\n\nfunction Waveform({ amplitude, frequency, height, width }) {\n\n  const svgDOM = useRef(null);\n\n  useEffect(() => {\n    const transformWave = (svgDOM) => {\n      let svg = select(svgDOM.current).select('svg');\n      svg.style(\"width\", width + 'px').style(\"height\", height + 'px');\n  \n      let waves = [];\n      for (let idx=0; idx<amplitude.length; idx++) {\n        let wave = new Wave(\"sine\", amplitude[idx], frequency[idx]).setSize(height, width);\n        waves.push(wave);\n      }\n  \n      let wb = new WaveBuilder(waves).setSize(height, width).animate(0.5);\n      svg.call(wb);\n    }\n\n    transformWave(svgDOM)\n  }, [svgDOM, amplitude, frequency, height, width])\n\n  return (\n    <div ref={svgDOM}>\n      <svg />\n    </div>\n  );\n}\n\nexport default Waveform;\n","import React from 'react';\nimport { BlockMath, InlineMath } from 'react-katex';\nimport Layout from '../../../components/site/layouts/layout';\nimport WaveRainbow from '../../../components/waves/introWave';\nimport WaveForm from '../../../components/waves/waveForm';\nimport hierarchy from '../../../img/hierarchy.png'\nimport frequency from '../../../img/frequencyrange.png'\nimport structure from '../../../img/wavestructure.png'\nimport * as waveStyles from '../../../styles/waves/waves.module.css';\n\nfunction WavesPost() {\n  return (\n    <Layout>\n      <div className={waveStyles.post}>\n        <h1>\n          Sound Waves\n        </h1>\n        <WaveRainbow />\n        <h2>\n          How Sound Travels\n        </h2>\n        <p>\n          In physics, many different forms of vibrations travel through various mediums around the world.\n          For example, vibrations can travel through the air, water, or even a gas.\n          These vibrations are represented using waves.\n          In general, there are two basic types of waves:\n        </p>\n        <ul>\n          <li>Mechanical Waves</li>\n          <li>Electromagnetic Waves</li>\n        </ul>\n        <p>\n          Roughly, we can think of mechanical waves as sound waves and electromagnetic waves as light waves.\n          There are exceptions to this generalization, which are illustrated in the graphic below.\n        </p>\n        <img src={hierarchy} alt=\"hierarchy\" className={waveStyles.image} />\n        <p>\n          Sound waves refer to any vibration that is able to travel through a medium.\n          On the other hand, light waves refer to any vibration that is able to travel through a vacuum.\n          Meaning, they must be able to travel through a space without a medium.\n        </p>\n        <p>\n          There are many different types of sounds waves, which include audible and inaudible sound waves.\n          Interestingly, there are only certain sound waves that are audible to humans.\n          In particular, our ears can only hear waves having frequencies within the range of 20 Hz and 20,000 Hz.\n          These sounds waves translate to waves with wavelengths between 0.67 inches and 56 feet.\n        </p>\n        <p>\n        To illustrate this point, a dog whistle is inaudible to the human ear.\n        In other words, a dog whistle creates sound waves producing frequencies greater than 20,000 HZ, which fall outside of the hearing range for humans.\n        However, they fall within the range of frequencies that are audible to dogs.\n        In contrast, certain animals, such as whales and giraffes, communicate using sound waves that fall below 20 HZ sometimes.\n        Meaning, some of their sound waves are audible to other whales and giraffes, but not humans.\n        Avalanches and earthquakes also produce sound waves below the 20 HZ threshold.\n        </p>\n        <img src={frequency} alt=\"frequencyRange\" className={waveStyles.image} />\n        <p>\n          At this point, some of this information may seem convoluted.\n          In the next section, well develop a greater intuition for some of these technical terms, such as frequencies and wavelengths. \n        </p>\n        <h2>\n          Science of Sound\n        </h2>\n        <p>\n          Many different professions are interested in similar concepts related to sound.\n          Specifically, musicians and engineers both use their own terminology for describing loudness and pitch.\n          Engineers typically refer to any inherent change in a waveform, such as amplitude, whereas musicians refer to the acoustic effect caused by an increased amplitude.\n          Moreover, waves with a higher frequency produce a higher-pitched sound, and waves with a higher amplitude produce a louder sound.\n          They are both essentially talking about the same thing.\n        </p>\n        <p>\n          Returning to our dog whistle example, these sound waves produce an extremely high-pitched sound that is only audible to dogs.\n          These sound waves are high-pitched because their frequencies are so high.\n          On a related note, most dog whistles are fairly loud.\n          These sound waves are loud because their amplitude is high.\n        </p>\n        <p>\n          There are two types of waves with their own distinct set of properties:\n        </p>\n        <ul>\n          <li>Transverse Waves</li>\n          <li>Longitudinal Waves</li>\n        </ul>\n        <p>\n          Transverse waves move in a single direction with some perpendicular oscillation.\n          Most waves are transverse waves, including electromagnetic waves and water waves.\n          These waves take the shape of a shoelace wiggling up and down.\n        </p>\n        <img src={structure} alt=\"waveStructure\" className={waveStyles.image} />\n        <p>\n          Longitudinal waves move in a single direction with parallel particle displacement.\n          These waves take the shape of a slinky being pushed and pulled.\n          There are only a few examples of longitudinal waves, which includes sound waves.\n          The amplitude of a longitudinal wave measures a change in pressure.\n          Although sound waves are longitudinal waves, most diagrams will represent sound waves as transverse waves, since this seems to be more intuitive for most people.\n        </p>\n        <h2>\n          Sine Waveform\n        </h2>\n        <p>\n          As stated previously, volume corresponds to the amplitude of pressure.\n          Waves with larger amplitudes produce very loud sounds, which may even be felt by the body.\n          In music, decibals are used to measure sounds, whereas frequency is measured in units of hertz.\n          Note, decibels are a logarithmic ratio of the relative amplitude levels between two sounds.\n        </p>\n        <p>\n          In music theory, a sine wave is the most basic model of sound.\n          Each sine wave has the following formula:\n        </p>\n        <div className={waveStyles.math}>\n          <BlockMath math=\"f(t) = A * \\sin(\\omega \\times t + \\varphi)\" />\n        </div>\n        <p>\n          Here, <InlineMath math=\"A\" /> refers to the amplitude of the wave.\n          Mathematically, <InlineMath math=\"\\omega = \\pi \\times frequency\" />.\n          Next, <InlineMath math=\"t\" /> represents time.\n          Lastly, <InlineMath math=\"\\varphi\" /> is an angle representing the number of periods.<br />\n        </p>\n        <p>\n          A sine wave retains its general shape when combined with another sine wave of the same parameters, such as frequency, phase, and amplitude.\n          It is the only periodic waveform that has this property.\n          For this reason, the sine wave is acoustically unique.\n          Sine waves are important in many areas of engineering and physics, since they maintain this property.\n          In particular, sine waves are important in Fourier analysis, which roughly refers to the study of how a complex wave can be dissected into many simpler waves.\n          In other words, Fourier analysis illustrates how any complex waveform may consist of a series of individual sine waves.\n          Interestingly, there are plenty of use cases for Fourier analysis throughout many areas of engineering, including the <a href=\"https://hearinghealthmatters.org/waynesworld/2012/fourier-analysis-and-its-role-in-hearing-aids/\">design of hearing aids.</a>\n        </p>\n        <p>\n          So far, we've defined a sine wave, specified its mathematical parameters, and introduced its importance in engineering.\n          Now, let's illustrate some of these concepts by visualizing a sine wave as a transverse wave.\n          A basic sine wave, where amplitude=60dB and frequency=262Hz, may look like the following:\n        </p>\n        <WaveForm amplitude={[0.5]} frequency={[5]} height={200} width={600} />\n        <p>\n          We've all probably seen a sine wave that looks very similar to this before.\n          Let's say this sine wave is the result of a note being played on a piano. \n          In particular, a middle C may produce a sound wave appearing very similar to the sound wave illustrated above.\n          The middle C key can be referred to as C4, and hitting the C4 key will produce a sound at 262 Hz, which has the same frequency as the sine wave above.\n        </p>\n        <p>\n          Now, what happens if we hit this piano key even harder?\n          The sound will produce the same frequency as the sound before.\n          However, the sound will be much louder, which means the amplitude increases.\n          The amplitude of our previous sound wave was 60 dB, whereas the amplitude of our new sound wave becomes 70 dB.\n          In the end, our new sound will correspond to a sine wave that could look like the following:\n        </p>\n        <WaveForm amplitude={[1]} frequency={[5]} height={200} width={600} />\n        <p>\n          Notice, the crests and troughs stretch further away from the origin, compared to the crests and troughs of the previous sine wave.\n          This is a symptom of a louder sound wave having a greater amplitude.\n          If we reduced the amplitude of the sound wave to 40 dB or less, then the sine wave would begin flattening.\n        </p>\n        <p>\n          Now, let's say we're interested in playing a different note on the keyboard, such as C5.\n          The C5 key produces a sound at 523 Hz, which creates a sound wave with more crests and troughs.\n          Actually, each key is associated with its own frequency.\n          As we move up the keyboard, the frequency of each key increases.\n          For this example, we'll assume the key has an amplitude of 60 dB, similar to the most recent sound wave.\n          As a result, the sound wave produced by hitting the C5 key could look like the following sine wave:\n        </p>\n        <WaveForm amplitude={[1]} frequency={[10]} height={200} width={600} />\n        <p>\n          Again, frequency translates over to pitch.\n          In other words, the faster a wave repeats itself, the higher the pitch of the sound produced by hitting a key.\n          Meaning, hitting the C4 key will cause its string to vibrate at 523 Hz, whereas hitting the C5 key will cause its string to vibrate at 523 Hz.\n          To be clear, this is true for all instruments, and isn't only true for pianos.\n          If a vocalist sings a C4 note, then the vocalist's throat will vibrate at 262 Hz.\n        </p>\n        <p>\n          In most cases throughout the world, sounds aren't perfect sine waves.\n          Sounds are usually layered on top of each other, consisting of varying amplitudes and frequencies.\n          In the next section, we'll illustrate layered sounds and how they can be interpreted.\n        </p>\n        <h2>\n          Additive Synthesis\n        </h2>\n        <p>\n          Additive synthesis is a technique involving many simple tones being added together to make a more complex tone.\n          This concept arises from an idea mentioned earlier: complex sounds are made up of simpler sounds.\n          In additive synthesis, this concept is applied in reverse.\n        </p>\n        <p>\n          Interestingly, additive synthesis has been used by instruments to produce sounds since the Middle Ages.\n          Specifically, the pipe organ uses a separate pipe for each tone being added, which produces a resulting complex sound.\n          As the performance of computers continues to improve, digital software has become a popular means for mixing more complex sounds.\n          As a result, complex sounds become limited by the performance of the computer, rather than the number of pipes in a physical instrument, such as the pipe organ.\n          In othe words, digital oscillators and other modern systems can mix thousands of sine waves in real time, using aditive synthesis.\n          In more recent software, additive synthesis has been replaced by more efficient techniques used for producing complex sounds.\n        </p>\n        <p>\n          In theory, any waveform can be added together in order to form a more complex sound.\n          However, sine waves are the most popular waveform that is used, since it's considered the purest waveform.\n          In other words, a sine wave doesn't consist of any harmonics, which is an additional wave that's layered on top of a fundamental wave, where the frequency of the layered wave is an integer multiple of the frequency of the fundamental wave.\n        </p>\n        <p>\n          By using sine waves when performing additive synthesis, the process becomes simpler, controllable, and predictable.\n          Additive synthesis can be used to create other common waveforms, such as square and saw waves.\n          These waves are interesting because their harmonics follow a well-structured pattern.\n          For example, an ideal square wave consists of odd-integer harmonic frequencies.\n        </p>\n        <p>\n          To help visualize some of these concepts, we'll depict the addition of two sine waves.\n          In particular, one sine wave has an amplitude of 40 dB and a frequency of 294 Hz, while the other sine wave has an amplitude of 40 dB and a frequency of 523 Hz.\n          This is similar to playing the C4 and C5 notes on a keyboard at the same time.\n          The following visual illustrates the resulting sound wave:\n        </p>\n        <WaveForm amplitude={[0.5, 0.5]} frequency={[5, 10]} height={200} width={600} />\n        <p>\n          Notice, the above sound wave doesn't emulate the typical shape of a sine wave.\n          The shape of this sound wave is the result of additive synthesis, which roughly represents the two basic sine waves layered on top of each other.\n          In other words, the two sine waves are added together to create the more complex sound wave seen above.\n        </p>\n        <p>\n          A more concrete application of additive synthesis can be found when playing a chord on the keyboard.\n          In this scenario, let's say our chord includes exactly 3 notes.\n          As a result, the outcome becomes a sound wave representing the three individual sound waves added up together.\n        </p>\n        <h2>\n          Next Steps\n        </h2>\n        <p>\n          This post was heavily influenced by <a href=\"https://www.pudding.cool/2018/02/waveforms/\">this amazing article</a>.\n          In the future, I plan to include details about harmonics and addtional waves, such as square and saw waves.\n          Specifically, I hope to illustrate some of these more complex concepts with waveforms and other graphics.\n          Also, I want to describe the differences between sine waves and other waveforms.\n        </p>\n      </div>\n    </Layout>\n  );\n}\n\nexport default WavesPost;\n"],"sourceRoot":""}