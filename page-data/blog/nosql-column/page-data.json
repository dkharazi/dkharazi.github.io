{"componentChunkName":"component---src-templates-blog-js","path":"/blog/nosql-column","result":{"data":{"markdownRemark":{"frontmatter":{"title":"NoSQL Basics: Column-Family Databases","date":"2020-02-27"},"html":"<p>In a <a href=\"/blog/nosql/\">previous post</a> about NoSQL databases, column-family stores were described at a fairly high-level. In this post, we'll dive into more low-level details, which includes features, behavior, and use cases.</p>\n<p><em>NoSQL Distilled</em> is a terrific resource for learning about both high-level and low-level details of NoSQL databases. This post is meant to summarize my experience with these databases, along with particular segments from the book. Again, refer to the book for a deeper dive of relational and NoSQL databases.</p>\n<h2>Table of Contents</h2>\n<ul>\n<li><a href=\"#defining-a-column-family-store\">Defining a Column-Family Database</a></li>\n<li><a href=\"#introduction-to-the-cassandra-architecture\">Introduction to the Cassandra Architecture</a></li>\n<li><a href=\"#features-of-column-family-databases\">Features of Column-Family Databases</a></li>\n<li><a href=\"#using-column-family-databases\">Using Column-Family Databases</a></li>\n</ul>\n<h2>Defining a Column-Family Store</h2>\n<p>Compared to key-value and document databases, column-family stores impose more limitations on the structure of an aggregate. Specifically, column-family databases organize their columns into column families. Each column must be assigned to a particular column-family. Then, each column can be accessed via a column-family. In particular, accessing a column-family will return each of the columns associated with that column family.</p>\n<p>At a high level point of view, a column-family database represents a map consisting of smaller maps, where the first map is a column family and the second map is a row. In the CQL API, column families are referred to as tables. To gain some additional intuition about the data model, let's look at how data is stored in Cassandra:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- create keyspace (database)</span>\n<span class=\"token keyword\">CREATE</span> KEYSPACE hotel <span class=\"token keyword\">WITH</span> <span class=\"token keyword\">replication</span> <span class=\"token operator\">=</span>\n    {<span class=\"token string\">'class'</span>: <span class=\"token string\">'SimpleStrategy'</span><span class=\"token punctuation\">,</span>\n     <span class=\"token string\">'replication_factor'</span>: <span class=\"token number\">3</span>}<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- create table</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> hotel<span class=\"token punctuation\">.</span>employees <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">text</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">,</span>\n    name <span class=\"token keyword\">text</span><span class=\"token punctuation\">,</span>\n    roles <span class=\"token keyword\">set</span><span class=\"token punctuation\">,</span>\n    salary <span class=\"token keyword\">smallint</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- insert row</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> hotel<span class=\"token punctuation\">.</span>employees\n       JSON <span class=\"token string\">'{\"id\": \"10F-S53\",\n              \"name\": \"Susan\",\n              \"roles\": {\"accountant\", \"auditor\"}}'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>CQL is a <strong>typed language</strong> used for querying column-family databases in Cassandra. Meaning, Cassandra isn't really schemaless anymore, since data types and primary keys are required. In many ways, CQL feels like SQL, but deliberately excludes certain functionalities that violates their data model. In particular, CQL doesn't support group by operations, join operations, and others.</p>\n<p>On the flip side, CQL supports certain functionalities that aren't supported in relational databases, since they violate the relational data model and comply with the column-family data model. For example, CQL supports the use of tuples and sets as data types defined within a schema.</p>\n<p>To learn more about the details behind data manipulation with CQL, refer to <a href=\"https://cassandra.apache.org/doc/latest/cql/dml.html\" target=\"_blank\" rel=\"nofollow\">the docs</a>.</p>\n<h2>Introduction to the Cassandra Architecture</h2>\n<p>Whereas Apache HBase was created based on <a href=\"https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf\" target=\"_blank\" rel=\"nofollow\">Google's BigTable</a>, Apache Cassandra relies on a number of techniques from <a href=\"https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf\" target=\"_blank\" rel=\"nofollow\">Amazon's Dynamo</a>. For a brief comparison between HBase and BigTable, refer to <a href=\"https://stackoverflow.com/a/24860743/12777044\" target=\"_blank\" rel=\"nofollow\">this post</a>. Each node in the Dynamo system has three main components:</p>\n<ul>\n<li>Request coordination for each partitioned dataset</li>\n<li>Ring membership and failure detection</li>\n<li>Local storage engine</li>\n</ul>\n<p>Cassandra uses most of these features, but uses a storage engined based on LSM instead. To go one level deeper, Cassandra takes the following from Dynamo:</p>\n<ul>\n<li>Dataset partitioning using consistent hashing</li>\n<li>Multi-master replication</li>\n<li>Tunable levels of replication and consistency</li>\n<li>Distributed cluster management</li>\n<li>Distributed failure detection</li>\n<li>Incremental horizontal scaling on commodity hardware</li>\n</ul>\n<p>Cassandra partitions (creates shards) data across nodes using consistent hashing. In naive data hashing, keys are allocatd to buckets by hashing the key modulo the number of buckets. Cassandra takes a different approach by first hashing each node to one or more values on a continuous hash ring. These hash values representing each node are referred to as <em>tokens</em> in Cassandra. Once tokens are created, Cassandra then is able to map data points to tokens on that same hash ring. Specifically, Cassandra will receive rows, hash the primary keys of each row, and map those hash values to the hash ring. Lastly, Cassandra will map those data points to nodes by rounding their mapped hash values to the nearest token in a clockwise motion on the ring.</p>\n<p><img src=\"/6f1a2565e67c58fa0e75d7394ab3acd1/cassandrahash.svg\" alt=\"CassandraHashRing\"></p>\n<p>The use of consistent hashing for partitioning makes Cassandra a <strong>scalable</strong> and <strong>available</strong> column-family store. There are other features included in the hashing algorithm to improve potential issues with consistency, such as virtual nodes, quorums, and <a href=\"https://cassandra.apache.org/doc/latest/operating/compaction/index.html\" target=\"_blank\" rel=\"nofollow\">compaction</a>. For more details about the architecture of Cassandra and its more specific hashing features, refer to <a href=\"https://cassandra.apache.org/doc/latest/architecture/dynamo.html\" target=\"_blank\" rel=\"nofollow\">the docs</a>.</p>\n<h2>Features of Column-Family Databases</h2>\n<p>Unlike some NoSQL databases and most relational databases, Cassandra does not support transactions. Similar to key-item and document stores, wrties are atomic at the row level in Cassandra. Meaning, any transformation of multiple columns of a single row is treated as a single write operation. For more information about atomicity in Cassandra, refer to <a href=\"https://docs.datastax.com/en/cassandra-oss/2.1/cassandra/dml/dml_atomicity_c.html\" target=\"_blank\" rel=\"nofollow\">the docs</a>.</p>\n<p>Returning to the CAP theorem, Cassandra focuses on high availability and scalability. The consistency can be increased with the use of quorums. Each quorum has a replication factor, which can be adjusted to tune the level of availability within our cluster.</p>\n<p>Whereas both key-item and document databases are designed using a master-worker architecture, Cassandra uses a peer-to-peer architecture. This choice reaffirms the idea of Cassandra favoring availability and scalability, rather than consistency.</p>\n<p>Cassandra effortlessly scales with the addition of nodes. Since Cassandra doesn't promote a master node, it really doesn't need to worry about failures or spend time promoting a new master node.</p>\n<p>Lastly, Cassandra supports a fairly robust querying language called CQL. Since Cassandra isn't a relational databases, CQL still has its own limitations compared to SQL. Thus, column families will need to be designed effectively, so they are optimized for reading data.</p>\n<h2>Using Column-Family Databases</h2>\n<p>The table below outlines a few particular use cases for column-family databases. In particular, the column-family databases use Cassandra as a representative of the following use cases. Read more details about the Cassandra use cases in <a href=\"https://stackoverflow.com/a/30964048/12777044\" target=\"_blank\" rel=\"nofollow\">this post</a>. For more details about individual use cases, refer to the <em>NoSQL Distilled</em> text. For a more straightforward comparison between MongoDB and Cassandra, read <a href=\"https://phoenixnap.com/kb/cassandra-vs-mongodb\" target=\"_blank\" rel=\"nofollow\">this article</a>.</p>\n<table>\n<thead>\n<tr>\n<th>Use-Case</th>\n<th>Good or Bad?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Event logging</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Blogging sites</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Content management systems</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Real time analytics</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Page counters</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Systems requiring ACID</td>\n<td>Bad</td>\n</tr>\n<tr>\n<td>Early prototypes</td>\n<td>Bad</td>\n</tr>\n</tbody>\n</table>"}},"pageContext":{"slug":"nosql-column"}},"staticQueryHashes":["2961437231","3159585216"]}