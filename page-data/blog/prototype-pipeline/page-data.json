{"componentChunkName":"component---src-templates-blog-js","path":"/blog/prototype-pipeline","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Building a Prototyping Pipeline in Python","date":"2020-07-25"},"html":"<p>Most data science projects undergo various stages, which require communication with the business, determining use cases and opportunities with high ROIs, collecting and exploring raw data, feature engineering, and iterating through potential models.</p>\n<p>Furthermore, these stages don't usually occur in perfectly successive steps. Rather, they generally follow an iterative cycle, where we may return to a stage after making changes to another stage. Evidently, this system consists of many moving parts, which calls for a rapid prototyping environment.</p>\n<h2>Table of Contents</h2>\n<ul>\n<li><a href=\"#motivating-a-data-science-pipeline\">Motivating a Data Science Pipeline</a></li>\n<li><a href=\"#outlining-a-prototyping-pipeline\">Outlining a Prototyping Pipeline</a></li>\n<li><a href=\"#illustrating-our-project-layout\">Illustrating our Project Layout</a></li>\n<li><a href=\"#defining-a-flask-application\">Defining a Flask Application</a></li>\n<li><a href=\"#defining-nginx-configurations\">Defining NGINX Configurations</a></li>\n<li><a href=\"#defining-gunicorn-configurations\">Defining Gunicorn Configurations</a></li>\n<li><a href=\"#defining-the-dockerfile\">Defining the Dockerfile</a></li>\n</ul>\n<h2>Motivating a Data Science Pipeline</h2>\n<p>The DevOps lifecycle delineates the journey of project development. At a high level, it determines a philosophy that enforces agility and collaboration between software development and IT operations. There are 8 phases included in the DevOps lifecycle, but this post won't be going into these specifics. For details about individual phases within the DevOps lifecycle, refer to <a href=\"https://realpython.com/tutorials/devops/\" target=\"_blank\" rel=\"nofollow\">these articles</a>, which introduce DevOps solutions in Python.</p>\n<p><img src=\"/b75eb9062321a0f7411cb99f4ff6c60c/pydevops.svg\" alt=\"pydevops\"></p>\n<p>To motivate the use of a prototyping pipeline, we'll focus on the <em>plan</em> and <em>code</em> phase for most of this post. As stated previously, there are many moving parts in a data science pipeline. Generally, any prototyping pipeline will include the following steps:</p>\n<ul>\n<li>Understanding a business problem</li>\n<li>Collecting or locating any raw data</li>\n<li>Performing exploratory data analysis</li>\n<li>Performing feature engineering</li>\n<li>Building and evaluating models</li>\n<li>Deploying ultimate model</li>\n</ul>\n<p>Notice, the majority of these steps happen during the code phase, and these are only a small percentage of the complete set of operations that occur throughout the entire lifecycle. Automating these steps in a standardized environment provides benefits, such as continuous deployment, continuous testing, and process efficiency. In other words, building a rapid prototyping pipeline can help automate these steps, which facilitates project development.</p>\n<h2>Outlining a Prototyping Pipeline</h2>\n<p>When assembling my own prototyping pipelines, I personally prefer to build web applications using <a href=\"https://flask.palletsprojects.com/en/1.1.x/\" target=\"_blank\" rel=\"nofollow\">Flask</a>, rather than Django. In particular, I use <a href=\"https://dash.plotly.com/integrating-dash\" target=\"_blank\" rel=\"nofollow\">Dash</a> for quickly building data visualizations and interfaces, where Dash uses the Flask micro-framework under the hood. As a result, it is fairly straightforward to embed a Dash app at a specific route of an existing Flask app.</p>\n<p>Furthermore, a WSGI server can be used as an application server. It handles requests meant for our actual applications, which are passed on from the web server. Personally, I'll use Gunicorn for this setup, but there are many other <a href=\"https://flask.palletsprojects.com/en/1.1.x/deploying/wsgi-standalone/\" target=\"_blank\" rel=\"nofollow\">WSGI servers</a> that contain WSGI applications and serve HTTP.</p>\n<p>Similarly, there are many HTTP web servers available, but Nginx is <a href=\"https://docs.gunicorn.org/en/stable/deploy.html\" target=\"_blank\" rel=\"nofollow\">highly suggested</a> when working with Gunicorn. Again, Nginx is our web server, which accepts the client requests and handles any HTTP connections. These HTTP requests are passed on to the Gunicorn WSGI servers. When combining these components together, our pipeline begins to take the following shape:</p>\n<p><img src=\"/866f26ccf8e8c2130a8db2d309542064/prototype.svg\" alt=\"prototypepipeline\"></p>\n<p>Although Nginx sits inside the same server as the Flask web application in this example, it can be served on its own server. Also, the web server can run in a docker container that is located within or outside of the container running our web application. In a productionized environment, we may think about running the Nginx web server to help balance the load.</p>\n<p>In the Gunicorn documentation, the recommended number of workers is 2-4 workers per core. For horizontal scaling, Kubernetes is used to scale the number of deployments, each running a Gunicorn WSGI server with multiple workers. For more information about the implementation of Kubernetes, Gunicorn, and other components of our pipeline, refer to <a href=\"https://stackoverflow.com/a/51873337/12777044\" target=\"_blank\" rel=\"nofollow\">this post</a>.</p>\n<h2>Illustrating our Project Layout</h2>\n<p>All files related to Docker and Gunicorn are located in the <code class=\"language-text\">deploy</code> directory in our project layout. The files related to our Flask web application are located in the <code class=\"language-text\">src</code> directory in our project layout. Ultimately, our project layout looks like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">myapp/\n├── deploy/\n│   ├── docker-entrypoint.sh\n│   ├── Dockerfile\n│   ├── nginx.conf\n│   ├── supervisord.conf\n│   └── conf.ini\n└── src/\n    ├── __init__.py\n    └── app.py</code></pre></div>\n<p>The <code class=\"language-text\">app.py</code> contains the code for our web application. Whereas, the <code class=\"language-text\">conf.py</code> file contains configuration details for a Gunicorn WSGI server. The remaining files in the <code class=\"language-text\">deploy</code> directory mostly relate to Docker configurations.</p>\n<h2>Defining a Flask Application</h2>\n<p>In this post, we'll build a simple Flask web application running on Docker Compose. Specifically, the application outputs a request counter maintained in Redis. The following is sample code from our application:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># app.py</span>\n<span class=\"token keyword\">import</span> time\n<span class=\"token keyword\">import</span> redis\n<span class=\"token keyword\">from</span> flask <span class=\"token keyword\">import</span> Flask\n\napp <span class=\"token operator\">=</span> Flask<span class=\"token punctuation\">(</span>__name__<span class=\"token punctuation\">)</span>\ncache <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>host<span class=\"token operator\">=</span><span class=\"token string\">'redis'</span><span class=\"token punctuation\">,</span> port<span class=\"token operator\">=</span><span class=\"token number\">6379</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_hit_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  retries <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n  <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n      <span class=\"token keyword\">return</span> cache<span class=\"token punctuation\">.</span>incr<span class=\"token punctuation\">(</span><span class=\"token string\">'hits'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">except</span> redis<span class=\"token punctuation\">.</span>exceptions<span class=\"token punctuation\">.</span>ConnectionError <span class=\"token keyword\">as</span> exc<span class=\"token punctuation\">:</span>\n      <span class=\"token keyword\">if</span> retries <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">raise</span> exc\n      retries <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n      time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  count <span class=\"token operator\">=</span> get_hit_count<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'Ive been seen {} times.\\n'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span></code></pre></div>\n<p>In this exmaple, <code class=\"language-text\">redis</code> is the hostname of the redis container located on the same network as this application. We use the default port for Redis, which is <code class=\"language-text\">6379</code>. This <a href=\"https://realpython.com/flask-by-example-implementing-a-redis-task-queue/\" target=\"_blank\" rel=\"nofollow\">article</a> illustrates a more detailed example using a redis task queue. For a deeper explanation about our simple Python web application, refer to the <a href=\"https://docs.docker.com/compose/gettingstarted/\" target=\"_blank\" rel=\"nofollow\">getting-started docs</a>, which uses this example with Docker compose in greater detail.</p>\n<h2>Defining NGINX Configurations</h2>\n<p>In this post, our Nginx web server and Gunicorn WSGI server handles client requests and eventually runs our flask application as a result. Therefore, we need to configure our Nginx web server. These configurations are suggested in greater detail in the <a href=\"https://docs.gunicorn.org/en/stable/deploy.html\" target=\"_blank\" rel=\"nofollow\">Gunicorn docs</a>, but we'll simplify the file to only include barebones specifications in the <code class=\"language-text\">nginx.conf</code> file:</p>\n<div class=\"gatsby-highlight\" data-language=\"apacheconf\"><pre class=\"language-apacheconf\"><code class=\"language-apacheconf\">worker_processes 1;\n\npid /var/run/nginx.pid;\nerror_log /var/log/nginx/error.log warn;\n\nevents {\n  worker_connections 1024;\n}\n\nhttp {\n  <span class=\"token directive-inline property\">include</span> mime.types;\n  default_type application/octet-stream;\n  sendfile on;\n\n  upstream app_server {\n    server unix:/tmp/guni.sock fail_timeout=0;\n  }\n\n  server {\n    <span class=\"token directive-inline property\">listen</span> 8080;\n    server_name localhost;\n    client_max_body_size 4G;\n    keepalive_timeout 5;\n\n    root /home/dkharazi/dev/myapp/public;\n\n    location / {\n      try_files <span class=\"token variable\">$uri</span> @app;\n    }\n    location @app {\n      proxy_set_header X-Forwarded-For\n        <span class=\"token variable\">$proxy_add_x_forwarded_for</span>;\n      proxy_set_header X-Forwarded-Proto\n        <span class=\"token variable\">$scheme</span>;\n      proxy_pass\n        http://localhost:8050;\n    }\n  }\n}</code></pre></div>\n<p>Nginx configuration files are located in the <code class=\"language-text\">/etc/nginx</code> directory, where the primary configuration file refers to <code class=\"language-text\">/etc/nginx/nginx.conf</code>. In Nginx, configuration options are called <em>directives</em>, which are organized into groups known as contexts.</p>\n<p>By default, the process ID of the nginx master process is written to the <code class=\"language-text\">nginx.pid</code> file in the <code class=\"language-text\">/var/run</code> directory. Here, we are specifying the process ID to be written to that directory, but can change it to some different directory.  In a similar fashion, the error logs are written to the default directory.</p>\n<p>The <a href=\"http://nginx.org/en/docs/ngx_core_module.html#events\" target=\"_blank\" rel=\"nofollow\">events directive</a> specifies the context of the main configuration file. Here, we'll identify any directives related to the processing of connections. To keep things simple, we'll only specify the maximum number of simultaneous connections that can be opened by a worker.</p>\n<p>The <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#http\" target=\"_blank\" rel=\"nofollow\">http directive</a> specifies the context of the main configuration related to HTTP server directives. Here, we'll define some basic configurations, such as the default MIME type of a response, a flag for blocking I/O to disk, and WSGI server specifications. Additionally,  the server directive is specified, which sets configurations for our virtual server and points Nginx to the location of our web application. These configurations redefine any appending fields to the request header, which are passed to the proxied server. Specifically, they use embedded variables, such as <code class=\"language-text\">proxy_add_x_forwarded_for</code>, which refers to the remote address of the client.</p>\n<p>In our situation, we want to assign our Nginx to a port below 1024, which are privaleged ports. Also, we're informing Nginx to route all requests to the Gunicorn socket and Python application when specifying the location of <code class=\"language-text\">@app</code>.</p>\n<p>For additional detils about the more basic configurations, refer to <a href=\"http://nginx.org/en/docs/beginners_guide.html\" target=\"_blank\" rel=\"nofollow\">this guide</a>. Also, refer to <a href=\"http://nginx.org/en/docs/ngx_core_module.html\" target=\"_blank\" rel=\"nofollow\">the docs</a> for more details about the behavior of any particular syntax.</p>\n<h2>Defining Gunicorn Configurations</h2>\n<p>Again, our Nginx web server and Gunicorn WSGI server handles client requests and eventually runs our flask application as a result. Therefore, we need to configure our Gunicorn WSGI server. These configurations are suggested in greater detail in the <a href=\"https://docs.gunicorn.org/en/stable/deploy.html\" target=\"_blank\" rel=\"nofollow\">Gunicorn docs</a>, but we'll simplify the file to only include barebones specifications in the <code class=\"language-text\">conf.ini</code> file:</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token selector\">[app:server]</span>\n<span class=\"token constant\">bind</span> <span class=\"token attr-value\"><span class=\"token punctuation\">=</span> localhost:8050</span>\n<span class=\"token constant\">workers</span> <span class=\"token attr-value\"><span class=\"token punctuation\">=</span> 4</span>\n<span class=\"token constant\">name</span> <span class=\"token attr-value\"><span class=\"token punctuation\">=</span> 'myapp'</span>\n<span class=\"token constant\">daemon</span> <span class=\"token attr-value\"><span class=\"token punctuation\">=</span> True</span></code></pre></div>\n<p>The <code class=\"language-text\">bind</code> setting refers to the socket to which the Gunicorn WSGI server binds itself. The <code class=\"language-text\">workers</code> setting refers to the number of worker processes for handling requests. The recommended value for this setting is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>×</mo><mtext>num cores</mtext></mrow><annotation encoding=\"application/x-tex\">2 \\times \\text{num cores}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord\">num cores</span></span></span></span></span>. This setting should be adjusted in order to find the best for our work load, since it depends on the hardware of our server. The <code class=\"language-text\">daemon</code> setting specifies that the app will run in the background on our server. For details about more specific settings in the configuration file, refer to the <a href=\"https://docs.gunicorn.org/en/latest/settings.html\" target=\"_blank\" rel=\"nofollow\">Gunicorn docs</a>.</p>\n<h2>Defining the Dockerfile</h2>\n<p>Docker recommends running one process per container for <a href=\"https://devops.stackexchange.com/a/451\" target=\"_blank\" rel=\"nofollow\">these reasons</a>. If there is a need to run our WSGI server and Nginx web server in the same container, we can use <a href=\"https://stackoverflow.com/a/43510962/12777044\" target=\"_blank\" rel=\"nofollow\">supervisord</a> to create and manage processes based on data in its configuration file, which creates subprocesses. Docker outlines their <a href=\"https://docs.docker.com/config/containers/multi-service_container/\" target=\"_blank\" rel=\"nofollow\">best practices</a> for running multiple services within a single container.</p>\n<p>In this example, our Dockerfile builds a Python 3.7 image. We'll also define a compose file, which will reference two individual services: <code class=\"language-text\">web</code> and <code class=\"language-text\">redis</code>. Specifically, these will be outlined in the <code class=\"language-text\">docker-compose.yml</code> file. </p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> python<span class=\"token punctuation\">:</span>3.7<span class=\"token punctuation\">-</span>alpine\n<span class=\"token keyword\">WORKDIR</span> /myapp\n<span class=\"token keyword\">ENV</span> FLASK_APP app.py\n<span class=\"token keyword\">ENV</span> FLASK_RUN_HOST 0.0.0.0\n<span class=\"token keyword\">RUN</span> apk add <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>no<span class=\"token punctuation\">-</span>cache gcc musl<span class=\"token punctuation\">-</span>dev linux<span class=\"token punctuation\">-</span>headers\n<span class=\"token keyword\">COPY</span> requirements.txt requirements.txt\n<span class=\"token keyword\">RUN</span> pip install <span class=\"token punctuation\">-</span>r requirements.txt\n<span class=\"token keyword\">COPY</span> . .\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"flask\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"run\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>To translate some of these commands, the Dockerfile starts off with building an image using the Python 3.7 image. Then, it assigns the working directory to <code class=\"language-text\">/myapp</code>. Next, it sets the environment variables used by the <a href=\"https://flask.palletsprojects.com/en/1.1.x/cli/\" target=\"_blank\" rel=\"nofollow\">flask command</a>. Gcc is installed so Python packages, such as SQLAlchemy, can compile speedups. The <code class=\"language-text\">requirements.txt</code> file is copied, which installs the Python dependencies, and it is run after being copied. Then, all of the files from the current directory <code class=\"language-text\">.</code> are copied to the workdir <code class=\"language-text\">.</code> in the image. Lastly, the <code class=\"language-text\">flask run</code> command is run in the container.</p>\n<p>As stated previously, we want to define two different services, so they can run in their own individual containers. Creating a <code class=\"language-text\">docker-compose.yml</code> file will make this possible. In particular, we can create a file called <code class=\"language-text\">docker-compose.yml</code>, which will contain the following contents:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3'</span>\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">web</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span> .\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"5000:5000\"</span>\n  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"redis:alpine\"</span></code></pre></div>\n<p>The <code class=\"language-text\">web</code> service uses the Python 3.7 image built from the Dockerfile. On the other hand, the <code class=\"language-text\">redis</code> service uses the Redis image pulled from the Docker Hub registry. Port 5000 of the container is bound to port 5000 of our machine, which is the default port for the Flask web service. We can run these containers by running the following commands:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">$ </span>docker-compose up</code></pre></div>\n<p>After the command finishes executing, our container should be running. Now, we can enter <code class=\"language-text\">http://localhost:5000</code> in our browser to see the application running. For additional information about specific configurations available to the Compose file, refer to the <a href=\"https://docs.docker.com/compose/compose-file/\" target=\"_blank\" rel=\"nofollow\">Docker docs</a>.</p>"}},"pageContext":{"slug":"prototype-pipeline"}},"staticQueryHashes":["2961437231","3159585216"]}