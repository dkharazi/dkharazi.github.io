{"componentChunkName":"component---src-templates-entry-js","path":"/notes/de/other/docker","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Docker"},"html":"<h3>Describing Docker Containers</h3>\n<ul>\n<li>A <strong>container</strong> is an emulation of an operating system</li>\n<li>\n<p>A <strong>container engine</strong> is an environment for deploying containerized applications</p>\n<ul>\n<li>Docker is an example of a container engine</li>\n<li>The container engine allocates cores and memory to containers</li>\n</ul>\n</li>\n<li>\n<p>An <strong>image</strong> is a snapshot of a container</p>\n<ul>\n<li>A container is an instance of an image</li>\n<li>Specifically, a container is a running instance of an image</li>\n</ul>\n</li>\n<li>\n<p>A <strong>Dockerfile</strong> is a file containing image-instructions</p>\n<ul>\n<li>Docker builds an image by reading the instructions from a Dockerfile</li>\n<li>These instructions provide the container engine information to create an image</li>\n</ul>\n</li>\n<li>\n<p>The following analogy can be used to describe each component:</p>\n<ul>\n<li>A Dockerfile is the shopping list</li>\n<li>An image is the recipe</li>\n<li>A container is the cake</li>\n</ul>\n</li>\n<li>Containers and virtual machines can be used together:</li>\n</ul>\n<p><img src=\"/31aff7bae25d503c9bea33b32d22bdb3/docker.svg\" alt=\"containerlayer\"></p>\n<h3>Use Cases of Docker Containers</h3>\n<ol>\n<li>\n<p>Containers can perform a task <strong>independent of the host's OS</strong></p>\n<ul>\n<li>Containers break down configuration into code</li>\n<li>Containers do this without the overhead of VMs</li>\n<li>This allows containers to be deployed quicker while consuming fewer resources</li>\n</ul>\n</li>\n<li>\n<p>Containers can run many apps on a <strong>single server in isolation</strong></p>\n<ul>\n<li>Specifically, containers perform isolation at the OS level</li>\n<li>Therefore, a single OS can run multiple containers</li>\n<li>This decreases overhead by providing additional processing power to applications</li>\n</ul>\n</li>\n<li>\n<p>Containers create <strong>well-managed production environments</strong></p>\n<ul>\n<li>Actually, they can enforce other environments as well (e.g. development environment)</li>\n<li>Code changes must travel through several different environments to reach deployment</li>\n<li>Each environment is different in comparison</li>\n<li>Containers provide a constant, isolated environment</li>\n<li>Meaning, code quickly travels down a pipeline from the development environment to the production environment </li>\n</ul>\n</li>\n<li>\n<p>Containers can <strong>consolidate more servers</strong></p>\n<ul>\n<li>Containers use less memory compared to VMs</li>\n<li>Therefore, they can consolidate more servers</li>\n<li>They decrease the number of required servers</li>\n<li>This decreases the hardware costs and server management time</li>\n</ul>\n</li>\n<li>\n<p>Containers are <strong>portable environments</strong></p>\n<ul>\n<li>Containers are a form of lightweight virtualization</li>\n<li>This makes them extremely portable</li>\n<li>Cloud service providers (e.g. AWS) champion containers due to their portability</li>\n<li>They can be run within cloud environments easily</li>\n</ul>\n</li>\n</ol>\n<h3>Differentiating between Containers and VMs</h3>\n<ul>\n<li>Containers emulate an OS, whereas VMs emulate hardware</li>\n<li>Containers are more lightweight compared to VMs</li>\n<li>Containers share a host OS in contrast to VMs</li>\n<li>Containers start up in milliseconds, whereas VMs start up in minutes</li>\n<li>Containers require less memory space compared to VMs</li>\n<li>Containers are slightly less secure compared to VMs</li>\n<li>Containers maintain process-level isolation, whereas VMs are fully isolated</li>\n</ul>\n<h3>Advantages of Virtualization via Containers</h3>\n<ul>\n<li>\n<p>Cheaper hardware costs</p>\n<ul>\n<li>Due to server consolidation</li>\n<li>Enables concurrent software to take advantage of true concurrency in a multicore architecture</li>\n</ul>\n</li>\n<li>\n<p>Reliability and robustness</p>\n<ul>\n<li>Enables software failover and recovery</li>\n<li>The modularity and isolation improves reliability</li>\n<li>If a container breaks, the entire machine doesn't break as well</li>\n</ul>\n</li>\n<li>\n<p>Scalability</p>\n<ul>\n<li>A single container engine can manage very many containers</li>\n<li>This enables additional containers to be created as needed</li>\n</ul>\n</li>\n<li>\n<p>Spatial isolation</p>\n<ul>\n<li>Support lightweight spatial isolation</li>\n<li>This is because containers are given their own resources</li>\n</ul>\n</li>\n<li>\n<p>More Storage</p>\n<ul>\n<li>Containers do not emulate hardware</li>\n<li>This makes them so lightweight in terms of storage size</li>\n</ul>\n</li>\n<li>\n<p>Increased performance</p>\n<ul>\n<li>Containers increase performance compared to VMs</li>\n<li>This is because containers do not emulate hardware</li>\n</ul>\n</li>\n<li>\n<p>Real-time applications</p>\n<ul>\n<li>Containers provide more consistent timing than VMs</li>\n</ul>\n</li>\n<li>\n<p>Continuous integration</p>\n<ul>\n<li>Containers support Agile and continuous development processes</li>\n</ul>\n</li>\n<li>\n<p>Portability</p>\n<ul>\n<li>Containers support portability from development to production environments</li>\n<li>This is especially beneficial for cloud-based applications</li>\n</ul>\n</li>\n<li>\n<p>Safety</p>\n<ul>\n<li>There are some safety benefits by localizing the impact of faults and failures to individual containers</li>\n</ul>\n</li>\n<li>\n<p>Security</p>\n<ul>\n<li>The modular architecture increases the difficulty of attacks</li>\n<li>A container that is compromised can be terminated and replaced</li>\n</ul>\n</li>\n</ul>\n<h3>Disadvantages of Virtualization via Containers</h3>\n<ul>\n<li>\n<p>Shared resources</p>\n<ul>\n<li>Single points of failure exist</li>\n<li>Two applications running in the same container can interfere with each other</li>\n<li>Sofware running in different containers can interfere with each other</li>\n</ul>\n</li>\n<li>\n<p>Interference Analysis</p>\n<ul>\n<li>Shared resources imply interference</li>\n<li>The number of interference paths increases rapidly as the number of containers increases</li>\n<li>This makes the exhaustive analysis of all such paths nearly impossible</li>\n</ul>\n</li>\n<li>\n<p>Safety</p>\n<ul>\n<li>Spatial interference can cause memory clashes</li>\n</ul>\n</li>\n<li>\n<p>Security</p>\n<ul>\n<li>Data stored in containers is insecure</li>\n<li>Container processes are insecure</li>\n<li>Privileges of container services are minimized</li>\n</ul>\n</li>\n<li>\n<p>Container sprawl</p>\n<ul>\n<li>Excessive containerization is relatively common</li>\n<li>This can increase the amount of time and effort spent on container management</li>\n</ul>\n</li>\n</ul>\n<h3>Caching Images in Docker</h3>\n<ul>\n<li>\n<p>Docker images are cached on a machine once the image is built</p>\n<ul>\n<li>The image will be cached in <code class=\"language-text\">/var/lib/docker</code></li>\n</ul>\n</li>\n<li>The image won't be rebuilt, unless changes are made to the image</li>\n<li>If changes are made to the image, then Docker will rebuild it</li>\n<li>If only a few changes are made to the image, the rebuilding process won't take very long</li>\n<li>This is because Docker only needs to process those new instructions in the Dockerfile</li>\n<li>In other words, Docker will not process the unchanged instructions in the Dockerfile</li>\n<li>This is because those components are cached already</li>\n</ul>\n<h3>Mounting Host Directories to Containers</h3>\n<ul>\n<li>Host directories can be copied to containers</li>\n<li>Changes to a copied host directory on a container will not carry over to the host machine</li>\n<li>\n<p>Host directories can be mounted to containers using:</p>\n<ul>\n<li>Bind Mounts</li>\n<li>Volumes</li>\n</ul>\n</li>\n<li>With bind mounts, a file or directory on the host machine is mounted into a container</li>\n<li>With volumes, a new directory is created within Docker's storage directory on the host machine</li>\n<li>Therefore, Docker manages the content of that directory</li>\n<li>In other words, volumes are the preferred mechanism for persisting data on the host machine after the container is gone</li>\n<li>Host directories are copied when building an image</li>\n<li>Whereas, host directories are mounted when running a container</li>\n<li>\n<p>Mounting a host directory as a data volume:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-v [host_dir:container_dir]\t</code></pre></div>\n</li>\n<li>\n<p>Copying a host directory to an image:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">[</span>host_dir<span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n</ul>\n<h3>Advantages of Volumes over Bind Mounts</h3>\n<ul>\n<li>Volumes are easier to back up</li>\n<li>Volumes are easier to migrate</li>\n<li>Volumes can be managed using Docker CLI</li>\n<li>Volumes work on both Linux and Windows containers</li>\n<li>Volumes can be more safely shared among multiple containers</li>\n<li>Volume drivers allow storage of volumes on remote hosts or cloud providers</li>\n<li>Volume drivers allow encryption of volume contents</li>\n</ul>\n<hr>\n<h3>tldr</h3>\n<ul>\n<li>A virtual machine emulates underlying hardware</li>\n<li>A container emulates an operating system</li>\n<li>\n<p>A container has the following use cases:</p>\n<ol>\n<li>Performing a task independent of the host's OS</li>\n<li>Running many apps on a single server in isolation</li>\n<li>Creating well-managed production environments</li>\n<li>Consolidating more servers</li>\n<li>Creating portable environments</li>\n</ol>\n</li>\n<li>A container engine is an environment for deploying containerized applications</li>\n<li>An image is a snapshot of a container</li>\n<li>A Dockerfile is a file containing image instructions</li>\n</ul>\n<hr>\n<h3>References</h3>\n<ul>\n<li><a href=\"https://insights.sei.cmu.edu/sei_blog/2017/09/virtualization-via-containers.html\" target=\"_blank\" rel=\"nofollow\">Details about Virtualization via Containers</a></li>\n<li><a href=\"https://insights.sei.cmu.edu/sei_blog/2017/09/virtualization-via-virtual-machines.html\" target=\"_blank\" rel=\"nofollow\">Details about Virtualization via Virtual Machines</a></li>\n<li><a href=\"https://stackoverflow.com/a/16048358/12777044\" target=\"_blank\" rel=\"nofollow\">Difference between Docker Containers and Virtual Machines</a></li>\n<li><a href=\"https://stackoverflow.com/a/23736802/12777044\" target=\"_blank\" rel=\"nofollow\">Difference between Docker Containers and Images</a></li>\n<li><a href=\"https://stackoverflow.com/a/49173474/12777044\" target=\"_blank\" rel=\"nofollow\">Difference between Docker Volumes and Bind Directories</a></li>\n<li><a href=\"https://www.rcrwireless.com/20170822/five-container-use-cases-tag27-tag99\" target=\"_blank\" rel=\"nofollow\">Five Functions for Docker Containers</a></li>\n<li><a href=\"https://docs.docker.com/storage/volumes/\" target=\"_blank\" rel=\"nofollow\">Docker Volumes</a></li>\n<li><a href=\"https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-docker/manage-windows-dockerfile\" target=\"_blank\" rel=\"nofollow\">Details about the Dockerfile</a></li>\n</ul>"}},"pageContext":{"slug":"de/other/docker","previousSlug":null,"nextSlug":"de/other/tomcat","previousTitle":null,"nextTitle":"Tomcat"}},"staticQueryHashes":[]}