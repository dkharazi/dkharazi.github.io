{"componentChunkName":"component---src-templates-entry-js","path":"/notes/de/other/mq","result":{"data":{"markdownRemark":{"frontmatter":{"title":"RabbitMQ"},"html":"<h3>Defining Terminology for Pub/Sub Systems</h3>\n<ul>\n<li>A <em>producer</em> is a user application that sends messages to some user application</li>\n<li>A <em>consumer</em> is a user application that receives messages from some user application</li>\n<li>\n<p>A <em>queue</em> is an application that receives messages from a producer and decides which consumers should receive those messages</p>\n<ul>\n<li>A message is known as a <em>task</em></li>\n<li>A queue can also be referred to as a <em>broker</em></li>\n<li>Producers send messages that are immediately added to a queue</li>\n<li>Consumers wait for messages to be sent from a queue</li>\n</ul>\n</li>\n<li>\n<p>Using an analogy, an email group is similar to a queue</p>\n<ul>\n<li>Email accounts (i.e. consumers) may subscribe to an email group (i.e. a queue)</li>\n<li>Other email accounts (i.e. producers) may send emails to this email group, which will be received by those subscribed email accounts (i.e. consumers)</li>\n</ul>\n</li>\n</ul>\n<h3>Comparing a Task Queue and a Pub/Sub</h3>\n<ul>\n<li>\n<p>A <em>task queue</em> model delivers a single message to a single consumer</p>\n<ul>\n<li>In other words, a task queue receives a message from a producer and sends the message to an individual consumer</li>\n<li>A work queue can have many different consumers available for receiving a single task, but only one consumer must receive each task (not multiple)</li>\n<li>For example, a task queue may be used to distribute a large number of messages to any available consumers (or workers in this case)</li>\n</ul>\n</li>\n<li>\n<p>A <em>publisher/subscriber</em> model delivers a single message to multiple consumers</p>\n<ul>\n<li>For example, a pub/sub model may be used to send messages to multiple consumers that require the publisher's message for their application</li>\n</ul>\n</li>\n</ul>\n<h3>Defining Components of a Publisher/Subscriber Model</h3>\n<ul>\n<li>\n<p>An <em>exchange</em> receives messages from a producer and sends those messages to a specified queue</p>\n<ul>\n<li>An exhange can append the message to one or many different queues</li>\n<li>An exchange can also discard the message, but this rarely happens</li>\n<li>A few exchange types include <em>fanout</em>, <em>direct</em>, <em>topic</em>, etc.</li>\n<li>For example, a <em>fanout</em> exchange broadcasts the message to all of the queues it knows about</li>\n<li>A <em>direct</em> exchange broadcasts a message to queues matching the name given by the binding key</li>\n</ul>\n</li>\n<li>\n<p>A <em>binding</em> must be created between the exchange and the queue, so the exchange knows which queues to append its messages to</p>\n<ul>\n<li>A binding is created using the <code class=\"language-text\">queue_bind</code> function</li>\n<li>There can be multiple bindings with the same name and different queue names</li>\n<li>Binding names are specified using the <code class=\"language-text\">routing_key</code> in the <code class=\"language-text\">queue_bind</code> function</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2e29a3a41b01b7683c9f0f3b196e05db/direct_exchange.png\" alt=\"Direct Exchange\"></p>\n<h3>Illustrating a Basic Producer</h3>\n<ol>\n<li>\n<p>Connect to a queue on a machine</p>\n<ul>\n<li>The <code class=\"language-text\">host</code> parameter defines where the queue lives</li>\n<li>The queue should usually live on its own machine</li>\n</ul>\n</li>\n<li>\n<p>Create a queue called <em>hello</em></p>\n<ul>\n<li>Only one queue can exist for each unique name</li>\n<li>A best-practice is to always call it, even if a queue has already been created</li>\n<li>The <code class=\"language-text\">queue_declare</code> function can be called as many times, but only one queue will ever be created</li>\n</ul>\n</li>\n<li>\n<p>Send a message to a queue that eventually can be received by consumers</p>\n<ul>\n<li>Initialize a message using the <code class=\"language-text\">body</code> parameter</li>\n<li>The <code class=\"language-text\">routing_key</code> should match the name given to the queue</li>\n<li>The <code class=\"language-text\">exchange</code> refers to an exchange sending a publisher's message to a queue</li>\n</ul>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># producer.py</span>\n<span class=\"token keyword\">import</span> pika\n\n<span class=\"token comment\"># Connect to a queue on our local machine</span>\nconnection <span class=\"token operator\">=</span> pika<span class=\"token punctuation\">.</span>BlockingConnection<span class=\"token punctuation\">(</span>\n    pika<span class=\"token punctuation\">.</span>ConnectionParameters<span class=\"token punctuation\">(</span>host<span class=\"token operator\">=</span><span class=\"token string\">'localhost'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Create a 'hello' queue</span>\n<span class=\"token comment\"># Declaring another queue will be ignored</span>\n<span class=\"token comment\"># if a 'hello' queue exists already</span>\nchannel <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nchannel<span class=\"token punctuation\">.</span>queue_declare<span class=\"token punctuation\">(</span>queue<span class=\"token operator\">=</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Create an exchange that receives producer's messages</span>\nchannel<span class=\"token punctuation\">.</span>exchange_declare<span class=\"token punctuation\">(</span>exchange<span class=\"token operator\">=</span><span class=\"token string\">'greeting'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Send a 'Hello World!' message to any subscribed consumers</span>\nchannel<span class=\"token punctuation\">.</span>basic_publish<span class=\"token punctuation\">(</span>exchange<span class=\"token operator\">=</span><span class=\"token string\">'greeting'</span><span class=\"token punctuation\">,</span> routing_key<span class=\"token operator\">=</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> body<span class=\"token operator\">=</span><span class=\"token string\">'Hello World!'</span><span class=\"token punctuation\">)</span>\nconnection<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Illustrating a Basic Consumer</h3>\n<ol>\n<li>\n<p>Connect to a queue on a machine</p>\n<ul>\n<li>The <code class=\"language-text\">host</code> parameter defines where the queue lives</li>\n<li>The queue should usually live on its own machine</li>\n</ul>\n</li>\n<li>\n<p>Create a queue called <em>hello</em></p>\n<ul>\n<li>Only one queue can exist for each unique name</li>\n<li>A best-practice is to always call it, even if a queue has already been created</li>\n<li>The <code class=\"language-text\">queue_declare</code> function can be called as many times, but only one queue will ever be created</li>\n</ul>\n</li>\n<li>\n<p>Consume a producer's message from a queue</p>\n<ul>\n<li>Initialize a <code class=\"language-text\">callback</code> function that will be executed once the message has been received</li>\n<li>The <code class=\"language-text\">auto_ack</code> parameter refers to an acknowledgement that is sent back to the queue stating the consumer has received the queue's message, so next the message can be deleted from the queue</li>\n</ul>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># consumer.py</span>\n<span class=\"token keyword\">import</span> pika<span class=\"token punctuation\">,</span> sys<span class=\"token punctuation\">,</span> os\n\n<span class=\"token comment\"># Connect to a queue on our local machine</span>\nconnection <span class=\"token operator\">=</span> pika<span class=\"token punctuation\">.</span>BlockingConnection<span class=\"token punctuation\">(</span>\n    pika<span class=\"token punctuation\">.</span>ConnectionParameters<span class=\"token punctuation\">(</span>host<span class=\"token operator\">=</span><span class=\"token string\">'localhost'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Create a 'hello' queue</span>\n<span class=\"token comment\"># Declaring another queue will be ignored</span>\n<span class=\"token comment\"># if a 'hello' queue exists already</span>\nchannel <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nchannel<span class=\"token punctuation\">.</span>queue_declare<span class=\"token punctuation\">(</span>queue<span class=\"token operator\">=</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Print the producer's message once we receive it from the queue</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">,</span> method<span class=\"token punctuation\">,</span> properties<span class=\"token punctuation\">,</span> body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" [x] Received %r\"</span> <span class=\"token operator\">%</span> body<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Receive messages from the 'hello' queue</span>\nchannel<span class=\"token punctuation\">.</span>basic_consume<span class=\"token punctuation\">(</span>queue<span class=\"token operator\">=</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> on_message_callback<span class=\"token operator\">=</span>callback<span class=\"token punctuation\">,</span> auto_ack<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\nchannel<span class=\"token punctuation\">.</span>start_consuming<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Comparing Exchanges and Queues</h3>\n<ul>\n<li>\n<p>A producer must sends its message to an exchange</p>\n<ul>\n<li>\n<p>A producer must do at least one of the following:</p>\n<ul>\n<li>Declare an exchange</li>\n<li>Declare a queue</li>\n<li>Declare an exchange and a queue</li>\n</ul>\n</li>\n<li>A producer can declare a binding as well</li>\n<li>A producer always publishes its messages to an exchange</li>\n<li>A producer never publishes its messages to a queue directly</li>\n<li>\n<p>Publishing messages using <code class=\"language-text\">exchange=&#39;&#39;</code> (in the <code class=\"language-text\">basic_publish</code> function) will publish messages to a default exchange</p>\n<ul>\n<li>This default exchange is a pre-declared, unnamed exchange</li>\n<li>By default, this exchange creates bindings behind-the-scenes with the same name as the queue names</li>\n<li>As a result, the <code class=\"language-text\">routing_key</code> can be the queue name for a default exchange in the <code class=\"language-text\">basic_publish</code> function</li>\n</ul>\n</li>\n<li>\n<p>For all non-default exchanges, a binding must be manually created between an exchange and a queue</p>\n<ul>\n<li>This can be done using the <code class=\"language-text\">queue_bind</code> function</li>\n<li>By default, an exchange will <em>fanout</em> to all bounded queues by specifying <code class=\"language-text\">routing_key=&#39;&#39;</code> in the <code class=\"language-text\">basic_publish</code> function</li>\n<li>Each queue name must be unique, each exchange name must be unique, but there can be multiple binding names (i.e. <code class=\"language-text\">routing_key</code>) between queues and exchanges</li>\n<li>For example, an exchange could be bounded between two different queues, and a queue could be bounded between two different exchanges</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>A consumer must receive any messages from a queue</p>\n<ul>\n<li>\n<p>A consumer can do any of the following:</p>\n<ul>\n<li>Declare an exchange</li>\n<li>Declare a queue</li>\n<li>Declare an exchange and a queue</li>\n<li>Declare a binding between an exchange and a queue</li>\n</ul>\n</li>\n<li>If a queue has not already been declared, then a consumer must declare that queue before consuming/listening to a queue for any messages</li>\n<li>A consumer always receives messages from a queue</li>\n<li>A consumer never receives its messages from an exchange directly</li>\n</ul>\n</li>\n</ul>\n<h3>Illustrating a Request/Response Pattern</h3>\n<ul>\n<li>Task Queues can be used to distribute time-consuming tasks among multiple workers/consumers</li>\n<li>A request/response pattern (or RPC) involves sending a task and waiting for the task to complete before sending any response</li>\n<li>\n<p>In this example, the web layer could be a react frontend writing an order to a database</p>\n<ul>\n<li>From there, the customer will receive a response using async javascript (or react)</li>\n<li>Behind-the-scenes, a RabbitMQ/Kafka producer will publish orders to the event stream, where multiple RabbitMQ/Kafka consumers are listening</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/229045e391e94b4f6e909e5aef4f12d1/sample_events.png\" alt=\"ExamplePipeline\"></p>\n<h3>References</h3>\n<ul>\n<li><a href=\"https://www.rabbitmq.com/tutorials/tutorial-six-python.html\" target=\"_blank\" rel=\"nofollow\">Creating a Pub-Sub System for a Request-Response Pattern</a></li>\n<li><a href=\"https://www.rabbitmq.com/tutorials/tutorial-three-python.html\" target=\"_blank\" rel=\"nofollow\">RabbitMQ Tutorials and Documentation</a></li>\n<li><a href=\"https://supunbhagya.medium.com/request-driven-vs-event-driven-microservices-7b1fe40dccde\" target=\"_blank\" rel=\"nofollow\">Article comparing Request-Driven and Event-Driven Microservices</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=DXTHb9TqJOs&#x26;ab_channel=HusseinNasser\" target=\"_blank\" rel=\"nofollow\">Video about Publish-Subsribe and Request-Response Patterns</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=FMhbR_kQeHw&#x26;ab_channel=GauravSen\" target=\"_blank\" rel=\"nofollow\">Video defining the Publisher-Subscriber Model</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=rJHTK2TfZ1I&#x26;ab_channel=GauravSen\" target=\"_blank\" rel=\"nofollow\">Video defining Event-Driven Systems</a></li>\n</ul>"}},"pageContext":{"slug":"de/other/mq","previousSlug":"de/other/kubernetes","nextSlug":"de/other/kafka","previousTitle":"Kubernetes","nextTitle":"Kafka"}},"staticQueryHashes":[]}