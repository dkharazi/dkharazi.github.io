{"componentChunkName":"component---src-templates-entry-js","path":"/notes/py/flask/appcontext","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Application Contexts"},"html":"<h3>Describing the Application Context</h3>\n<ul>\n<li>\n<p>An application context tracks application-level data from:</p>\n<ul>\n<li>A request</li>\n<li>A CLI command</li>\n<li>Other activity</li>\n</ul>\n</li>\n<li>Flask avoids passing an application to each function</li>\n<li>It does this by creating objects <code class=\"language-text\">g</code> and <code class=\"language-text\">current_app</code></li>\n<li>These are proxies that can be accessed at any point</li>\n</ul>\n<h3>Issue with Importing <code class=\"language-text\">app</code> Instances</h3>\n<ul>\n<li>Every <code class=\"language-text\">Flask</code> application object has attributes</li>\n<li>The <code class=\"language-text\">config</code> attribute is one example</li>\n<li>Attributes are useful to access within views and CLI commands</li>\n<li>However, importing an <code class=\"language-text\">app</code> instance within a module is prone to circular imports</li>\n<li>An <code class=\"language-text\">app</code> instance can't be imported using the <a href=\"https://flask.palletsprojects.com/en/1.1.x/patterns/appfactories/\" target=\"_blank\" rel=\"nofollow\">app factory pattern</a></li>\n<li>Flask solves this problem with the <em>application context</em></li>\n</ul>\n<h3>The Purpose of the Application Context</h3>\n<ul>\n<li>With application contexts, we don't refer to an <code class=\"language-text\">app</code> directly</li>\n<li>Instead, we use a <code class=\"language-text\">current_app</code> proxy</li>\n<li>This points to the application handling the current activity</li>\n<li>Flask automatically pushes an application context when handling a request</li>\n<li>\n<p>The following functions have access to <code class=\"language-text\">current_app</code>:</p>\n<ul>\n<li>View functions</li>\n<li>Error handlers</li>\n<li>Other functions</li>\n</ul>\n</li>\n</ul>\n<h3>Defining the Structure of Application Contexts</h3>\n<ul>\n<li>There is a stack that manages application contexts</li>\n<li>\n<p>This stack is referred to as the application context stack</p>\n<ul>\n<li>In the code, this is <code class=\"language-text\">_app_ctx_stack</code></li>\n</ul>\n</li>\n<li>\n<p>Eac element in the stack is a single application context</p>\n<ul>\n<li>In the code, this is an <code class=\"language-text\">AppContext</code> class</li>\n</ul>\n</li>\n<li>\n<p>Each application context is essentially a list of two objects:</p>\n<ul>\n<li>A single <code class=\"language-text\">g</code> object</li>\n<li>A single <code class=\"language-text\">current_app</code> object</li>\n</ul>\n</li>\n</ul>\n<h3>Implementing an Application Context in Flask</h3>\n<ul>\n<li>Flask needs a <code class=\"language-text\">Flask</code> object to create an application context</li>\n<li>Flask needs an environment dictionary to create a request context</li>\n<li>The environment dictionary has all the client data and is taken from the browser</li>\n<li>The applications and request context are both created simultaneously</li>\n<li>\n<p>The steps include the following:</p>\n<ol>\n<li>A <code class=\"language-text\">Flask</code> object is created</li>\n<li>An application context is created when an <code class=\"language-text\">app</code> variable is assigned</li>\n<li>A request context is then created when getting an environment dictionary</li>\n<li>View functions are invoked</li>\n<li>Gain access to objects <code class=\"language-text\">g</code>, <code class=\"language-text\">current_app</code>, <code class=\"language-text\">request</code>, and <code class=\"language-text\">session</code></li>\n</ol>\n</li>\n</ul>\n<h3>Lifetieme of the Context</h3>\n<ul>\n<li>The application context is created and destroyed as necessary</li>\n<li>A Flask application begins by handling a request</li>\n<li>Then, it pushes an application context and a request context</li>\n<li>\n<p>Once a request ends, it does the following:</p>\n<ul>\n<li>Pops the request context</li>\n<li>Then, pops the application context</li>\n</ul>\n</li>\n<li>Typically, an application context will have the same lifetime as a request</li>\n</ul>\n<h3>Storing Data with the Application Context</h3>\n<ul>\n<li>The application context is used for storing common data</li>\n<li>Specifically, this data refers to a request or CLI command</li>\n<li>\n<p>Flask provides the <code class=\"language-text\">g</code> object for this purpose</p>\n<ul>\n<li><code class=\"language-text\">g</code> stands for <code class=\"language-text\">global</code></li>\n<li>This refers to data being global <em>within</em> a context</li>\n</ul>\n</li>\n<li>The data on <code class=\"language-text\">g</code> is lost after the context ends</li>\n<li>\n<p>Implying, it is not used for storing data between requests</p>\n<ul>\n<li>To store data across requests, we can use <code class=\"language-text\">session</code> or store data in a database</li>\n</ul>\n</li>\n<li>It is a simple namespace object that has the same lifetime as an application context</li>\n</ul>\n<h3>References</h3>\n<ul>\n<li><a href=\"https://flask.palletsprojects.com/en/1.1.x/appcontext/\" target=\"_blank\" rel=\"nofollow\">Basics of the Application Context</a></li>\n<li><a href=\"https://flask.palletsprojects.com/en/1.1.x/patterns/appfactories/\" target=\"_blank\" rel=\"nofollow\">Describing App Factory Patterns</a></li>\n</ul>"}},"pageContext":{"slug":"py/flask/appcontext","previousSlug":"py/flask/view","nextSlug":"py/flask/reqcontext","previousTitle":"Views","nextTitle":"Request Contexts"}},"staticQueryHashes":[]}