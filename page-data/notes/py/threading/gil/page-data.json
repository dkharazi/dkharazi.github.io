{"componentChunkName":"component---src-templates-entry-js","path":"/notes/py/threading/gil","result":{"data":{"markdownRemark":{"frontmatter":{"title":"The GIL"},"html":"<h3>Defining the Global Interpreter Lock</h3>\n<ul>\n<li>The Global Interpreter Lock (GIL) is a boolean value in the CPython interpreter</li>\n<li>This boolean value is protected by a mutex</li>\n<li>Specifically, the GIL represents which thread is currently executing statements</li>\n<li>The GIL is used by the core bytecode evaluation loop in CPython</li>\n</ul>\n<h3>Generalizing the Problem caused by the GIL</h3>\n<ul>\n<li>CPython supports multiple threads within a single interpreter</li>\n<li>However, threads must request access to the GIL in order</li>\n<li>Without access, threads can't execute <em>Opcodes</em> (low-level operations)</li>\n<li>As a result, multiple threads of a single process can only use a single core</li>\n</ul>\n<h3>Describing the Behavior of the GIL</h3>\n<ul>\n<li>Threads hold the GIL when running</li>\n<li>However, they release the GIL when blocking for I/O</li>\n<li>Meaning, other available threads will run when a thread is paused</li>\n<li>On the other hand, CPU-bound threads will periodically perform checks</li>\n<li>Specifically, each thread is paused if it is still running after 100 interpreter <em>ticks</em></li>\n<li>The check interval is a global counter that is completely independent of thread scheduling</li>\n<li>In other words, two threads <em>could</em> run in parallel if they don't need access to the CPython interpreter</li>\n<li>\n<p>This happens for the following scenarios:</p>\n<ul>\n<li>I/O requests</li>\n<li>Threads using C extensions</li>\n</ul>\n</li>\n</ul>\n<h3>Achieving Concurrency in CPython</h3>\n<ul>\n<li>We need to use multiple processes to achieve true concurrency</li>\n<li>Specifically, we can run multiple processes in parallel, rather than running multiple threads</li>\n<li>The standard CPython library includes a multiprocessing module</li>\n<li>Multiprocessing is a wrapper around the spawning of CPython processes</li>\n<li>Each process has its own GIL</li>\n<li>However, threads are more lightweight compared to processes</li>\n<li>Specifically, their startup times and memory usages are high</li>\n<li>Also, threads run in different memory spaces</li>\n<li>On the other hand, processes run in the same memory spaces</li>\n<li>Thus, sharing objects between processes becomes hard</li>\n</ul>\n<h3>A Lesser Known Problem Caused by the GIL</h3>\n<ul>\n<li>The GIL causes a process to run on only one CPU core</li>\n<li>Implying, the threads of that process can only run on one core</li>\n<li>The GIL has another problem that is somewhat related</li>\n<li>\n<p>Specifically, it prioritizes CPU bound threads over I/O bound threads</p>\n<ul>\n<li>\n<p>This is a huge problem, since the GIL also causes:</p>\n<ul>\n<li>CPU bound threads to run on a single core</li>\n<li>I/O bound threads to run on multiple cores</li>\n<li>Meaning, the CPU bound threads block the I/O bound threads</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>This contrasts to how the OS handles thread scheduling</p>\n<ul>\n<li>The OS prioritizes short-running tasks</li>\n</ul>\n</li>\n</ul>\n<h3>When to Use Threads in Python</h3>\n<ul>\n<li>Threads should only be reserved for programs concerned with I/O</li>\n<li>A good use case of I/O bound threads are network servers</li>\n<li>\n<p>For CPU bound threads, consider using:</p>\n<ul>\n<li>C extension modules</li>\n<li>multiprocesssing module</li>\n</ul>\n</li>\n<li>A C extension module could be <code class=\"language-text\">numpy</code></li>\n<li>Multiprocessing involves creating a separate process</li>\n</ul>\n<h3>References</h3>\n<ul>\n<li><a href=\"http://index-of.co.uk/Python/Python%20Essential%20Reference,%20Fourth%20Edition.pdf\" target=\"_blank\" rel=\"nofollow\">Python Essential Reference</a></li>\n<li><a href=\"https://www.arp.com/medias/13916546.pdf\" target=\"_blank\" rel=\"nofollow\">Python in a Nuteshell</a></li>\n<li><a href=\"https://wiki.python.org/moin/GlobalInterpreterLock\" target=\"_blank\" rel=\"nofollow\">Python's Definition of the GIL</a></li>\n<li><a href=\"https://stackoverflow.com/a/1294402/12777044\" target=\"_blank\" rel=\"nofollow\">What is the GIL?</a></li>\n<li><a href=\"https://stackoverflow.com/a/36820528/12777044\" target=\"_blank\" rel=\"nofollow\">How the GIL Works for I/O Bound Threads</a></li>\n<li><a href=\"https://medium.com/hackernoon/has-the-python-gil-been-slain-9440d28fa93d\" target=\"_blank\" rel=\"nofollow\">Recent State of GIL</a></li>\n<li><a href=\"https://stackoverflow.com/a/49938239/12777044\" target=\"_blank\" rel=\"nofollow\">Python Web Applications and the GIL</a></li>\n<li><a href=\"http://www.dabeaz.com/python/GIL.pdf\" target=\"_blank\" rel=\"nofollow\">Detailed Lecture Slides about Python GIL and Threads</a></li>\n<li><a href=\"https://stackoverflow.com/a/55309364/12777044\" target=\"_blank\" rel=\"nofollow\">Multithreaded I/O and CPU Bounded Threads</a></li>\n<li><a href=\"https://stackoverflow.com/a/3044626/12777044\" target=\"_blank\" rel=\"nofollow\">Multithreading and Multiprocessing in Python</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=MCs5OvhV9S4\" target=\"_blank\" rel=\"nofollow\">Building a Web Service from Scratch</a></li>\n</ul>"}},"pageContext":{"slug":"py/threading/gil","previousSlug":"py/threading/interpreter","nextSlug":"py/threading/io","previousTitle":"Compilers and Interpreters","nextTitle":"CPU and I/O Bound"}},"staticQueryHashes":[]}