{"componentChunkName":"component---src-templates-entry-js","path":"/notes/py/threading/interpreter","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Compilers and Interpreters"},"html":"<h3>Defining Bytecode</h3>\n<ul>\n<li>Bytecode is used in Java, Python, and other languages</li>\n<li>However, not all bytecode is created equal</li>\n<li>Bytecode is a generic term for an intermediate language used by compilers and interpreters</li>\n<li>For example, Java bytecode contains information about primitive data types</li>\n<li>On the other hand, Python bytecode does not contain this information</li>\n<li>As a result, the Python virtual machine (PVM) is slower than the Java virtual machine (JVM)</li>\n<li>Specifically, the bytecode in the PVM takes longer to execute than the bytecode in the JVM</li>\n</ul>\n<h3>Differentiating between Compilers and Interpreters</h3>\n<ul>\n<li>\n<p>An interpreter is a program that executes a given language to receive some desired output</p>\n<ul>\n<li>The program is a function, the language is our input, and some expected outcome is our output</li>\n<li>This program is typically machine code</li>\n<li>This language can be bytecode, other machine code, etc.</li>\n<li>\n<p>This language can be high-level or low-level</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">source language, input --&gt; | interpreter | --&gt; output</code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>A compiler is a program that translates a source language into a destination language</p>\n<ul>\n<li>The program is a function, the source language is our input, and the destination language is our output</li>\n<li>This program can be written in many different languages</li>\n<li>This source language is usually some higher-level language</li>\n<li>\n<p>This destination language is usually some lower-level equivalent</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">source language --&gt; | compiler | --&gt; destination language</code></pre></div>\n</li>\n</ul>\n</li>\n<li>Roughly, a compiler is nothing more than a language translator</li>\n<li>Roughly, an interpreter is just a CPU emulator</li>\n<li>A CPU is an interpreter of machine code</li>\n</ul>\n<h3>Compilation and Interpretation of CPython</h3>\n<ol>\n<li>\n<p>A CPython compiler translates source code into CPython bytecode</p>\n<ul>\n<li>The source code is a .py file</li>\n<li>The bytecode is a .pyc file</li>\n<li>The CPython compiler is written in Python and C</li>\n<li>The bytecode is cached in a pycache folder</li>\n<li>The program will run this bytecode unless any changes are made to the program</li>\n</ul>\n</li>\n<li>\n<p>A CPython interpreter executes bytecode in a Python virtual machine (PVM)</p>\n<ul>\n<li>The interpreter is a precompiled C program</li>\n<li>Meaning, the interpreter is machine code</li>\n<li>The bytecode is read in to the interpreter similar to how a text file is read in C</li>\n<li>Meaning, the Python program is never actually converted into machine code</li>\n<li>Instead, the machine code (i.e. interpreter) executes the Python program (as bytecode)</li>\n<li>Thus, the machine code (i.e. interpreter) returns the desired output of the program</li>\n</ul>\n</li>\n</ol>\n<h3>Comparing the PVM and JVM</h3>\n<ul>\n<li>During run-time, the bytecode is interpreted by a JVM interpreter within the JVM</li>\n<li>Before interpretation, a JIT compiler compiles the bytecode into machine code within the JVM</li>\n<li>Unlike Python, Java is able to do this because Java is statically-typed</li>\n<li>Therefore, type checking has already happened during compile-time</li>\n<li>\n<p>Returning to the illustration of an interpreter, the JVM interpreter looks like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">bytecode, input --&gt; | JVM interpreter | --&gt; output</code></pre></div>\n</li>\n<li>Since the data types of input are known, a JIT compiler can be used at run-time</li>\n<li>\n<p>Therefore, the JVM compilation process looks like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">bytecode --&gt; | JIT compiler | --&gt; machine code</code></pre></div>\n</li>\n<li>\n<p>With the addition of the JIT compiler at run-time, the JVM interpreter now looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">machine code, input --&gt; | JVM interpreter | --&gt; output</code></pre></div>\n</li>\n<li>Bytecode is platform dependent</li>\n<li>Machine code is platform dependent</li>\n<li>Specifically, there is different machine code for different processors</li>\n<li>This is why the JIT compiler exists within the JVM and can't be compiled beforehand</li>\n</ul>\n<h3>Highlighting Differences in Compile and Run Time</h3>\n<ul>\n<li>\n<p>At compile time:</p>\n<ul>\n<li>Language syntax is checked</li>\n<li>Data types are checked for statically-typed languages</li>\n</ul>\n</li>\n<li>\n<p>At run time:</p>\n<ul>\n<li>Computations such as addition, division, etc.</li>\n<li>Data types are checked for dynamically-typed languages</li>\n</ul>\n</li>\n</ul>\n<h3>Summarizing Static and Dynamic Languages</h3>\n<ul>\n<li>Generally, a dynamically-typed language executes many common programming behaviors at runtime</li>\n<li>A statically-typed language is able to execute these behaviors at compile time</li>\n<li>This is because statically-typed languages give the compiler much more information (e.g. variable types, etc.)</li>\n<li>Specifically, the compiler has information about the structure of the program and its data</li>\n<li>With this information, the compiler will be able to optimize both memory access and computations</li>\n<li>As a result, statically-typed languages are generally faster than dynamically-typed languages</li>\n</ul>\n<h3>Challenges of Writing Compilers for Python</h3>\n<ul>\n<li>Essentially, the bytecode of a statically-typed language will run faster compared to the bytecode of a dynamically-typed language</li>\n<li>\n<p>This is because bytecode of statically-typed languages still need to determine information like variable types</p>\n<ul>\n<li>Statically-typed languages have already done this</li>\n<li>Dynamically-typed languages need to do this because a user could pass a variable as a list, integer, etc. at runtime</li>\n</ul>\n</li>\n<li>\n<p>To effectively compile dynamically-typed languages:</p>\n<ol>\n<li>Enforce a static structure of data</li>\n<li>Infer the types of all variables, classes, etc.</li>\n</ol>\n</li>\n<li>A compiler of a dynamically-typed language could enforce the above conditions</li>\n<li>However, implementing these additional checks and inferences leads to larger bytecode</li>\n<li>Meaning, running the bytecode becomes slower</li>\n</ul>\n<h3>References</h3>\n<ul>\n<li><a href=\"http://index-of.co.uk/Python/Python%20Essential%20Reference,%20Fourth%20Edition.pdf\" target=\"_blank\" rel=\"nofollow\">Python Essential Reference</a></li>\n<li><a href=\"https://www.arp.com/medias/13916546.pdf\" target=\"_blank\" rel=\"nofollow\">Python in a Nuteshell</a></li>\n<li><a href=\"https://softwareengineering.stackexchange.com/a/269878\" target=\"_blank\" rel=\"nofollow\">Understanding Differences between Compilers</a></li>\n<li><a href=\"https://stackoverflow.com/a/2998544/12777044\" target=\"_blank\" rel=\"nofollow\">Python as an Interpreted Language</a></li>\n<li><a href=\"https://stackoverflow.com/a/1732383/12777044\" target=\"_blank\" rel=\"nofollow\">Differences between Python and Java Bytecode</a></li>\n<li><a href=\"https://stackoverflow.com/a/2998750/12777044\" target=\"_blank\" rel=\"nofollow\">Compilation Strategies of Python Implementation</a></li>\n<li><a href=\"https://stackoverflow.com/a/3265602/12777044\" target=\"_blank\" rel=\"nofollow\">Compiled and Interpreted Languages</a></li>\n<li><a href=\"https://softwareengineering.stackexchange.com/a/243274\" target=\"_blank\" rel=\"nofollow\">Why isn't there a Python Compiler?</a></li>\n<li><a href=\"https://stackoverflow.com/q/19916729/12777044\" target=\"_blank\" rel=\"nofollow\">How Python Bytecode Runs in CPython</a></li>\n<li><a href=\"https://stackoverflow.com/a/48334180/12777044\" target=\"_blank\" rel=\"nofollow\">Describing the JIT Compiler</a></li>\n<li><a href=\"https://stackoverflow.com/a/2377288/12777044\" target=\"_blank\" rel=\"nofollow\">Difference between Compilers and Interpreters</a></li>\n<li><a href=\"https://stackoverflow.com/a/21475819/12777044\" target=\"_blank\" rel=\"nofollow\">Confusion between Compilers and Interpreters</a></li>\n<li><a href=\"https://cs.lmu.edu/~ray/notes/introcompilers/\" target=\"_blank\" rel=\"nofollow\">Lecture Notes about Compilers</a></li>\n<li><a href=\"https://softwareengineering.stackexchange.com/a/111471\" target=\"_blank\" rel=\"nofollow\">Definitions of Compilers and Interpreters</a></li>\n<li><a href=\"https://softwareengineering.stackexchange.com/a/300608\" target=\"_blank\" rel=\"nofollow\">Interpreters and Machine Code</a></li>\n<li><a href=\"https://stackoverflow.com/a/846421/12777044\" target=\"_blank\" rel=\"nofollow\">Runtime and Compile Time</a></li>\n<li><a href=\"https://softwareengineering.stackexchange.com/a/181947\" target=\"_blank\" rel=\"nofollow\">Challenges of Compilers for Dynamically Typed Languages</a></li>\n</ul>"}},"pageContext":{"slug":"py/threading/interpreter","previousSlug":"py/threading/parallelism","nextSlug":"py/threading/gil","previousTitle":"Parallelism","nextTitle":"The GIL"}},"staticQueryHashes":[]}